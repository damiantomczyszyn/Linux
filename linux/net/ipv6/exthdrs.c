ackwards for a lock dependency,
 * 	for a lock dependency A -> B, there are two lock_lists:
 *
 * 	a)	lock_list in the ->locks_after list of A, whose ->class is B and
 * 		->links_to is A. In this case, we can say the lock_list is
 * 		"A -> B" (forwards case).
 *
 * 	b)	lock_list in the ->locks_before list of B, whose ->class is A
 * 		and ->links_to is B. In this case, we can say the lock_list is
 * 		"B <- A" (bacwards case).
 *
 * 	The ->trace of both a) and b) point to the call trace where B was
 * 	acquired with A held.
 *
 * 2)	A "helper" lock_list is introduced during BFS, this lock_list doesn't
 * 	represent a certain lock dependency, it only provides an initial entry
 * 	for BFS. For example, BFS may introduce a "helper" lock_list whose
 * 	->class is A, as a result BFS will search all dependencies starting with
 * 	A, e.g. A -> B or A -> C.
 *
 * 	The notation of a forwards helper lock_list is like "-> A", which means
 * 	we should search the forwards dependencies starting with "A", e.g A -> B
 * 	or A -> C.
 *
 * 	The notation of a bacwards helper lock_list is like "<- B", which means
 * 	we should search the backwards dependencies ending with "B", e.g.
 * 	B <- A or B <- C.
 */

/*
 * printk the shortest lock dependencies from @root to @leaf in reverse order.
 *
 * We have a lock dependency path as follow:
 *
 *    @root                                                                 @leaf
 *      |                                                                     |
 *      V                                                                     V
 *	          ->parent                                   ->parent
 * | lock_list | <--------- | lock_list | ... | lock_list  | <--------- | lock_list |
 * |    -> L1  |            | L1 -> L2  | ... |Ln-2 -> Ln-1|            | Ln-1 -> Ln|
 *
 * , so it's natural that we start from @leaf and print every ->class and
 * ->trace until we reach the @root.
 */
static void __used
print_shortest_lock_dependencies(struct lock_list *leaf,
				 struct lock_list *root)
{
	struct lock_list *entry = leaf;
	int depth;

	/*compute depth from generated tree by BFS*/
	depth = get_lock_depth(leaf);

	do {
		print_lock_class_header(entry->class, depth);
		printk("%*s ... acquired at:\n", depth, "");
		print_lock_trace(entry->trace, 2);
		printk("\n");

		if (depth == 0 && (entry != root)) {
			printk("lockdep:%s bad path found in chain graph\n", __func__);
			break;
		}

		entry = get_lock_parent(entry);
		depth--;
	} while (entry && (depth >= 0));
}

/*
 * printk the shortest lock dependencies from @leaf to @root.
 *
 * We have a lock dependency path (from a backwards search) as follow:
 *
 *    @leaf                                                                 @root
 *      |                                                                     |
 *      V                                                                     V
 *	          ->parent                                   ->parent
 * | lock_list | ---------> | lock_list | ... | lock_list  | ---------> | lock_list |
 * | L2 <- L1  |            | L3 <- L2  | ... | Ln <- Ln-1 |            |    <- Ln  |
 *
 * , so when we iterate from @leaf to @root, we actually print the lock
 * dependency path L1 -> L2 -> .. -> Ln in the non-reverse order.
 *
 * Another thing to notice here is that ->class of L2 <- L1 is L1, while the
 * ->trace of L2 <- L1 is the call trace of L2, in fact we don't have the call
 * trace of L1 in the dependency path, which is alright, because most of the
 * time we can figure out where L1 is held from the call trace of L2.
 */
static void __used
print_shortest_lock_dependencies_backwards(struct lock_list *leaf,
					   struct lock_list *root)
{
	struct lock_list *entry = leaf;
	const struct lock_trace *trace = NULL;
	int depth;

	/*compute depth from generated tree by BFS*/
	depth = get_lock_depth(leaf);

	do {
		print_lock_class_header(entry->class, depth);
		if (trace) {
			printk("%*s ... acquired at:\n", depth, "");
			print_lock_trace(trace, 2);
			printk("\n");
		}

		/*
		 * Record the pointer to the trace for the next lock_list
		 * entry, see the comments for the function.
		 */
		trace = entry->trace;

		if (depth == 0 && (entry != root)) {
			printk("lockdep:%s bad path found in chain graph\n", __func__);
			break;
		}

		entry = get_lock_parent(entry);
		depth--;
	} while (entry && (depth >= 0));
}

static void
print_irq_lock_scenario(struct lock_list *safe_entry,
			struct lock_list *unsafe_entry,
			struct lock_class *prev_class,
			struct lock_class *next_class)
{
	struct lock_class *safe_class = safe_entry->class;
	struct lock_class *unsafe_class = unsafe_entry->class;
	struct lock_class *middle_class = prev_class;

	if (middle_class == safe_class)
		middle_class = next_class;

	/*
	 * A direct locking problem where unsafe_class lock is taken
	 * directly by safe_class lock, then all we need to show
	 * is the deadlock scenario, as it is obvious that the
	 * unsafe lock is taken under the safe lock.
	 *
	 * But if there is a chain instead, where the safe lock takes
	 * an intermediate lock (middle_class) where this lock is
	 * not the same as the safe lock, then the lock chain is
	 * used to describe the problem. Otherwise we would need
	 * to show a different CPU case for each link in the chain
	 * from the safe_class lock to the unsafe_class lock.
	 */
	if (middle_class != unsafe_class) {
		printk("Chain exists of:\n  ");
		__print_lock_name(safe_class);
		printk(KERN_CONT " --> ");
		__print_lock_name(middle_class);
		printk(KERN_CONT " --> ");
		__print_lock_name(unsafe_class);
		printk(KERN_CONT "\n\n");
	}

	printk(" Possible interrupt unsafe locking scenario:\n\n");
	printk("       CPU0                    CPU1\n");
	printk("       ----                    ----\n");
	printk("  lock(");
	__print_lock_name(unsafe_class);
	printk(KERN_CONT ");\n");
	printk("                               local_irq_disable();\n");
	printk("                               lock(");
	__print_lock_name(safe_class);
	printk(KERN_CONT ");\n");
	printk("                               lock(");
	__print_lock_name(middle_class);
	printk(KERN_CONT ");\n");
	printk("  <Interrupt>\n");
	printk("    lock(");
	__print_lock_name(safe_class);
	printk(KERN_CONT ");\n");
	printk("\n *** DEADLOCK ***\n\n");
}

static void
print_bad_irq_dependency(struct task_struct *curr,
			 struct lock_list *prev_root,
			 struct lock_list *next_root,
			 struct lock_list *backwards_entry,
			 struct lock_list *forwards_entry,
			 struct held_lock *prev,
			 struct held_lock *next,
			 enum lock_usage_bit bit1,
			 enum lock_usage_bit bit2,
			 const char *irqclass)
{
	if (!debug_locks_off_graph_unlock() || debug_locks_silent)
		return;

	pr_warn("\n");
	pr_warn("=====================================================\n");
	pr_warn("WARNING: %s-safe -> %s-unsafe lock order detected\n",
		irqclass, irqclass);
	print_kernel_ident();
	pr_warn("-----------------------------------------------------\n");
	pr_warn("%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\n",
		curr->comm, task_pid_nr(curr),
		lockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,
		curr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,
		lockdep_hardirqs_enabled(),
		curr->softirqs_enabled);
	print_lock(next);

	pr_warn("\nand this task is already holding:\n");
	print_lock(prev);
	pr_warn("which would create a new lock dependency:\n");
	print_lock_name(hlock_class(prev));
	pr_cont(" ->");
	print_lock_name(hlock_class(next));
	pr_cont("\n");

	pr_warn("\nbut this new dependency connects a %s-irq-safe lock:\n",
		irqclass);
	print_lock_name(backwards_entry->class);
	pr_warn("\n... which became %s-irq-safe at:\n", irqclass);

	print_lock_trace(backwards_entry->class->usage_traces[bit1], 1);

	pr_warn("\nto a %s-irq-unsafe lock:\n", irqclass);
	print_lock_name(forwards_entry->class);
	pr_warn("\n... which became %s-irq-unsafe at:\n", irqclass);
	pr_warn("...");

	print_lock_trace(forwards_entry->class->usage_traces[bit2], 1);

	pr_warn("\nother info that might help us debug this:\n\n");
	print_irq_lock_scenario(backwards_entry, forwards_entry,
				hlock_class(prev), hlock_class(next));

	lockdep_print_held_locks(curr);

	pr_warn("\nthe dependencies between %s-irq-safe lock and the holding lock:\n", irqclass);
	print_shortest_lock_dependencies_backwards(backwards_entry, prev_root);

	pr_warn("\nthe dependencies between the lock to be acquired");
	pr_warn(" and %s-irq-unsafe lock:\n", irqclass);
	next_root->trace = save_trace();
	if (!next_root->trace)
		return;
	print_shortest_lock_dependencies(forwards_entry, next_root);

	pr_warn("\nstack backtrace:\n");
	dump_stack();
}

static const char *state_names[] = {
#define LOCKDEP_STATE(__STATE) \
	__stringify(__STATE),
#include "lockdep_states.h"
#undef LOCKDEP_STATE
};

static const char *state_rnames[] = {
#define LOCKDEP_STATE(__STATE) \
	__stringify(__STATE)"-READ",
#include "lockdep_states.h"
#undef LOCKDEP_STATE
};

static inline const char *state_name(enum lock_usage_bit bit)
{
	if (bit & LOCK_USAGE_READ_MASK)
		return state_rnames[bit >> LOCK_USAGE_DIR_MASK];
	else
		return state_names[bit >> LOCK_USAGE_DIR_MASK];
}

/*
 * The bit number is encoded like:
 *
 *  bit0: 0 exclusive, 1 read lock
 *  bit1: 0 used in irq, 1 irq enabled
 *  bit2-n: state
 */
static int exclusive_bit(int new_bit)
{
	int state = new_bit & LOCK_USAGE_STATE_MASK;
	int dir = new_bit & LOCK_USAGE_DIR_MASK;

	/*
	 * keep state, bit flip the direction and strip read.
	 */
	return state | (dir ^ LOCK_USAGE_DIR_MASK);
}

/*
 * Observe that when given a bitmask where each bitnr is encoded as above, a
 * right shift of the mask transforms the individual bitnrs as -1 and
 * conversely, a left shift transforms into +1 for the individual bitnrs.
 *
 * So for all bits whose number have LOCK_ENABLED_* set (bitnr1 == 1), we can
 * create the mask with those bit numbers using LOCK_USED_IN_* (bitnr1 == 0)
 * instead by subtracting the bit number by 2, or shifting the mask right by 2.
 *
 * Similarly, bitnr1 == 0 becomes bitnr1 == 1 by adding 2, or shifting left 2.
 *
 * So split the mask (note that LOCKF_ENABLED_IRQ_ALL|LOCKF_USED_IN_IRQ_ALL is
 * all bits set) and recompose with bitnr1 flipped.
 */
static unsigned long invert_dir_mask(unsigned long mask)
{
	unsigned long excl = 0;

	/* Invert dir */
	excl |= (mask & LOCKF_ENABLED_IRQ_ALL) >> LOCK_USAGE_DIR_MASK;
	excl |= (mask & LOCKF_USED_IN_IRQ_ALL) << LOCK_USAGE_DIR_MASK;

	return excl;
}

/*
 * Note that a LOCK_ENABLED_IRQ_*_READ usage and a LOCK_USED_IN_IRQ_*_READ
 * usage may cause deadlock too, for example:
 *
 * P1				P2
 * <irq disabled>
 * write_lock(l1);		<irq enabled>
 *				read_lock(l2);
 * write_lock(l2);
 * 				<in irq>
 * 				read_lock(l1);
 *
 * , in above case, l1 will be marked as LOCK_USED_IN_IRQ_HARDIRQ_READ and l2
 * will marked as LOCK_ENABLE_IRQ_HARDIRQ_READ, and this is a possible
 * deadlock.
 *
 * In fact, all of the following cases may cause deadlocks:
 *
 * 	 LOCK_USED_IN_IRQ_* -> LOCK_ENABLED_IRQ_*
 * 	 LOCK_USED_IN_IRQ_*_READ -> LOCK_ENABLED_IRQ_*
 * 	 LOCK_USED_IN_IRQ_* -> LOCK_ENABLED_IRQ_*_READ
 * 	 LOCK_USED_IN_IRQ_*_READ -> LOCK_ENABLED_IRQ_*_READ
 *
 * As a result, to calculate the "exclusive mask", first we invert the
 * direction (USED_IN/ENABLED) of the original mask, and 1) for all bits with
 * bitnr0 set (LOCK_*_READ), add those with bitnr0 cleared (LOCK_*). 2) for all
 * bits with bitnr0 cleared (LOCK_*_READ), add those with bitnr0 set (LOCK_*).
 */
static unsigned long exclusive_mask(unsigned long mask)
{
	unsigned long excl = invert_dir_mask(mask);

	excl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;
	excl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;

	return excl;
}

/*
 * Retrieve the _possible_ original mask to which @mask is
 * exclusive. Ie: this is the opposite of exclusive_mask().
 * Note that 2 possible original bits can match an exclusive
 * bit: one has LOCK_USAGE_READ_MASK set, the other has it
 * cleared. So both are returned for each exclusive bit.
 */
static unsigned long original_mask(unsigned long mask)
{
	unsigned long excl = invert_dir_mask(mask);

	/* Include read in existing usages */
	excl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;
	excl |= (excl & LOCKF_  ƒ|$`"‡  ‹D$`Ύ€    ‰D$…ΐ  „   έ    ‰\$q‰L$$‰σ‰t$‹4$‰υ‹vhέ…φtz8  ‰l$ ‰D$‹D$‹l†‰κƒβuZ‹D$‹D$‹DΖ9Θuλ>΄&    ƒΒ‹ 9Αt‹X…Ϋuπ‹X…Ϋtμ‹[…Ϋuβ‹ 9Αuεt& ƒϊ‡'  „(  ‹vh…φu—‹l$ ‹4$‹\$ή‰D$‹€4  9Εt‹D$9„μ  …  ‹D$‹4  9έ„C  ‰Ψ1λt& ƒΒ‹ 9Εt‹p…φuπ‹H…Ιtμ‹I…Ιuβ‹ 9Εuεt& ƒϊ?‡1  φD$d„  ‹L$‹T$‰Ψ΄&    v …t9xu9Ο…·   …t	;P„   ‹ 9Εuά‹T$‹D$…uιΥ   v ‹9έ„  ;Cuρϋ π‡Ξ  ‰ω…„λ  ‹$‰\$‰Λ1φ‹€”   ‹P@‹@<‰D$(‹D$`‰T$,‰D$0‹C(‹„°x  …ΐt1ΙT$(θό‰D΄4…ΐ„w  ƒώtj‹C(Ύ   ‹„°x  …ΐuΡλζt& Ύκ‹D$Dd+    …>  ƒΔH‰π[^_]ΓφD$d…¬  t& ‹D$‹€4  9Ε…=1ΫιB΄&    ‹\$…Ϋtu‹D$‹k‰{‹L$‹|$‰C‹D$4‰ϊ‰C‹D$8‰C‹$‰Έμ  θόυ‰Ζ…ΐ…ϊ   …ν„   ‰θθό‹<$‹L$`1φ‹D$<‰ϊθό‹L$`‹D$@‰ϊθόι8΅   Ή   Ίΐ  θό‰Γ…ΐ„C  ‹t$‹L$‰+‹†8  ‰8  ‰C‰‹D$‰{‹|$‰C‹D$4‰ϊ‰C‹D$8‰C‹$‰Έμ  θUυ‰Ζ…ΐ…²   ‹D$$ΰϋθόιU΄&    ‰ς‰Ψθό‰D΄4= π‡Ύ   ‰D΄<ιhώ΄&    ‹D$‹Hι	ώt& …νt[‰k‹D$<ΗC    θό‹D$@θόιPώv ιΨό‰θ‹l$ ¨…ΥόΎι.ώ‹D$Ύώ…ΐ…ώ1Ϋιύ‹D$<θό‹D$@θό‹C‹‰B‰‰ΨΗ   ΗC"  θόιαύΎώιΧύ‹D$<Ύτθό‹D$@θόι»ύΎωι±ύθό‰ήι¥ύ΄&    θόS‰Γφ@,tƒT  1[ιόt& θό‹C¨ud θόƒT  1[ιό¶    ‹Cπƒ λή΄&    ΄&    θόUΉ   ΊΠ  WV‰ΖSƒμdd΅    ‰D$`1ΐl$‰οσ«†T  ‰$hΐ  θόZ‰Η…ΐ…¶   ‹^h…Ϋt"θό‹ƒT  ¨…μ   d θό‹[h…Ϋuή†4  μ  ‰ ‰@ƒΐ9Αuτ†H  ‰†H  ‰†L  λƒΗƒtxL½ ‰ϊ‰π‰λθΙρ…ΐtεl$`‹ƒΓθό9λuς‹^h…Ϋtθό‹ƒT  ¨u{dθό‹[h…Ϋuβ‹$Ώτθό‹D$`d+    u{ƒΔd‰ψ[^_]Γ΄&    f1Ϋ¶    ‹L ‹„Ψ  “τ   ƒΓ‰L–θόƒϋuή1λ²f‹ƒX  πƒ ι‹ƒX  πƒ(…x‹“X  ƒT  ‹Rθόι_θόv θόU‰ΥW‰ΟVS‰Γƒμ‹ θό‰Ζ= π‡Κ   ‹S‰ΠƒΰƒψtEΈ    ‹[‰$θό‹$1Ι‰πR‰ϊSj θ›ψ‰ΓΈ    θόƒΔφF,thƒΔ‰Ψ[^_]Γt& ‹C‰κ1Ιθό‰Ε= πws‹SΈ    ‹[‰$θό‹$‰ι‰πR‰ϊSj θ>ψ‰ΓΈ    θόƒΔ…νt‰θθόφF,uθό‹F¨uRdθό‰ΨƒΔ[^_]ΓƒΔ‰Γ‰Ψ[^_]Γt& φF,t
‰λι]v θό‹F¨u-dθό‰λι?t& ‹Fπƒ(u¨‹VF‹Rθόλ‹Fπƒ(uΝ‹VF‹Rθόλ½΄&    ΄&    θόW‰ΧV‰ΖS‹ θό‰Γ= πwt‹F‰ϊ1Ιθό‹v‰ΗΈ     πwfθό‰ϊ1Ι‰ΨVθ…ρ‰ΖΈ    θόZ…t‰ψθόφC,t‰π[^_Γθό‹C¨uDdθό‰π[^_Γ¶    ‰Ζ[‰π^_Γ΄&    θό1Ι1‰ΨVθρ‰ΖΈ    θόXλ£‹Cπƒ(u¶‹SC‹Rθόλ¦΄&    θόUWV‰ΖSƒμ‹Nd΅    ‰D$1ΐ…Ι…σ   ‹F‰Υθό‰Η= π‡Τ   ΅   Ή0   Ίΐ θό‰Γ…ΐ„ί   UΉ\  Ί   θό‹F‰{(T$‰C,‰Ψθό‰ΖX…φuS‹s,Έ    θό1Ι1‰ψjVSθυ‰ΖΈ    θόƒΔ‰ΰ…φuJθό‰Ζ‹D$d+    uvƒΔ‰π[^_]Γt& ‰ΨθόφG,uΨθό‹G¨u/dθόλΒt& θόλΨ΄&    f‰Ζλ©t& Ύκλ‹Gπƒ(uΛ‹WG‹Rθόλ»Ύτλθό΄&    t& θόUWV‰ΦS‰Γƒμ d΅    ‰D$‹θό‰Η= π‡ς  Έ    θό‹CΗ$κƒψ"‡<  Ύ€    …ΐ-  „   ‹”‡μ  ‹k‰L$Η4  ‰L$‹‡Ψ  ‹C‰T$‰L$ƒΰ„D  ‰Θθό‰D$Ή   FT$θό…ΐ…¬  FΉ   T$θό…ΐ…“  ‹C‰ξ…ΐ„Ά   …ν„   ‹L$‰$…Ι„’   9ΘƒC  ‰D$Η$δφC…~  ‹D$1ν‹\Η‹D$9Ψtc‰|$‰Ηλ@t& ‹@(Ή   T$‹@ ‰D$‰πθό…ΐ…  ƒΕ;l$„Ρ   ‹ƒΖ9ί„Δ   ‹C…ΐu½‹C…ΐt¶‹@λ±Η$    Έ    θόφG,t!‹D$d+    …   ‹$ƒΔ [^_]Γt& θό‹G¨…¨   dθόλΕ¶    ‹L$‹TΟ‹L$9Ρth‰$‰Λλ
ƒΐ‹9Σt‹J…Ιuπ‹J…Ιtμ‹I…Ιuβλγ‹$ιƒώ΄&    ‰$ιo΄&    ‹|$ιN΄&    Η$    ιΌώt& 1ΐιDώ΄&    f‹|$Η$ςι‹Gπƒ(…N‹WG‹Rθόι;‹L$‹D$‰κθό‰$ιΰώθόt& θόUWVS‰ΓΏΫƒμ d΅    ‰D$1ΐΏD$4‰L$‰T$Αΰ	Ψ‰D$d‹    θό‹ƒΘ  ‹T$8ΗD$    ‹@8‹΄Ψ  θόθό‹ƒp  ‰D$D$‰ƒp  ‹^…ΫtB~t& ‰|$>t& ‹K$S0D$θό‰Ζ…φu|$ πwΗD$‹_ƒΗ…ΫuΖ‹L$d΅    ‰p  θόθό‹\$θό‹D$d+    ukƒΔ ‰Ψ[^_]Γt& θόS0‹s$‰ΕD$θό‹[‰Ζθό…    $ϊƒCƒƒS θό1)θCSƒCχ$   „KϋιEθό΄&    ΄&    θόU‰ΕWV‰ΞΉ	   S‰ΣƒμP‹D$d|$(‰D$‹D$h‰D$d΅    ‰D$L1ΐ‰T$$Ίΐ  ‰l$ ΗD$    ΗD$    σ«‹D$lΗD$,   ‰t$<‹L$`‰D$@Έ   θό‰D$(…ΐ„4  ‰ΑD$1PD$0P‰Ψ‹{θό[_…ΐ…  …φt‹D$‹…Ιt‹D$‹……  θό‹T$pd‹    ‹ƒΘ  ΗD$    ‹@8‹΄Ψ  θόθό‹ƒp  ~‰D$D$‰ƒp  ‹^…Ϋt@¶    ‰|$>t& ‹K$S0D$ θό‰Ζ…φu|$ πwΗD$‹_ƒΗ…ΫuΖ‹L$d΅    ‰p  θόθό‹\$θό‹D$(θόƒϋu‹D$8…ΐ…™   ‹D$0θό‹D$Ld+    …7  ƒΔP‰Ψ[^_]Γt& ΗD$,    ELF                            4     (               θόΗ€ΐ      1ΐΓ΄&    ΄&    θόΗ€ΐ       1ΐΓ΄&    ΄&    θό‹ΐ   …Ιu‹€Δ   ΗB(p   ΗB4   ‰B81ΐΓ΄&    θό‹@\θό1ΐΓθόV1Ι‰ΖS‰Σƒμd΅    ‰D$‹†”   f‰L$ΖD$ƒϊtAƒϊtLƒϊtGj Ή   T$θόYƒψ…-   ‰Δ   ‹D$d+    u!ƒΔ[^Γt& ΖD$λΒ΄&    fΖD$λ²θόt& θό‹ΐ   …Ιt	1ΐΓ¶    ‹R8θP1ΐΓ΄&    ¶    θόVS‰Γ‹@‹P‹Rθό%   =   „B   Έϋ[^Γ                     @  p                   "                                                                                                           @   p       €     @       (Radio)  6%s: Audio Mode: %u%s
 vp27smpx θόƒΈΐ    Ή	   Ί    DΡƒΐpRpTPh
   θό1ΐƒΔΓƒΖpVh    θόXZιΥ   ‹S·C  Q QP‹CT²   0h$   θόCΉΐ  ΊΘ   θό‰ΖƒΔ…ΐu
Έτιh  Ή@   ‰Ϊθό‰πΊ   Η†Δ      θ|   1ΐιh   3%s: I/O error setting audmode
    6%s %d-%04x: chip found @ 0x%x (%s)
 θόΊ    Έ    ιόΈ    ιό            vp27smpx                                                           ΐ       `                                                                                                                                       @                                                                                         license=GPL author=Hans Verkuil description=vp27smpx driver  GCC: (GNU) 11.2.0           GNU  ΐ       ΐ                                  ρ                                                    ,   @   )     =   p                                   	 M       1    	               a   €        v   1       	      #     ΅   @  /     °   F   v    	 Δ   @                       Ρ            ζ       €     φ       
           0                        0     )  ΐ   ,     <  `   P     O           f          |           —             Ά             ΐ             Θ             Ϊ             τ                                       +             @             N             b           n             }      
           0      vp27smpx.c vp27smpx_s_radio vp27smpx_s_std vp27smpx_g_tuner vp27smpx_remove vp27smpx_log_status vp27smpx_set_audmode vp27smpx_set_audmode.cold vp27smpx_s_tuner vp27smpx_probe vp27smpx_probe.cold vp27smpx_ops vp27smpx_driver_init vp27smpx_driver vp27smpx_driver_exit vp27smpx_id vp27smpx_core_ops vp27smpx_tuner_ops vp27smpx_video_ops __UNIQUE_ID_license268 __UNIQUE_ID_author267 __UNIQUE_ID_description266 __fentry__ v4l2_device_unregister_subdev _printk __stack_chk_guard i2c_transfer_buffer_flags __stack_chk_fail __x86_indirect_thunk_edx devm_kmalloc v4l2_i2c_subdev_init __this_module i2c_register_driver init_module i2c_del_driver cleanup_module __mod_i2c__vp27smpx_id_device_table      !     A     q     y          ’   !  Ε   "  ΰ   !    #      A    S  $  Ο   	  c  	                 h                             	                                      "     '      6     ;      e     j      |   %  ”     ›   &  ±     B          Έ                  '     (          *  @     D     L     l     Δ     Τ     Ψ        	   .symtab .strtab .shstrtab .rel.text .rel.data .bss .rel__mcount_loc .rodata.str1.1 .rel.text.unlikely .rodata.str1.4 .rel.init.text .rel.exit.text .rel.rodata .modinfo .comment .note.GNU-stack .note.gnu.property                                                         @   o                    	   @       θ
  x               )             ΐ  €                   %   	   @       `                  /             @                     8             @  $                  4   	   @       €  H               E      2       d  +                 X               Ό                  T   	   @       Θ  €      	         g      2       L  J                 z             –                    v   	   @       H                  ‰               
                  …   	   @       h                              ΐ  0                  ”   	   @       x  @                             π  <                  ©      0       ,                   ²              ?                     Β             @  (                                h  Π              	              8  °                               Έ  Υ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ιαώv θόS0‹s$‰ΕD$ θό‹[‰Ζθό…    $ϊƒCƒƒS θό1)θCSƒCχ$   „ϋιv ‹|$‹θό‹D$0‹L$‰‹D$4‰ιP΄&    ‹L$`Ίΐ  Έ   θόΉ   ‰D$0‰Β‹D$‹ 9ΘGΑ‰D$4…tR‹L$‹1ƒψs$…ΐ„.ώ¶
¨„!ώ·Lώf‰Lώιώ‹zƒηό‰
‹Lό‰Lό)ϊ)ΦΑισ¥ιούΗD$4    ιβύθό΄&    t& θόUWV‰ΖSƒμp‹¶δ  ‰D$‹„$   ‰T$‹$„   1‰D$‹„$   ‰L$‰D$d΅    ‰D$l1ΐ‰TLƒΐƒψ rτ11ΐ‰T,ƒΐƒψ rτ‹D$‹|$L$L‰D$(‹D$‹‹ ‰D$4‹D$‹ ‰D$8Έ   9ΒLΠD$(θή‰D$…ΐxN‹?‹l$,9Η‰|$<Oψ…ρ  ‰ϊ1Ι‰θθό‰ω‰Ϊ‰θθό‰Η…t=‹l$,ΗD$ςD$L9Εt‰θθό‹D$ld+    …ν  ‹D$ƒΔp[^_]Γt& ‹D$1θό‹  ΗD$$    θό{θόd΅    ‹p  ‰L$L$ ‰p  ‹[…Ϋt;‰|$ >t& ‹K$S0D$(θό‰Ζ…φu|$$ πwΗD$$‹_ƒΗ…ΫuΖ‹L$d΅    ‰p  θόθό‹\$$‹D$θό…Ϋ…Η   ‹D$<‹l$,ƒψ„Ζ   ώ;D$υώ‹T$4‹L$‰‹T$8‹L$‰…ΐ„±   ‹L$‰L$L9Ν„¬   ‹D$ΗD$    ‰(ιΛώt& θόS0‹s$‰ΕD$(θό‹[‰Ζθό…    $ϊƒCƒƒS θό1)θCSƒCχ$   „σώϋινώv ‰\$‹l$,ιJώv ΗD$   ι:ώv ι ώΗD$    ι#ώΊΐ θό‰Γ…ΐt%‹L$<‹T$,θό‹D$ΗD$    ‰ιώθόΗD$τ‹l$,ιέύ¶    θόUWV‰ΖSƒμh‹δ  1φ‰D$‹D$|‹Ό$   ‰D$‹„$€   ‰D$d΅    ‰D$d1ΐ‰tDƒΐƒψ rτ1φ1ΐ‰t$ƒΐƒψ rτ‹D$‰T$,‰L$0L$D‰D$ d΅    ‰D$8‹„$„   ‰D$4‰ΒD$ θΫ‰D$…ΐX  …uL‹D$θό‰T$4…c  …ΐ…[  ‹D$‰Φ‹l$$9ΒOπ1Ι‰θ‰ςθό‹T$‰ρ‰θθό…ΐ…,  ‹D$1θό‹›  ‰|$θό{θόd΅    ‹p  ‰L$L$‰p  ‹[…Ϋt;‰|$>t& ‹K$S0D$ θό‰Ζ…φu|$ πwΗD$‹_ƒΗ…ΫuΖ‹L$d΅    ‰p  θόθό‹t$‹D$θό…φχ   ‹\$4‹D$$;\$u…Ϋxq‰t$t6Ή   ‰Ϊ‰$θό‹$‹D$‰Ωθό…ΐuF‹D$4‹L$θό…Ιu5‹D$$L$D9Θtθό‹D$dd+    …”   ‹D$ƒΔh[^_]Γ΄&    ‹D$$ΗD$ςλΑ΄&    v θόS0‹s$‰ΕD$ θό‹[‰Ζθό…    $ϊƒCƒƒS θό1)θCSƒCχ$   „Γώϋι½ώv ‰t$ιJθόfθόUWV‰ΦS‰Γƒμ<‹|$T‹D$P‰|$d‹    ‰T$8‹“δ  ‰\$‹‰D$Ψ‰t$ ‰D$‹D$X‰L$$‰D$‹²  ‰\$(ΗD$0    d‹    ΗD$4    ‰\$,θόθό‹ƒp  ‰D$D$‰ƒp  ‹^…ΫtC~¶    ‰|$>t& ‹K$S0D$θό‰Ζ…φu|$ πwΗD$‹_ƒΗ…ΫuΖ‹L$d΅    ‰p  θόθό‹D$…ΐx‹L$‹T$(;€   …ux‹T$8d+    uyƒΔ<[^_]Γv θόS0‹s$‰ΕD$θό‹[‰Ζθό…    $ϊƒCƒƒS θό1)θCSƒCχ$   „;ϋι5v ‰λ„Έςιzθό     cgroup_bpf_enabled_key  __cgroup_bpf_run_filter_skb  __cgroup_bpf_run_filter_sk  __cgroup_bpf_run_filter_sock_addr  __cgroup_bpf_run_filter_sock_ops                                                                        @   π  0  P  `  p  Π     °  @  ΐ  π  `	  ΐ  €                   p  °  π  °  0  p  €    ΐ  ΰ       0  P$  °$  @&  °'  (  ΰ)  ,   .  π0   4   6  cgroup_id:	%llu
attach_type:	%d
      ΐ      Τ  @        €      ¤         -  -      /  Θ/      T2   3      45  06      D7  Θ7      include/linux/skbuff.h / kernel/bpf/cgroup.c include/linux/thread_info.h °      φ	  ­     @       ƒ	 #     Υ 	 3  -   ι 	Έ$   θό ›  “  ή    ›$  &  &  s'  '  s(  ³)  S,   	
 strnlen           P      0                                          	                                                               @                           	                                                            	                                                             	                                                             	         
                                   °                                             
                                                                                                               ΐ  `  ΰ        p                       GCC: (GNU) 11.2.0           GNU  ΐ       ΐ                                  ρ              
              +             N              o             •   4          ½              γ   5            P          /            
 T  Q          €  s          ®             Ϊ  t            •          2             ]  @       w  0      •  P       ­  `  
     Ε  p  V     δ  Π  /     ϊ                           V     )  `  E    @  @  y                                 R  ΐ  Ό     a      
     u  $        €     i     ›         ²     ό     Ν     ϊ     ί     <     ώ  ΰ  <       €  <     -  @  <     P  ΐ   <     o     <     „     r     –     Ν    ©      #     ΄  °  w     Κ  0  7    β  p      ω  €  …        ΅     ,  ΐ       D  ΰ       [     
    q  `   <     ”  0      ¨  \                     ½           ϋ          :          r          «          X       Έ     Η   `	  W    9  °  6    Έ  π  ³    <  p  6    ί           ξ             ω                          π  3     2             ;             A             N             Y             f             p             ~             ‰             ›             ±             Κ             Φ             ο                                       (  °       A             H             O  ΐ  (     l  π  n     …             •             ¥             ·             Ζ             Ξ             Φ             δ  €  ™     ψ             	             '	             G	             e	             y	             ‹	             §	             Γ	             Ν	             ε	             ψ	             
             
             3
             G
             [
             t
             ‡
             
             »
             Σ
             μ
                                       .             D             \             k             ‚             –             ―  P$  Q     Β             ή  °$      ρ               @&  b                 +             A  °'  Ω     X  (  E    o             }                                       ­  ΰ)  ¬    Γ             η             Ω             υ  ,  b       .  ε    6             M             f  π0  
    ‰                          ­             Ύ             Λ   4      ξ             ϋ                6  ›    0  ,        D  0        \          o           †  Ό         Τ        cgroup.c __kstrtab_cgroup_bpf_enabled_key __kstrtabns_cgroup_bpf_enabled_key __ksymtab_cgroup_bpf_enabled_key __kstrtab___cgroup_bpf_run_filter_skb __kstrtabns___cgroup_bpf_run_filter_skb __ksymtab___cgroup_bpf_run_filter_skb __kstrtab___cgroup_bpf_run_filter_sk __kstrtabns___cgroup_bpf_run_filter_sk __ksymtab___cgroup_bpf_run_filter_sk __kstrtab___cgroup_bpf_run_filter_sock_addr __kstrtabns___cgroup_bpf_run_filter_sock_addr __ksymtab___cgroup_bpf_run_filter_sock_addr __kstrtab___cgroup_bpf_run_filter_sock_ops __kstrtabns___cgroup_bpf_run_filter_sock_ops __ksymtab___cgroup_bpf_run_filter_sock_ops sysctl_convert_ctx_access cg_sockopt_convert_ctx_access cg_sockopt_get_prologue bpf_cgroup_link_dealloc bpf_cgroup_link_fill_link_info cgroup_bpf_release_fn cgroup_bpf_release bpf_cgroup_link_show_fdinfo __bpf_prog_run_save_cb copy_sysctl_value sysctl_cpy_dir sysctl_cpy_dir.cold __func__.0 cgroup_dev_is_valid_access sysctl_is_valid_access cg_sockopt_is_valid_access sysctl_func_proto bpf_sysctl_get_new_value_proto bpf_set_retval_proto bpf_sysctl_get_name_proto bpf_sysctl_get_current_value_proto bpf_sysctl_set_new_value_proto bpf_get_retval_proto sockopt_alloc_buf cgroup_bpf_replace CSWTCH.197 cgroup_dev_func_proto compute_effective_progs update_effective_progs __cgroup_bpf_detach bpf_cgroup_link_release.part.0 bpf_cgroup_link_release bpf_cgroup_link_detach cg_sockopt_func_proto bpf_get_netns_cookie_sockopt_proto __cgroup_bpf_attach bpf_cgroup_link_lops __UNIQUE_ID___addressable___cgroup_bpf_run_filter_sock_ops491 __UNIQUE_ID___addressable___cgroup_bpf_run_filter_sock_addr490 __UNIQUE_ID___addressable___cgroup_bpf_run_filter_sk489 __UNIQUE_ID___addressable___cgroup_bpf_run_filter_skb488 __UNIQUE_ID___addressable_cgroup_bpf_enabled_key483 bpf_get_retval __fentry__ current_task bpf_set_retval bpf_get_netns_cookie_sockopt init_net kcmd_drivers/media/i2c/vp27smpx.o := gcc -Wp,-MMD,drivers/media/i2c/.vp27smpx.o.d -nostdinc -I./arch/x86/include -I./arch/x86/include/generated  -I./include -I./arch/x86/include/uapi -I./arch/x86/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/compiler-version.h -include ./include/linux/kconfig.h -include ./include/linux/compiler_types.h -D__KERNEL__ -fmacro-prefix-map=./= -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=implicit-function-declaration -Werror=implicit-int -Werror=return-type -Wno-format-security -std=gnu11 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -fcf-protection=n