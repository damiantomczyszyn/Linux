inline bool usage_accumulate(struct lock_list *entry, void *mask)
{
	if (!entry->only_xr)
		*(unsigned long *)mask |= entry->class->usage_mask;
	else /* Mask out _READ usage bits */
		*(unsigned long *)mask |= (entry->class->usage_mask & LOCKF_IRQ);

	return false;
}

/*
 * There is a strong dependency path in the dependency graph: A -> B, and now
 * we need to decide which usage bit of B conflicts with the usage bits of A,
 * i.e. which usage bit of B may introduce safe->unsafe deadlocks.
 *
 * As above, if only_xr is false, which means A -> B has -(*N)-> dependency
 * path, any usage of B should be considered. Otherwise, we should only
 * consider _READ usage.
 */
static inline bool usage_match(struct lock_list *entry, void *mask)
{
	if (!entry->only_xr)
		return !!(entry->class->usage_mask & *(unsigned long *)mask);
	else /* Mask out _READ usage bits */
		return !!((entry->class->usage_mask & LOCKF_IRQ) & *(unsigned long *)mask);
}

static inline bool usage_skip(struct lock_list *entry, void *mask)
{
	/*
	 * Skip local_lock() for irq inversion detection.
	 *
	 * For !RT, local_lock() is not a real lock, so it won't carry any
	 * dependency.
	 *
	 * For RT, an irq inversion happens when we have lock A and B, and on
	 * some CPU we can have:
	 *
	 *	lock(A);
	 *	<interrupted>
	 *	  lock(B);
	 *
	 * where lock(B) cannot sleep, and we have a dependency B -> ... -> A.
	 *
	 * Now we prove local_lock() cannot exist in that dependency. First we
	 * have the observation for any lock chain L1 -> ... -> Ln, for any
	 * 1 <= i <= n, Li.inner_wait_type <= L1.inner_wait_type, otherwise
	 * wait context check will complain. And since B is not a sleep lock,
	 * therefore B.inner_wait_type >= 2, and since the inner_wait_type of
	 * local_lock() is 3, which is greater than 2, therefore there is no
	 * way the local_lock() exists in the dependency B -> ... -> A.
	 *
	 * As a result, we will skip local_lock(), when we search for irq
	 * inversion bugs.
	 */
	if (entry->class->lock_type == LD_LOCK_PERCPU) {
		if (DEBUG_LOCKS_WARN_ON(entry->class->wait_type_inner < LD_WAIT_CONFIG))
			return false;

		return true;
	}

	return false;
}

/*
 * Find a node in the forwards-direction dependency sub-graph starting
 * at @root->class that matches @bit.
 *
 * Return BFS_MATCH if such a node exists in the subgraph, and put that node
 * into *@target_entry.
 */
static enum bfs_result
find_usage_forwards(struct lock_list *root, unsigned long usage_mask,
			struct lock_list **target_entry)
{
	enum bfs_result result;

	debug_atomic_inc(nr_find_usage_forwards_checks);

	result = __bfs_forwards(root, &usage_mask, usage_match, usage_skip, target_entry);

	return result;
}

/*
 * Find a node in the backwards-direction dependency sub-graph starting
 * at @root->class that matches @bit.
 */
static enum bfs_result
find_usage_backwards(struct lock_list *root, unsigned long usage_mask,
			struct lock_list **target_entry)
{
	enum bfs_result result;

	debug_atomic_inc(nr_find_usage_backwards_checks);

	result = __bfs_backwards(root, &usage_mask, usage_match, usage_skip, target_entry);

	return result;
}

static void print_lock_class_header(struct lock_class *class, int depth)
{
	int bit;

	printk("%*s->", depth, "");
	print_lock_name(class);
#ifdef CONFIG_DEBUG_LOCKDEP
	printk(KERN_CONT " ops: %lu", debug_class_ops_read(class));
#endif
	printk(KERN_CONT " {\n");

	for (bit = 0; bit < LOCK_TRACE_STATES; bit++) {
		if (class->usage_mask & (1 << bit)) {
			int len = depth;

			len += printk("%*s   %s", depth, "", usage_str[bit]);
			len += printk(KERN_CONT " at:\n");
			print_lock_trace(class->usage_traces[bit], len);
		}
	}
	printk("%*s }\n", depth, "");

	printk("%*s ... key      at: [<%px>] %pS\n",
		depth, "", class->key, class->key);
}

/*
 * Dependency path printing:
 *
 * After BFS we get a lock dependency path (linked via ->parent of lock_list),
 * printing out each lock in the dependency path will help on understanding how
 * the deadlock could happen. Here are some details about dependency path
 * printing:
 *
 * 1)	A lock_list can be either forwards or backwards for a lock dependency,
 * 	for a lock dependency A -> B, there are two lock_lists:
 *
 * 	a)	lock_list in the ->locks_after list of A, whose ->class is B and
 * 		->links_to is A. In this case, we can say the lock_list is
 * 		"A -> B" (forwards case).
 *
 * 	b)	lock_list in the ->locks_before list of B, whose ->class is A
 * 		and ->links_to is B. In this case, we can say the lock_list is
 * 		"B <- A" (bacwards case).
 *
 * 	The ->trace of both a) and b) point to the call trace where B was
 * 	acquired with A held.
 *
 * 2)	A "helper" lock_list is introduced during BFS, this lock_list doesn't
 * 	represent a certain lock dependency, it only provides an initial entry
 * 	for BFS. For example, BFS may introduce a "helper" lock_list whose
 * 	->class is A, as a result BFS will search all dependencies starting with
 * 	A, e.g. A -> B or A -> C.
 *
 * 	The notation of a forwards helper lock_list is like "-> A", which means
 * 	we should search the forwards dependencies starting with "A", e.g A -> B
 * 	or A -> C.
 *
 * 	The notation of a bacwards helper lock_list is like "<- B", which means
 * 	we should search the backwards dependencies ending with "B", e.g.
 * 	B <- A or B <- C.
 */

/*
 * printk the shortest lock dependencies from @root to @leaf in reverse order.
 *
 * We have a lock dependency path as follow:
 *
 *    @root                                                                 @leaf
 *      |                                                                     |
 *      V                                                                     V
 *	          ->parent                                   ->parent
 * | lock_list | <--------- | lock_list | ... | lock_list  | <--------- | lock_list |
 * |    -> L1  |            | L1 -> L2  | ... |Ln-2 -> Ln-1|            | Ln-1 -> Ln|
 *
 * , so it's natural that we start from @leaf and print every ->class and
 * ->trace until we reach the @root.
 */
static void __used
print_shortest_lock_dependencies(struct lock_list *leaf,
				 struct lock_list *root)
{
	struct lock_list *entry = leaf;
	int depth;

	/*compute depth from generated tree by BFS*/
	depth = get_lock_depth(leaf);

	do {
		print_lock_class_header(entry->class, depth);
		printk("%*s ... acquired at:\n", depth, "");
		print_lock_trace(entry->trace, 2);
		printk("\n");

		if (depth == 0 && (entry != root)) {
			printk("lockdep:%s bad path found in chain graph\n", __func__);
			break;
		}

		entry = get_lock_parent(entry);
		depth--;
	} while (entry && (depth >= 0));
}

/*
 * printk the shortest lock dependencies from @leaf to @root.
 *
 * We have a lock dependency path (from a backwards search) as follow:
 *
 *    @leaf                                                                 @root
 *      |                                                                     |
 *      V                                                                     V
 *	          ->parent                                   ->parent
 * | lock_list | ---------> | lock_list | ... | lock_list  | ---------> | lock_list |
 * | L2 <- L1  |            | L3 <- L2  | ... | Ln <- Ln-1 |            |    <- Ln  |
 *
 * , so when we iterate from @leaf to @root, we actually print the lock
 * dependency path L1 -> L2 -> .. -> Ln in the non-reverse order.
 *
 * Another thing to notice here is that ->class of L2 <- L1 is L1, while the
 * ->trace of L2 <- L1 is the call trace of L2, in fact we don't have the call
 * trace of L1 in the dependency path, which is alright, because most of the
 * time we can figure out where L1 is held from the call trace of L2.
 */
static void __used
print_shortest_lock_dependencies_backwards(struct lock_list *leaf,
					   struct lock_list *root)
{
	struct lock_list *entry = leaf;
	const struct lock_trace *trace = NULL;
	int depth;

	/*compute depth from generated tree by BFS*/
	depth = get_lock_depth(leaf);

	do {
		print_lock_class_header(entry->class, depth);
		if (trace) {
			printk("%*s ... acquired at:\n", depth, "");
			print_lock_trace(trace, 2);
			printk("\n");
		}

		/*
		 * Record the pointer to the trace for the next lock_list
		 * entry, see the comments for the function.
		 */
		trace = entry->trace;

		if (depth == 0 && (entry != root)) {
			printk("lockdep:%s bad path found in chain graph\n", __func__);
			break;
		}

		entry = get_lock_parent(entry);
		depth--;
	} while (entry && (depth >= 0));
}

static void
print_irq_lock_scenario(struct lock_list *safe_entry,
			struct lock_list *unsafe_entry,
			struct lock_class *prev_class,
			struct lock_class *next_class)
{
	struct lock_class *safe_class = safe_entry->class;
	struct lock_class *unsafe_class = unsafe_entry->class;
	struct lock_class *middle_class = prev_class;

	if (middle_class == safe_class)
		middle_class = next_class;

	/*
	 * A direct locking problem where unsafe_class lock is taken
	 * directly by safe_class lock, then all we need to show
	 * is the deadlock scenario, as it is obvious that the
	 * unsafe lock is taken under the safe lock.
	 *
	 * But if there is a chain instead, where the safe lock takes
	 * an intermediate lock (middle_class) where this lock is
	 * not the same as the safe lock, then the lock chain is
	 * used to describe the problem. Otherwise we would need
	 * to show a different CPU case for each link in the chain
	 * from the safe_class lock to the unsafe_class lock.
	 */
	if (middle_class != unsafe_class) {
		printk("Chain exists of:\n  ");
		__print_lock_name(safe_class);
		printk(KERN_CONT " --> ");
		__print_lock_name(middle_class);
		printk(KERN_CONT " --> ");
		__print_lock_name(unsafe_class);
		printk(KERN_CONT "\n\n");
	}

	printk(" Possible interrupt unsafe locking scenario:\n\n");
	printk("       CPU0                    CPU1\n");
	printk("       ----                    ----\n");
	printk("  lock(");
	__print_lock_name(unsafe_class);
	printk(KERN_CONT ");\n");
	printk("                               local_irq_disable();\n");
	printk("                               lock(");
	__print_lock_name(safe_class);
	printk(KERN_CONT ");\n");
	printk("                               lock(");
	__print_lock_name(middle_class);
	printk(KERN_CONT ");\n");
	printk("  <Interrupt>\n");
	printk("    lock(");
	__print_lock_name(safe_class);
	printk(KERN_CONT ");\n");
	printk("\n *** DEADLOCK ***\n\n");
}

static void
print_bad_irq_dependency(struct task_struct *curr,
			 struct lock_list *prev_root,
			 struct lock_list *next_root,
			 struct lock_list *backwards_entry,
			 struct lock_list *forwards_entry,
			 struct held_lock *prev,
			 struct held_lock *next,
			 enum lock_usage_bit bit1,
			 enum lock_usage_bit bit2,
			 const char *irqclass)
{
	if (!debug_locks_off_graph_unlock() || debug_locks_silent)
		return;

	pr_warn("\n");
	pr_warn("=====================================================\n");
	pr_warn("WARNING: %s-safe -> %s-unsafe lock order detected\n",
		irqclass, irqclass);
	print_kernel_ident();
	pr_warn("-----------------------------------------------------\n");
	pr_warn("%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] is trying to acquire:\n",
		curr->comm, task_pid_nr(curr),
		lockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,
		curr->softirq_context, softirq_count() >> SOFTIRQ_SHIFT,
		lockdep_hardirqs_enabled(),
		curr->softirqs_enabled);
	print_lock(next);

	pr_warn("\nand this task is already holding:\n");
	print_lock(prev);
	pr_warn("which would create a new lock dependency:\n");
	print_lock_name(hlock_class(prev));
	pr_cont(" ->");
	print_lock_name(hlock_class(next));
	pr_cont("\n");

	pr_warn("\nbut this new dependency connects a %s-irq-safe lock:\n",
		irqclass);
	print_lock_name(backwards_entry->class);
	pr_warn("\n... which became %s-irq-safe at:\n", irqclass);

	print_lock_trace(backwards_entry->class->usage_traces[bit1], 1);

	pr_warn("\nto a %s-irq-unsafe lock:\n", irqclass);
	print_lock_name(forwards_entry->class);
	pr_warn("\n... which became %s-irq-unsafe at:\n", irqclass);
	pr_warn("...");

	print_lock_trace(forwards_entry->class->usage_traces[bit2], 1);

	pr_warn("\nother info that might help us debug this:\n\n");
	print_irq_lock_scenario(backwards_entry, forwards_entry,
				hlock_class(prev), hlock_class(next));

	lockdep_print_held_locks(curr);

	pr_warn("\nthe dependencies between %s-irq-safe lock and the holding lock:\n", irqclass);
	print_shortest_lock_dependencies_backwards(backwards_entry, prev_root);

	pr_warn("\nthe dependencies between the lock to be acquired");
	pr_warn(" and %s-irq-unsafe lock:\n", irqclass);
	next_root->trace = save_trace();
	if (!next_root->trace)
		return;
	print_shortest_lock_dependencies(forwards_entry, next_root);

	pr_warn("\nstack backtrace:\n");
	dump_stack();
}

static const char *state_names[] = {
#define LOCKDEP_STATE(__STATE) \
	__stringify(__STATE),
#include "lockdep_states.h"
#undef LOCKDEP_STATE
};

static const char *state_rnames[] = {
#define LOCKDEP_STATE(__STATE) \
	__stringify(__STATE)"-READ",
#include "lockdep_states.h"
#undef LOCKDEP_STATE
};

static inline const char *state_name(enum lock_usage_bit bit)
{
	if (bit & LOCK_USAGE_READ_MASK)
		return state_rnames[bit >> LOCK_USAGE_DIR_MASK];
	else
		return state_names[bit >> LOCK_USAGE_DIR_MASK];
}

/*
 * The bit number is encoded like:
 *
 *  bit0: 0 exclusive, 1 read lock
 *  bit1: 0 used in irq, 1 irq enabled
 *  bit2-n: state
 */
static int exclusive_bit(int new_bit)
{
	int state = new_bit & LOCK_USAGE_STATE_MASK;
	int dir = new_bit & LOCK_USAGE_DIR_MASK;

	/*
	 * keep state, bit flip the direction and strip read.
	 */
	return state | (dir ^ LOCK_USAGE_DIR_MASK);
}

/*
 * Observe that when given a bitmask where each bitnr is encoded as above, a
 * right shift of the mask transforms the individual bitnrs as -1 and
 * conversely, a left shift transforms into +1 for the individual bitnrs.
 *
 * So for all bits whose number have LOCK_ENABLED_* set (bitnr1 == 1), we can
 * create the mask with those bit numbers using LOCK_USED_IN_* (bitnr1 == 0)
 * instead by subtracting the bit number by 2, or shifting the mask right by 2.
 *
 * Similarly, bitnr1 == 0 becomes bitnr1 == 1 by adding 2, or shifting left 2.
 *
 * So split the mask (note that LOCKF_ENABLED_IRQ_ALL|LOCKF_USED_IN_IRQ_ALL is
 * all bits set) and recompose with bitnr1 flipped.
 */
static unsigned long invert_dir_mask(unsigned long mask)
{
	unsigned long excl = 0;

	/* Invert dir */
	excl |= (mask & LOCKF_ENABLED_IRQ_ALL) >> LOCK_USAGE_DIR_MASK;
	excl |= (mask & LOCKF_USED_IN_IRQ_ALL) << LOCK_USAGE_DIR_MASK;

	return excl;
}

/*
 * Note that a LOCK_ENABLED_IRQ_*_READ usage and a LOCK_USED_IN_IRQ_*_READ
 * usage may cause deadlock too, for example:
 *
 * P1				P2
 * <irq disabled>
 * write_lock(l1);		<irq enabled>
 *				read_lock(l2);
 * write_lock(l2);
 * 				<in irq>
 * 				read_lock(l1);
 *
 * , in above case, l1 will be marked as LOCK_USED_IN_IRQ_HARDIRQ_READ and l2
 * will marked as LOCK_ENABLE_IRQ_HARDIRQ_READ, and this is a possible
 * deadlock.
 *
 * In fact, all of the following cases may cause deadlocks:
 *
 * 	 LOCK_USED_IN_IRQ_* -> LOCK_ENABLED_IRQ_*
 * 	 LOCK_USED_IN_IRQ_*_READ -> LOCK_ENABLED_IRQ_*
 * 	 LOCK_USED_IN_IRQ_* -> LOCK_ENABLED_IRQ_*_READ
 * 	 LOCK_USED_IN_IRQ_*_READ -> LOCK_ENABLED_IRQ_*_READ
 *
 * As a result, to calculate the "exclusive mask", first we invert the
 * direction (USED_IN/ENABLED) of the original mask, and 1) for all bits with
 * bitnr0 set (LOCK_*_READ), add those with bitnr0 cleared (LOCK_*). 2) for all
 * bits with bitnr0 cleared (LOCK_*_READ), add those with bitnr0 set (LOCK_*).
 */
static unsigned long exclusive_mask(unsigned long mask)
{
	unsigned long excl = invert_dir_mask(mask);

	excl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;
	excl |= (excl & LOCKF_IRQ) << LOCK_USAGE_READ_MASK;

	return excl;
}

/*
 * Retrieve the _possible_ original mask to which @mask is
 * exclusive. Ie: this is the opposite of exclusive_mask().
 * Note that 2 possible original bits can match an exclusive
 * bit: one has LOCK_USAGE_READ_MASK set, the other has it
 * cleared. So both are returned for each exclusive bit.
 */
static unsigned long original_mask(unsigned long mask)
{
	unsigned long excl = invert_dir_mask(mask);

	/* Include read in existing usages */
	excl |= (excl & LOCKF_IRQ_READ) >> LOCK_USAGE_READ_MASK;
	excl |= (excl & LOCKF_  ƒ|$`"‡  ‹D$`Ύ€    ‰D$…ΐ  „   έ    ‰\$q‰L$$‰σ‰t$‹4$‰υ‹vhέ…φtz8  ‰l$ ‰D$‹D$‹l†‰κƒβuZ‹D$‹D$‹DΖ9Θuλ>΄&    ƒΒ‹ 9Αt‹X…Ϋuπ‹X…Ϋtμ‹[…Ϋuβ‹ 9Αuεt& ƒϊ‡'  „(  ‹vh…φu—‹l$ ‹4$‹\$ή‰D$‹€4  9Εt‹D$9„μ  …  ‹D$‹4  9έ„C  ‰Ψ1λt& ƒΒ‹ 9Εt‹p…φuπ‹H…Ιtμ‹I…Ιuβ‹ 9Εuεt& ƒϊ?‡1  φD$d„  ‹L$‹T$‰Ψ΄&    v …t9xu9Ο…·   …t	;P„   ‹ 9Εuά‹T$‹D$…uιΥ   v ‹9έ„  ;Cuρϋ π‡Ξ  ‰ω…„λ  ‹$‰\$‰Λ1φ‹€”   ‹P@‹@<‰D$(‹D$`‰T$,‰D$0‹C(‹„°x  …ΐt1ΙT$(θό‰D΄4…ΐ„w  ƒώtj‹C(Ύ   ‹„°x  …ΐuΡλζt& Ύκ‹D$Dd+    …>  ƒΔH‰π[^_]ΓφD$d…¬  t& ‹D$‹€4  9Ε…=1ΫιB΄&    ‹\$…Ϋtu‹D$‹k‰{‹L$‹|$‰C‹D$4‰ϊ‰C‹D$8‰C‹$‰Έμ  θόυ‰Ζ…ΐ…ϊ   …ν„   ‰θθό‹<$‹L$`1φ‹D$<‰ϊθό‹L$`‹D$@‰ϊθόι8΅   Ή   Ίΐ  θό‰Γ…ΐ„C  ‹t$‹L$‰+‹†8  ‰8  ‰C‰‹D$‰{‹|$‰C‹D$4‰ϊ‰C‹D$8‰C‹$‰Έμ  θUυ‰Ζ…ΐ…²   ‹D$$ΰϋθόιU΄&    ‰ς‰Ψθό‰D΄4= π‡Ύ   ‰D΄<ιhώ΄&    ‹D$‹Hι	ώt& …νt[‰k‹D$<ΗC    θό‹D$@θόιPώv ιΨό‰θ‹l$ ¨…ΥόΎι.ώ‹D$Ύώ…ΐ…ώ1Ϋιύ‹D$<θό‹D$@θό‹C‹‰B‰‰ΨΗ   ΗC"  θόιαύΎώιΧύ‹D$<Ύτθό‹D$@θόι»ύΎωι±ύθό‰ήι¥ύ΄&    θόS‰Γφ@,tƒT  1[ιόt& θό‹C¨ud θόƒT  1[ιό¶    ‹Cπƒ λή΄&    ΄&    θόUΉ   ΊΠ  WV‰ΖSƒμdd΅    ‰D$`1ΐl$‰οσ«†T  ‰$hΐ  θόZ‰Η…ΐ…¶   ‹^h…Ϋt"θό‹ƒT  ¨…μ   d θό‹[h…Ϋuή†4  μ  ‰ ‰@ƒΐ9Αuτ†H  ‰†H  ‰†L  λƒΗƒtxL½ ‰ϊ‰π‰λθΙρ…ΐtεl$`‹ƒΓθό9λuς‹^h…Ϋtθό‹ƒT  ¨u{dθό‹[h…Ϋuβ‹$Ώτθό‹D$`d+    u{ƒΔd‰ψ[^_]Γ΄&    f1Ϋ¶    ‹L ‹„Ψ  “τ   ƒΓ‰L–θόƒϋuή1λ²f‹ƒX  πƒ ι‹ƒX  πƒ(…x‹“X  ƒT  ‹Rθόι_θόv θόU‰ΥW‰ΟVS‰Γƒμ‹ θό‰Ζ= π‡Κ   ‹S‰ΠƒΰƒψtEΈ    ‹[‰$θό‹$1Ι‰πR‰ϊSj θ›ψ‰ΓΈ    θόƒΔφF,thƒΔ‰Ψ[^_]Γt& ‹C‰κ1Ιθό‰Ε= πws‹SΈ    ‹[‰$θό‹$‰ι‰πR‰ϊSj θ>ψ‰ΓΈ    θόƒΔ…νt‰θθόφF,uθό‹F¨uRdθό‰ΨƒΔ[^_]ΓƒΔ‰Γ‰Ψ[^_]Γt& φF,t
‰λι]v θό‹F¨u-dθό‰λι?t& ‹Fπƒ(u¨‹VF‹Rθόλ‹Fπƒ(uΝ‹VF‹Rθόλ½΄&    ΄&    θόW‰ΧV‰ΖS‹ θό‰Γ= πwt‹F‰ϊ1Ιθό‹v‰ΗΈ     πwfθό‰ϊ1Ι‰ΨVθ…ρ‰ΖΈ    θόZ…t‰ψθόφC,t‰π[^_Γθό‹C¨uDdθό‰π[^_Γ¶    ‰Ζ[‰π^_Γ΄&    θό1Ι1‰ΨVθρ‰ΖΈ    θόXλ£‹Cπƒ(u¶‹SC‹Rθόλ¦΄&    θόUWV‰ΖSƒμ‹Nd΅    ‰D$1ΐ…Ι…σ   ‹F‰Υθό‰Η= π‡Τ   ΅   Ή0   Ίΐ θό‰Γ…ΐ„ί   UΉ\  Ί   θό‹F‰{(T$‰C,‰Ψθό‰ΖX…φuS‹s,Έ    θό1Ι1‰ψjVSθυ‰ΖΈ    θόƒΔ‰ΰ…φuJθό‰Ζ‹D$d+    uvƒΔ‰π[^_]Γt& ‰ΨθόφG,uΨθό‹G¨u/dθόλΒt& θόλΨ΄&    f‰Ζλ©t& Ύκλ‹Gπƒ(uΛ‹WG‹Rθόλ»Ύτλθό΄&    t& θόUWV‰ΦS‰Γƒμ d΅    ‰D$‹θό‰Η= π‡ς  Έ    θό‹CΗ$κƒψ"‡<  Ύ€    …ΐ-  „   ‹”‡μ  ‹k‰L$Η4  ‰L$‹‡Ψ  ‹C‰T$‰L$ƒΰ„D  ‰Θθό‰D$Ή   FT$θό…ΐ…¬  FΉ   T$θό…ΐ…“  ‹C‰ξ…ΐ„Ά   …ν„   ‹L$‰$…Ι„’   9ΘƒC  ‰D$Η$δφC…~  ‹D$1ν‹\Η‹D$9Ψtc‰|$‰Ηλ@t& ‹@(Ή   T$‹@ ‰D$‰πθό…ΐ…  ƒΕ;l$„Ρ   ‹ƒΖ9ί„Δ   ‹C…ΐu½‹C…ΐt¶‹@λ±Η$    Έ    θόφG,t!‹D$d+    …   ‹$ƒΔ [^_]Γt& θό‹G¨…¨   dθόλΕ¶    ‹L$‹TΟ‹L$9Ρth‰$‰Λλ
ƒΐ‹9Σt‹J…Ιuπ‹J…Ιtμ‹I…Ιuβλγ‹$ιƒώ΄&    ‰$ιo΄&    ‹|$ιN΄&    Η$    ιΌώt& 1ΐιDώ΄&    f‹|$Η$ςι‹Gπƒ(…N‹WG‹Rθόι;‹L$‹D$‰κθό‰$ιΰώθόt& θόUWVS‰ΓΏΫƒμ d΅    ‰D$1ΐΏD$4‰L$‰T$Αΰ	Ψ‰D$d‹    θό‹ƒΘ  ‹T$8ΗD$    ‹@8‹΄Ψ  θόθό‹ƒp  ‰D$D$‰ƒp  ‹^…ΫtB~t& ‰|$>t& ‹K$S0D$θό‰Ζ…φu|$ πwΗD$‹_ƒΗ…ΫuΖ‹L$d΅    ‰p  θόθό‹\$θό‹D$d+    ukƒΔ ‰Ψ[^_]Γt& θόS0‹s$‰ΕD$θό‹[‰Ζθό…    $ϊƒCƒƒS θό1)θCSƒCχ$   „KϋιEθό΄&    ΄&    θόU‰ΕWV‰ΞΉ	   S‰ΣƒμP‹D$d|$(‰D$‹D$h‰D$d΅    ‰D$L1ΐ‰T$$Ίΐ  ‰l$ ΗD$    ΗD$    σ«‹D$lΗD$,   ‰t$<‹L$`‰D$@Έ   θό‰D$(…ΐ„4  ‰ΑD$1PD$0P‰Ψ‹{θό[_…ΐ…  …φt‹D$‹…Ιt‹D$‹……  θό‹T$pd‹    ‹ƒΘ  ΗD$    ‹@8‹΄Ψ  θόθό‹ƒp  ~‰D$D$‰ƒp  ‹^…Ϋt@¶    ‰|$>t& ‹K$S0D$ θό‰Ζ…φu|$ πwΗD$‹_ƒΗ…ΫuΖ‹L$d΅    ‰p  θόθό‹\$θό‹D$(θόƒϋu‹D$8…ΐ…™   ‹D$0θό‹D$Ld+    …7  ƒΔP‰Ψ[^_]Γt& ΗD$,    ELF                            4     (               θόΗ€ΐ      1ΐΓ΄&    ΄&    θόΗ€ΐ       1ΐΓ΄&    ΄&    θό‹ΐ   …Ιu‹€Δ   ΗB(p   ΗB4   ‰B81ΐΓ΄&    θό‹@\θό1ΐΓθόV1Ι‰ΖS‰Σƒμd΅    ‰D$‹†”   f‰L$ΖD$ƒϊtAƒϊtLƒϊtGj Ή   T$θόYƒψ…-   ‰Δ   ‹D$d+    u!ƒΔ[^Γt& ΖD$λΒ΄&    fΖD$λ²θόt& θό‹ΐ   …Ιt	1ΐΓ¶    ‹R8θP1ΐΓ΄&    ¶    θόVS‰Γ‹@‹P‹Rθό%   =   „B   Έϋ[^Γ                     @  p                   "                                                                                                           @   p       €     @       (Radio)  6%s: Audio Mode: %u%s
 vp27smpx θόƒΈΐ    Ή	   Ί    DΡƒΐpRpTPh
   θό1ΐƒΔΓƒΖpVh    θόXZιΥ   ‹S·C  Q QP‹CT²   0h$   θόCΉΐ  ΊΘ   θό‰ΖƒΔ…ΐu
Έτιh  Ή@   ‰Ϊθό‰πΊ   Η†Δ      θ|   1ΐιh   3%s: I/O error setting audmode
    6%s %d-%04x: chip found @ 0x%x (%s)
 θόΊ    Έ    ιόΈ    ιό            vp27smpx                                                           ΐ       `                                                                                                                                       @                                                                                         license=GPL author=Hans Verkuil description=vp27smpx driver  GCC: (GNU) 11.2.0           GNU  ΐ       ΐ                                  ρ                                                    ,   @   )     =   p                                   	 M       1    	               a   €        v   1       	      #     ΅   @  /     °   F   v    	 Δ   @                       Ρ            ζ       €     φ       
           0                        0     )  ΐ   ,     <  `   P     O           f          |           —             Ά             ΐ             Θ             Ϊ             τ                                       +             @             N             b           n             }      
           0      vp27smpx.c vp27smpx_s_radio vp27smpx_s_std vp27smpx_g_tuner vp27smpx_remove vp27smpx_log_status vp27smpx_set_audmode vp27smpx_set_audmode.cold vp27smpx_s_tuner vp27smpx_probe vp27smpx_probe.cold vp27smpx_ops vp27smpx_driver_init vp27smpx_driver vp27smpx_driver_exit vp27smpx_id vp27smpx_core_ops vp27smpx_tuner_ops vp27smpx_video_ops __UNIQUE_ID_license268 __UNIQUE_ID_author267 __UNIQUE_ID_description266 __fentry__ v4l2_device_unregister_subdev _printk __stack_chk_guard i2c_transfer_buffer_flags __stack_chk_fail __x86_indirect_thunk_edx devm_kmalloc v4l2_i2c_subdev_init __this_module i2c_register_driver init_module i2c_del_driver cleanup_module __mod_i2c__vp27smpx_id_device_table      !     A     q     y          ’   !  Ε   "  ΰ   !    #      A    S  $  Ο   	  c  	                 h                             	                                      "     '      6     ;      e     j      |   %  ”     ›   &  ±     B          Έ                  '     (          *  @     D     L     l     Δ     Τ     Ψ        	   .symtab .strtab .shstrtab .rel.text .rel.data .bss .rel__mcount_loc .rodata.str1.1 .rel.text.unlikely .rodata.str1.4 .rel.init.text .rel.exit.text .rel.rodata .modinfo .comment .note.GNU-stack .note.gnu.property                                                         @   o                    	   @       θ
  x               )             ΐ  €                   %   	   @       `                  /             @                     8             @  $                  4   	   @       €  H               E      2       d  +                 X               Ό                  T   	   @       Θ  €      	         g      2       L  J                 z             –                    v   	   @       H                  ‰               
                  …   	   @       h                              ΐ  0                  ”   	   @       x  @                             π  <                  ©      0       ,                   ²              ?                     Β             @  (                                h  Π              	              8  °                               Έ  Υ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ιαώv θόS0‹s$‰ΕD$ θό‹[‰Ζθό…    $ϊƒCƒƒS θό1)θCSƒCχ$   „ϋιv ‹|$‹θό‹D$0‹L$‰‹D$4‰ιP΄&    ‹L$`Ίΐ  Έ   θόΉ   ‰D$0‰Β‹D$‹ 9ΘGΑ‰D$4…tR‹L$‹1ƒψs$…ΐ„.ώ¶
¨„!ώ·Lώf‰Lώιώ‹zƒηό‰
‹Lό‰Lό)ϊ)ΦΑισ¥ιούΗD$4    ιβύθό΄&    t& θόUWV‰ΖSƒμp‹¶δ  ‰D$‹„$   ‰T$‹$„   1‰D$‹„$   ‰L$‰D$d΅    ‰D$l1ΐ‰TLƒΐƒψ rτ11ΐ‰T,ƒΐƒψ rτ‹D$‹|$L$L‰D$(‹D$‹‹ ‰D$4‹D$‹ ‰D$8Έ   9ΒLΠD$(θή‰D$…ΐxN‹?‹l$,9Η‰|$<Oψ…ρ  ‰ϊ1Ι‰θθό‰ω‰Ϊ‰θθό‰Η…t=‹l$,ΗD$ςD$L9Εt‰θθό‹D$ld+    …ν  ‹D$ƒΔp[^_]Γt& ‹D$1θό‹  ΗD$$    θό{θόd΅    ‹p  ‰L$L$ ‰p  ‹[…Ϋt;‰|$ >t& ‹K$S0D$(θό‰Ζ…φu|$$ πwΗD$$‹_ƒΗ…ΫuΖ‹L$d΅    ‰p  θόθό‹\$$‹D$θό…Ϋ…Η   ‹D$<‹l$,ƒψ„Ζ   ώ;D$υώ‹T$4‹L$‰‹T$8‹L$‰…ΐ„±   ‹L$‰L$L9Ν„¬   ‹D$ΗD$    ‰(ιΛώt& θόS0‹s$‰ΕD$(θό‹[‰Ζθό…    $ϊƒCƒƒS θό1)θCSƒCχ$   „σώϋινώv ‰\$‹l$,ιJώv ΗD$   ι:ώv ι ώΗD$    ι#ώΊΐ θό‰Γ…ΐt%‹L$<‹T$,θό‹D$ΗD$    ‰ιώθόΗD$τ‹l$,ιέύ¶    θόUWV‰ΖSƒμh‹δ  1φ‰D$‹D$|‹Ό$   ‰D$‹„$€   ‰D$d΅    ‰D$d1ΐ‰tDƒΐƒψ rτ1φ1ΐ‰t$ƒΐƒψ rτ‹D$‰T$,‰L$0L$D‰D$ d΅    ‰D$8‹„$„   ‰D$4‰ΒD$ θΫ‰D$…ΐX  …uL‹D$θό‰T$4…c  …ΐ…[  ‹D$‰Φ‹l$$9ΒOπ1Ι‰θ‰ςθό‹T$‰ρ‰θθό…ΐ…,  ‹D$1θό‹›  ‰|$θό{θόd΅    ‹p  ‰L$L$‰p  ‹[…Ϋt;‰|$>t& ‹K$S0D$ θό‰Ζ…φu|$ πwΗD$‹_ƒΗ…ΫuΖ‹L$d΅    ‰p  θόθό‹t$‹D$θό…φχ   ‹\$4‹D$$;\$u…Ϋxq‰t$t6Ή   ‰Ϊ‰$θό‹$‹D$‰Ωθό…ΐuF‹D$4‹L$θό…Ιu5‹D$$L$D9Θtθό‹D$dd+    …”   ‹D$ƒΔh[^_]Γ΄&    ‹D$$ΗD$ςλΑ΄&    v θόS0‹s$‰ΕD$ θό‹[‰Ζθό…    $ϊƒCƒƒS θό1)θCSƒCχ$   „Γώϋι½ώv ‰t$ιJθόfθόUWV‰ΦS‰Γƒμ<‹|$T‹D$P‰|$d‹    ‰T$8‹“δ  ‰\$‹‰D$Ψ‰t$ ‰D$‹D$X‰L$$‰D$‹²  ‰\$(ΗD$0    d‹    ΗD$4    ‰\$,θόθό‹ƒp  ‰D$D$‰ƒp  ‹^…ΫtC~¶    ‰|$>t& ‹K$S0D$θό‰Ζ…φu|$ πwΗD$‹_ƒΗ…ΫuΖ‹L$d΅    ‰p  θόθό‹D$…ΐx‹L$‹T$(;€   …ux‹T$8d+    uyƒΔ<[^_]Γv θόS0‹s$‰ΕD$θό‹[‰Ζθό…    $ϊƒCƒƒS θό1)θCSƒCχ$   „;ϋι5v ‰λ„Έςιzθό     cgroup_bpf_enabled_key  __cgroup_bpf_run_filter_skb  __cgroup_bpf_run_filter_sk  __cgroup_bpf_run_filter_sock_addr  __cgroup_bpf_run_filter_sock_ops                                                                        @   π  0  P  `  p  Π     °  @  ΐ  π  `	  ΐ  €                   p  °  π  °  0  p  €    ΐ  ΰ       0  P$  °$  @&  °'  (  ΰ)  ,   .  π0   4   6  cgroup_id:	%llu
attach_type:	%d
      ΐ      Τ  @        €      ¤         -  -      /  Θ/      T2   3      45  06      D7  Θ7      include/linux/skbuff.h / kernel/bpf/cgroup.c include/linux/thread_info.h °      φ	  ­     @       ƒ	 #     Υ 	 3  -   ι 	Έ$   θό ›  “  ή    ›$  &  &  s'  '  s(  ³)  S,   	
 strnlen           P      0                                          	                                                               @                           	                                                            	                                                             	                                                             	         
                                   °                                             
                                                                                                               ΐ  `  ΰ        p                       GCC: (GNU) 11.2.0           GNU  ΐ       ΐ                                  ρ              
              +             N              o             •   4          ½              γ   5            P          /            
 T  Q          €  s          ®             Ϊ  t            •          2             ]  @       w  0      •  P       ­  `  
     Ε  p  V     δ  Π  /     ϊ                           V     )  `  E    @  @  y                                 R  ΐ  Ό     a      
     u  $        €     i     ›         ²     ό     Ν     ϊ     ί     <     ώ  ΰ  <       €  <     -  @  <     P  ΐ   <     o     <     „     r     –     Ν    ©      #     ΄  °  w     Κ  0  7    β  p      ω  €  …        ΅     ,  ΐ       D  ΰ       [     
    q  `   <     ”  0      ¨  \                     ½           ϋ          :          r          «          X       Έ     Η   `	  W    9  °  6    Έ  π  ³    <  p  6    ί           ξ             ω                          π  3     2             ;             A             N             Y             f             p             ~             ‰             ›             ±             Κ             Φ             ο                                       (  °       A             H             O  ΐ  (     l  π  n     …             •             ¥             ·             Ζ             Ξ             Φ             δ  €  ™     ψ             	             '	             G	             e	             y	             ‹	             §	             Γ	             Ν	             ε	             ψ	             
             
             3
             G
             [
             t
             ‡
             
             »
             Σ
             μ
                                       .             D             \             k             ‚             –             ―  P$  Q     Β             ή  °$      ρ               @&  b                 +             A  °'  Ω     X  (  E    o             }                                       ­  ΰ)  ¬    Γ             η             Ω             υ  ,  b       .  ε    6             M             f  π0  
    ‰                          ­             Ύ             Λ   4      ξ             ϋ                6  ›    0  ,        D  0        \          o           †  Ό         Τ        cgroup.c __kstrtab_cgroup_bpf_enabled_key __kstrtabns_cgroup_bpf_enabled_key __ksymtab_cgroup_bpf_enabled_key __kstrtab___cgroup_bpf_run_filter_skb __kstrtabns___cgroup_bpf_run_filter_skb __ksymtab___cgroup_bpf_run_filter_skb __kstrtab___cgroup_bpf_run_filter_sk __kstrtabns___cgroup_bpf_run_filter_sk __ksymtab___cgroup_bpf_run_filter_sk __kstrtab___cgroup_bpf_run_filter_sock_addr __kstrtabns___cgroup_bpf_run_filter_sock_addr __ksymtab___cgroup_bpf_run_filter_sock_addr __kstrtab___cgroup_bpf_run_filter_sock_ops __kstrtabns___cgroup_bpf_run_filter_sock_ops __ksymtab___cgroup_bpf_run_filter_sock_ops sysctl_convert_ctx_access cg_sockopt_convert_ctx_access cg_sockopt_get_prologue bpf_cgroup_link_dealloc bpf_cgroup_link_fill_link_info cgroup_bpf_release_fn cgroup_bpf_release bpf_cgroup_link_show_fdinfo __bpf_prog_run_save_cb copy_sysctl_value sysctl_cpy_dir sysctl_cpy_dir.cold __func__.0 cgroup_dev_is_valid_access sysctl_is_valid_access cg_sockopt_is_valid_access sysctl_func_proto bpf_sysctl_get_new_value_proto bpf_set_retval_proto bpf_sysctl_get_name_proto bpf_sysctl_get_current_value_proto bpf_sysctl_set_new_value_proto bpf_get_retval_proto sockopt_alloc_buf cgroup_bpf_replace CSWTCH.197 cgroup_dev_func_proto compute_effective_progs update_effective_progs __cgroup_bpf_detach bpf_cgroup_link_release.part.0 bpf_cgroup_link_release bpf_cgroup_link_detach cg_sockopt_func_proto bpf_get_netns_cookie_sockopt_proto __cgroup_bpf_attach bpf_cgroup_link_lops __UNIQUE_ID___addressable___cgroup_bpf_run_filter_sock_ops491 __UNIQUE_ID___addressable___cgroup_bpf_run_filter_sock_addr490 __UNIQUE_ID___addressable___cgroup_bpf_run_filter_sk489 __UNIQUE_ID___addressable___cgroup_bpf_run_filter_skb488 __UNIQUE_ID___addressable_cgroup_bpf_enabled_key483 bpf_get_retval __fentry__ current_task bpf_set_retval bpf_get_netns_cookie_sockopt init_net kcmd_drivers/media/i2c/vp27smpx.o := gcc -Wp,-MMD,drivers/media/i2c/.vp27smpx.o.d -nostdinc -I./arch/x86/include -I./arch/x86/include/generated  -I./include -I./arch/x86/include/uapi -I./arch/x86/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/compiler-version.h -include ./include/linux/kconfig.h -include ./include/linux/compiler_types.h -D__KERNEL__ -fmacro-prefix-map=./= -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=implicit-function-declaration -Werror=implicit-int -Werror=return-type -Wno-format-security -std=gnu11 -mno-sse -mno-mmx -mno-sse2 -mno-3dnow -mno-avx -fcf-protection=none -m32 -msoft-float -mregparm=3 -freg-struct-return -fno-pic -mpreferred-stack-boundary=2 -march=i686 -mtune=pentium3 -mtune=generic -Wa,-mtune=generic32 -ffreestanding -mstack-protector-guard-reg=fs -mstack-protector-guard-symbol=__stack_chk_guard -Wno-sign-compare -fno-asynchronous-unwind-tables -mindirect-branch=thunk-extern -mindirect-branch-register -fno-jump-tables -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-address-of-packed-member -O2 -fno-allow-store-data-races -fstack-protector-strong -Wimplicit-fallthrough=5 -Wno-main -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-stack-clash-protection -pg -mrecord-mcount -mfentry -DCC_USING_FENTRY -Wdeclaration-after-statement -Wvla -Wno-pointer-sign -Wcast-function-type -Wno-stringop-truncation -Wno-stringop-overflow -Wno-restrict -Wno-maybe-uninitialized -Wno-alloc-size-larger-than -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init -Wno-packed-not-aligned  -DMODULE  -DKBUILD_BASENAME='"vp27smpx"' -DKBUILD_MODNAME='"vp27smpx"' -D__KBUILD_MODNAME=kmod_vp27smpx -c -o drivers/media/i2c/vp27smpx.o drivers/media/i2c/vp27smpx.c 

source_drivers/media/i2c/vp27smpx.o := drivers/media/i2c/vp27smpx.c

deps_drivers/media/i2c/vp27smpx.o := \
  include/linux/compiler-version.h \
    $(wildcard include/config/CC_VERSION_TEXT) \
  include/linux/kconfig.h \
    $(wildcard include/config/CPU_BIG_ENDIAN) \
    $(wildcard include/config/BOOGER) \
    $(wildcard include/config/FOO) \
  include/linux/compiler_types.h \
    $(wildcard include/config/DEBUG_INFO_BTF) \
    $(wildcard include/config/PAHOLE_HAS_BTF_TAG) \
    $(wildcard include/config/HAVE_ARCH_COMPILER_H) \
    $(wildcard include/config/CC_HAS_ASM_INLINE) \
  include/linux/compiler_attributes.h \
  include/linux/compiler-gcc.h \
    $(wildcard include/config/RETPOLINE) \
    $(wildcard include/config/ARCH_USE_BUILTIN_BSWAP) \
    $(wildcard include/config/SHADOW_CALL_STACK) \
    $(wildcard include/config/KCOV) \
  include/linux/module.h \
    $(wildcard include/config/MODULES) \
    $(wildcard include/config/SYSFS) \
    $(wildcard include/config/MODULES_TREE_LOOKUP) \
    $(wildcard include/config/LIVEPATCH) \
    $(wildcard include/config/STACKTRACE_BUILD_ID) \
    $(wildcard include/config/CFI_CLANG) \
    $(wildcard include/config/MODULE_SIG) \
    $(wildcard include/config/GENERIC_BUG) \
    $(wildcard include/config/KALLSYMS) \
    $(wildcard include/config/SMP) \
    $(wildcard include/config/TRACEPOINTS) \
    $(wildcard include/config/TREE_SRCU) \
    $(wildcard include/config/BPF_EVENTS) \
    $(wildcard include/config/DEBUG_INFO_BTF_MODULES) \
    $(wildcard include/config/JUMP_LABEL) \
    $(wildcard include/config/TRACING) \
    $(wildcard include/config/EVENT_TRACING) \
    $(wildcard include/config/FTRACE_MCOUNT_RECORD) \
    $(wildcard include/config/KPROBES) \
    $(wildcard include/config/HAVE_STATIC_CALL_INLINE) \
    $(wildcard include/config/PRINTK_INDEX) \
    $(wildcard include/config/MODULE_UNLOAD) \
    $(wildcard include/config/CONSTRUCTORS) \
    $(wildcard include/config/FUNCTION_ERROR_INJECTION) \
  include/linux/list.h \
    $(wildcard include/config/DEBUG_LIST) \
  include/linux/container_of.h \
  include/linux/build_bug.h \
  include/linux/compiler.h \
    $(wildcard include/config/TRACE_BRANCH_PROFILING) \
    $(wildcard include/config/PROFILE_ALL_BRANCHES) \
    $(wildcard include/config/STACK_VALIDATION) \
  include/linux/compiler_types.h \
  arch/x86/include/generated/asm/rwonce.h \
  include/asm-generic/rwonce.h \
  include/linux/kasan-checks.h \
    $(wildcard include/config/KASAN_GENERIC) \
    $(wildcard include/config/KASAN_SW_TAGS) \
  include/linux/types.h \
    $(wildcard include/config/HAVE_UID16) \
    $(wildcard include/config/UID16) \
    $(wildcard include/config/ARCH_DMA_ADDR_T_64BIT) \
    $(wildcard include/config/PHYS_ADDR_T_64BIT) \
    $(wildcard include/config/64BIT) \
    $(wildcard include/config/ARCH_32BIT_USTAT_F_TINODE) \
  include/uapi/linux/types.h \
  arch/x86/include/generated/uapi/asm/types.h \
  include/uapi/asm-generic/types.h \
  include/asm-generic/int-ll64.h \
  include/uapi/asm-generic/int-ll64.h \
  arch/x86/include/uapi/asm/bitsperlong.h \
  include/asm-generic/bitsperlong.h \
  include/uapi/asm-generic/bitsperlong.h \
  include/uapi/linux/posix_types.h \
  include/linux/stddef.h \
  include/uapi/linux/stddef.h \
  arch/x86/include/asm/posix_types.h \
    $(wildcard include/config/X86_32) \
  arch/x86/include/uapi/asm/posix_types_32.h \
  include/uapi/asm-generic/posix_types.h \
  include/linux/kcsan-checks.h \
    $(wildcard include/config/KCSAN) \
    $(wildcard include/config/KCSAN_WEAK_MEMORY) \
    $(wildcard include/config/KCSAN_IGNORE_ATOMICS) \
  include/linux/err.h \
  arch/x86/include/generated/uapi/asm/errno.h \
  include/uapi/asm-generic/errno.h \
  include/uapi/asm-generic/errno-base.h \
  include/linux/poison.h \
    $(wildcard include/config/ILLEGAL_POINTER_VALUE) \
  include/linux/const.h \
  include/vdso/const.h \
  include/uapi/linux/const.h \
  arch/x86/include/asm/barrier.h \
  arch/x86/include/asm/alternative.h \
  include/linux/stringify.h \
  arch/x86/include/asm/asm.h \
  arch/x86/include/asm/extable_fixup_types.h \
  arch/x86/include/asm/nops.h \
  include/asm-generic/barrier.h \
  include/linux/stat.h \
  arch/x86/include/uapi/asm/stat.h \
  include/uapi/linux/stat.h \
  include/linux/time.h \
    $(wildcard include/config/POSIX_TIMERS) \
  include/linux/cache.h \
    $(wildcard include/config/ARCH_HAS_CACHE_LINE_SIZE) \
  include/uapi/linux/kernel.h \
  include/uapi/linux/sysinfo.h \
  arch/x86/include/asm/cache.h \
    $(wildcard include/config/X86_L1_CACHE_SHIFT) \
    $(wildcard include/config/X86_INTERNODE_CACHE_SHIFT) \
    $(wildcard include/config/X86_VSMP) \
  include/linux/linkage.h \
    $(wildcard include/config/ARCH_USE_SYM_ANNOTATIONS) \
  include/linux/export.h \
    $(wildcard include/config/MODVERSIONS) \
    $(wildcard include/config/MODULE_REL_CRCS) \
    $(wildcard include/config/HAVE_ARCH_PREL32_RELOCATIONS) \
    $(wildcard include/config/TRIM_UNUSED_KSYMS) \
  arch/x86/include/asm/linkage.h \
    $(wildcard include/config/X86_64) \
    $(wildcard include/config/X86_ALIGNMENT_16) \
    $(wildcard include/config/SLS) \
  arch/x86/include/asm/ibt.h \
    $(wildcard include/config/X86_KERNEL_IBT) \
  include/linux/math64.h \
    $(wildcard include/config/ARCH_SUPPORTS_INT128) \
  include/linux/math.h \
  arch/x86/include/asm/div64.h \
  include/linux/log2.h \
    $(wildcard include/config/ARCH_HAS_ILOG2_U32) \
    $(wildcard include/config/ARCH_HAS_ILOG2_U64) \
  include/linux/bitops.h \
  include/linux/bits.h \
  include/vdso/bits.h \
  include/linux/typecheck.h \
  arch/x86/include/asm/bitops.h \
    $(wildcard include/config/X86_CMOV) \
  arch/x86/include/asm/rmwcc.h \
    $(wildcard include/config/CC_HAS_ASM_GOTO) \
  include/asm-generic/bitops/fls64.h \
  include/asm-generic/bitops/sched.h \
  arch/x86/include/asm/arch_hweight.h \
  arch/x86/include/asm/cpufeatures.h \
  arch/x86/include/asm/required-features.h \
    $(wildcard include/config/X86_MINIMUM_CPU_FAMILY) \
    $(wildcard include/config/MATH_EMULATION) \
    $(wildcard include/config/X86_PAE) \
    $(wildcard include/config/X86_CMPXCHG64) \
    $(wildcard include/config/X86_P6_NOP) \
    $(wildcard include/config/MATOM) \
    $(wildcard include/config/PARAVIRT_XXL) \
  arch/x86/include/asm/disabled-features.h \
    $(wildcard include/config/X86_SMAP) \
    $(wildcard include/config/X86_UMIP) \
    $(wildcard include/config/X86_INTEL_MEMORY_PROTECTION_KEYS) \
    $(wildcard include/config/X86_5LEVEL) \
    $(wildcard include/config/PAGE_TABLE_ISOLATION) \
    $(wildcard include/config/INTEL_IOMMU_SVM) \
    $(wildcard include/config/X86_SGX) \
  include/asm-generic/bitops/const_hweight.h \
  include/asm-generic/bitops/instrumented-atomic.h \
  include/linux/instrumented.h \
  include/asm-generic/bitops/instrumented-non-atomic.h \
    $(wildcard include/config/KCSAN_ASSUME_PLAIN_WRITES_ATOMIC) \
  include/asm-generic/bitops/instrumented-lock.h \
  include/asm-generic/bitops/le.h \
  arch/x86/include/uapi/asm/byteorder.h \
  include/linux/byteorder/little_endian.h \
  include/uapi/linux/byteorder/little_endian.h \
  include/linux/swab.h \
  include/uapi/linux/swab.h \
  arch/x86/include/uapi/asm/swab.h \
  include/linux/byteorder/generic.h \
  include/asm-generic/bitops/ext2-atomic-setbit.h \
  include/vdso/math64.h \
  include/linux/time64.h \
  include/vdso/time64.h \
  include/uapi/linux/time.h \
  include/uapi/linux/time_types.h \
  include/linux/time32.h \
  include/linux/timex.h \
  include/uapi/linux/timex.h \
  include/uapi/linux/param.h \
  arch/x86/include/generated/uapi/asm/param.h \
  include/asm-generic/param.h \
    $(wildcard include/config/HZ) \
  include/uapi/asm-generic/param.h \
  arch/x86/include/asm/timex.h \
    $(wildcard include/config/X86_TSC) \
  arch/x86/include/asm/processor.h \
    $(wildcard include/config/X86_VMX_FEATURE_NAMES) \
    $(wildcard include/config/X86_IOPL_IOPERM) \
    $(wildcard include/config/STACKPROTECTOR) \
    $(wildcard include/config/VM86) \
    $(wildcard include/config/X86_DEBUGCTLMSR) \
    $(wildcard include/config/CPU_SUP_AMD) \
    $(wildcard include/config/XEN) \
  arch/x86/include/asm/processor-flags.h \
  arch/x86/include/uapi/asm/processor-flags.h \
  include/linux/mem_encrypt.h \
    $(wildcard include/config/ARCH_HAS_MEM_ENCRYPT) \
    $(wildcard include/config/AMD_MEM_ENCRYPT) \
  arch/x86/include/asm/mem_encrypt.h \
  include/linux/init.h \
    $(wildcard include/config/STRICT_KERNEL_RWX) \
    $(wildcard include/config/STRICT_MODULE_RWX) \
    $(wildcard include/config/LTO_CLANG) \
  include/linux/cc_platform.h \
    $(wildcard include/config/ARCH_HAS_CC_PLATFORM) \
  arch/x86/include/uapi/asm/bootparam.h \
  include/linux/screen_info.h \
  include/uapi/linux/screen_info.h \
  include/linux/apm_bios.h \
  include/uapi/linux/apm_bios.h \
  include/uapi/linux/ioctl.h \
  arch/x86/include/generated/uapi/asm/ioctl.h \
  include/asm-generic/ioctl.h \
  include/uapi/asm-generic/ioctl.h \
  include/linux/edd.h \
  include/uapi/linux/edd.h \
  arch/x86/include/asm/ist.h \
  arch/x86/include/uapi/asm/ist.h \
  include/video/edid.h \
    $(wildcard include/config/X86) \
  include/uapi/video/edid.h \
  arch/x86/include/asm/math_emu.h \
  arch/x86/include/asm/ptrace.h \
    $(wildcard include/config/PARAVIRT) \
    $(wildcard include/config/IA32_EMULATION) \
  arch/x86/include/asm/segment.h \
    $(wildcard include/config/XEN_PV) \
  arch/x86/include/asm/page_types.h \
    $(wildcard include/config/PHYSICAL_START) \
    $(wildcard include/config/PHYSICAL_ALIGN) \
    $(wildcard include/config/DYNAMIC_PHYSICAL_MASK) \
  arch/x86/include/asm/page_32_types.h \
    $(wildcard include/config/HIGHMEM4G) \
    $(wildcard include/config/HIGHMEM64G) \
    $(wildcard include/config/PAGE_OFFSET) \
  arch/x86/include/uapi/asm/ptrace.h \
  arch/x86/include/uapi/asm/ptrace-abi.h \
  arch/x86/include/asm/paravirt_types.h \
    $(wildcard include/config/PGTABLE_LEVELS) \
    $(wildcard include/config/PARAVIRT_DEBUG) \
  arch/x86/include/asm/desc_defs.h \
  arch/x86/include/asm/pgtable_types.h \
    $(wildcard include/config/MEM_SOFT_DIRTY) \
    $(wildcard include/config/HAVE_ARCH_USERFAULTFD_WP) \
    $(wildcard include/config/PROC_FS) \
  arch/x86/include/asm/pgtable_32_types.h \
  arch/x86/include/asm/pgtable-3level_types.h \
  include/asm-generic/pgtable-nop4d.h \
  include/asm-generic/pgtable-nopud.h \
  arch/x86/include/asm/nospec-branch.h \
  include/linux/static_key.h \
  include/linux/jump_label.h \
    $(wildcard include/config/HAVE_ARCH_JUMP_LABEL_RELATIVE) \
  arch/x86/include/asm/jump_label.h \
  include/linux/objtool.h \
    $(wildcard include/config/FRAME_POINTER) \
  arch/x86/include/asm/msr-index.h \
  arch/x86/include/asm/unwind_hints.h \
  arch/x86/include/asm/orc_types.h \
  arch/x86/include/asm/GEN-for-each-reg.h \
  arch/x86/include/asm/spinlock_types.h \
  include/asm-generic/qspinlock_types.h \
    $(wildcard include/config/NR_CPUS) \
  include/asm-generic/qrwlock_types.h \
  arch/x86/include/asm/proto.h \
  arch/x86/include/uapi/asm/ldt.h \
  arch/x86/include/uapi/asm/sigcontext.h \
  arch/x86/include/asm/current.h \
  arch/x86/include/asm/percpu.h \
    $(wildcard include/config/X86_64_SMP) \
  include/linux/kernel.h \
    $(wildcard include/config/PREEMPT_VOLUNTARY_BUILD) \
    $(wildcard include/config/PREEMPT_DYNAMIC) \
    $(wildcard include/config/HAVE_PREEMPT_DYNAMIC_CALL) \
    $(wildcard include/config/HAVE_PREEMPT_DYNAMIC_KEY) \
    $(wildcard include/config/PREEMPT_) \
    $(wildcard include/config/DEBUG_ATOMIC_SLEEP) \
    $(wildcard include/config/MMU) \
    $(wildcard include/config/PROVE_LOCKING) \
  include/linux/stdarg.h \
  include/linux/align.h \
  include/linux/limits.h \
  include/uapi/linux/limits.h \
  include/vdso/limits.h \
  include/linux/kstrtox.h \
  include/linux/minmax.h \
  include/linux/panic.h \
    $(wildcard include/config/PANIC_TIMEOUT) \
  include/linux/printk.h \
    $(wildcard include/config/MESSAGE_LOGLEVEL_DEFAULT) \
    $(wildcard include/config/CONSOLE_LOGLEVEL_DEFAULT) \
    $(wildcard include/config/CONSOLE_LOGLEVEL_QUIET) \
    $(wildcard include/config/EARLY_PRINTK) \
    $(wildcard include/config/PRINTK) \
    $(wildcard include/config/DYNAMIC_DEBUG) \
    $(wildcard include/config/DYNAMIC_DEBUG_CORE) \
  include/linux/kern_levels.h \
  include/linux/ratelimit_types.h \
  include/linux/spinlock_types_raw.h \
    $(wildcard include/config/DEBUG_SPINLOCK) \
    $(wildcard include/config/DEBUG_LOCK_ALLOC) \
  include/linux/lockdep_types.h \
    $(wildcard include/config/PROVE_RAW_LOCK_NESTING) \
    $(wildcard include/config/LOCKDEP) \
    $(wildcard include/config/LOCK_STAT) \
  include/linux/once_lite.h \
  include/linux/static_call_types.h \
    $(wildcard include/config/HAVE_STATIC_CALL) \
  include/linux/instruction_pointer.h \
  include/asm-generic/percpu.h \
    $(wildcard include/config/DEBUG_PREEMPT) \
    $(wildcard include/config/HAVE_SETUP_PER_CPU_AREA) \
  include/linux/threads.h \
    $(wildcard include/config/BASE_SMALL) \
  include/linux/percpu-defs.h \
    $(wildcard include/config/DEBUG_FORCE_WEAK_PER_CPU) \
  arch/x86/include/asm/page.h \
  arch/x86/include/asm/page_32.h \
    $(wildcard include/config/DEBUG_VIRTUAL) \
    $(wildcard include/config/FLATMEM) \
  include/linux/string.h \
    $(wildcard include/config/BINARY_PRINTF) \
    $(wildcard include/config/FORTIFY_SOURCE) \
  include/linux/errno.h \
  include/uapi/linux/errno.h \
  include/uapi/linux/string.h \
  arch/x86/include/asm/string.h \
  arch/x86/include/asm/string_32.h \
  include/linux/fortify-string.h \
  include/linux/range.h \
  include/asm-generic/memory_model.h \
    $(wildcard include/config/SPARSEMEM_VMEMMAP) \
    $(wildcard include/config/SPARSEMEM) \
  include/linux/pfn.h \
  include/asm-generic/getorder.h \
  arch/x86/include/asm/msr.h \
  arch/x86/include/asm/msr-index.h \
  arch/x86/include/asm/cpumask.h \
  include/linux/cpumask.h \
    $(wildcard include/config/CPUMASK_OFFSTACK) \
    $(wildcard include/config/HOTPLUG_CPU) \
    $(wildcard include/config/DEBUG_PER_CPU_MAPS) \
  include/linux/bitmap.h \
  include/linux/find.h \
  include/linux/atomic.h \
  arch/x86/include/asm/atomic.h \
  arch/x86/include/asm/cmpxchg.h \
  arch/x86/include/asm/cmpxchg_32.h \
  arch/x86/include/asm/atomic64_32.h \
  include/linux/atomic/atomic-arch-fallback.h \
    $(wildcard include/config/GENERIC_ATOMIC64) \
  include/linux/atomic/atomic-long.h \
  include/linux/atomic/atomic-instrumented.h \
  include/linux/bug.h \
    $(wildcard include/config/BUG_ON_DATA_CORRUPTION) \
  arch/x86/include/asm/bug.h \
    $(wildcard include/config/DEBUG_BUGVERBOSE) \
  include/linux/instrumentation.h \
    $(wildcard include/config/DEBUG_ENTRY) \
  include/asm-generic/bug.h \
    $(wildcard include/config/BUG) \
    $(wildcard include/config/GENERIC_BUG_RELATIVE_POINTERS) \
  arch/x86/include/uapi/asm/msr.h \
  include/linux/tracepoint-defs.h \
  arch/x86/include/asm/special_insns.h \
  include/linux/irqflags.h \
    $(wildcard include/config/TRACE_IRQFLAGS) \
    $(wildcard include/config/PREEMPT_RT) \
    $(wildcard include/config/IRQSOFF_TRACER) \
    $(wildcard include/config/PREEMPT_TRACER) \
    $(wildcard include/config/DEBUG_IRQFLAGS) \
    $(wildcard include/config/TRACE_IRQFLAGS_SUPPORT) \
  arch/x86/include/asm/irqflags.h \
  arch/x86/include/asm/fpu/types.h \
  arch/x86/include/asm/vmxfeatures.h \
  arch/x86/include/asm/vdso/processor.h \
  include/linux/personality.h \
  include/uapi/linux/personality.h \
  arch/x86/include/asm/tsc.h \
  arch/x86/include/asm/cpufeature.h \
    $(wildcard include/config/X86_FEATURE_NAMES) \
  include/vdso/time32.h \
  include/vdso/time.h \
  include/linux/uidgid.h \
    $(wildcard include/config/MULTIUSER) \
    $(wildcard include/config/USER_NS) \
  include/linux/highuid.h \
  include/linux/buildid.h \
    $(wildcard include/config/CRASH_CORE) \
  include/linux/mm_types.h \
    $(wildcard include/config/HAVE_ALIGNED_STRUCT_PAGE) \
    $(wildcard include/config/MEMCG) \
    $(wildcard include/config/USERFAULTFD) \
    $(wildcard include/config/SWAP) \
    $(wildcard include/config/NUMA) \
    $(wildcard include/config/HAVE_ARCH_COMPAT_MMAP_BASES) \
    $(wildcard include/config/MEMBARRIER) \
    $(wildcard include/config/AIO) \
    $(wildcard include/config/MMU_NOTIFIER) \
    $(wildcard include/config/TRANSPARENT_HUGEPAGE) \
    $(wildcard include/config/NUMA_BALANCING) \
    $(wildcard include/config/ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH) \
    $(wildcard include/config/HUGETLB_PAGE) \
    $(wildcard include/config/IOMMU_SVA) \
  include/linux/mm_types_task.h \
    $(wildcard include/config/SPLIT_PTLOCK_CPUS) \
    $(wildcard include/config/ARCH_ENABLE_SPLIT_PMD_PTLOCK) \
  arch/x86/include/asm/tlbbatch.h \
  include/linux/auxvec.h \
  include/uapi/linux/auxvec.h \
  arch/x86/include/uapi/asm/auxvec.h \
  include/linux/kref.h \
  include/linux/spinlock.h \
    $(wildcard include/config/PREEMPTION) \
  include/linux/preempt.h \
    $(wildcard include/config/PREEMPT_COUNT) \
    $(wildcard include/config/TRACE_PREEMPT_TOGGLE) \
    $(wildcard include/config/PREEMPT_NOTIFIERS) \
  arch/x86/include/asm/preempt.h \
  include/linux/thread_info.h \
    $(wildcard include/config/THREAD_INFO_IN_TASK) \
    $(wildcard include/config/GENERIC_ENTRY) \
    $(wildcard include/config/HAVE_ARCH_WITHIN_STACK_FRAMES) \
    $(wildcard include/config/HARDENED_USERCOPY) \
  include/linux/restart_block.h \
  arch/x86/include/asm/thread_info.h \
    $(wildcard include/config/COMPAT) \
  include/linux/bottom_half.h \
  include/linux/lockdep.h \
    $(wildcard include/config/DEBUG_LOCKING_API_SELFTESTS) \
  include/linux/smp.h \
    $(wildcard include/config/UP_LATE_INIT) \
  include/linux/smp_types.h \
  include/linux/llist.h \
    $(wildcard include/config/ARCH_HAVE_NMI_SAFE_CMPXCHG) \
  arch/x86/include/asm/smp.h \
    $(wildcard include/config/X86_LOCAL_APIC) \
    $(wildcard include/config/DEBUG_NMI_SELFTEST) \
  arch/x86/include/generated/asm/mmiowb.h \
  include/asm-generic/mmiowb.h \
    $(wildcard include/config/MMIOWB) \
  include/linux/spinlock_types.h \
  include/linux/rwlock_types.h \
  arch/x86/include/asm/spinlock.h \
  arch/x86/include/asm/paravirt.h \
    $(wildcard include/config/PARAVIRT_SPINLOCKS) \
  arch/x86/include/asm/frame.h \
  arch/x86/include/asm/qspinlock.h \
  include/asm-generic/qspinlock.h \
  arch/x86/include/asm/qrwlock.h \
  include/asm-generic/qrwlock.h \
  include/linux/rwlock.h \
    $(wildcard include/config/PREEMPT) \
  include/linux/spinlock_api_smp.h \
    $(wildcard include/config/INLINE_SPIN_LOCK) \
    $(wildcard include/config/INLINE_SPIN_LOCK_BH) \
    $(wildcard include/config/INLINE_SPIN_LOCK_IRQ) \
    $(wildcard include/config/INLINE_SPIN_LOCK_IRQSAVE) \
    $(wildcard include/config/INLINE_SPIN_TRYLOCK) \
    $(wildcard include/config/INLINE_SPIN_TRYLOCK_BH) \
    $(wildcard include/config/UNINLINE_SPIN_UNLOCK) \
    $(wildcard include/config/INLINE_SPIN_UNLOCK_BH) \
    $(wildcard include/config/INLINE_SPIN_UNLOCK_IRQ) \
    $(wildcard include/config/INLINE_SPIN_UNLOCK_IRQRESTORE) \
    $(wildcard include/config/GENERIC_LOCKBREAK) \
  include/linux/rwlock_api_smp.h \
    $(wildcard include/config/INLINE_READ_LOCK) \
    $(wildcard include/config/INLINE_WRITE_LOCK) \
    $(wildcard include/config/INLINE_READ_LOCK_BH) \
    $(wildcard include/config/INLINE_WRITE_LOCK_BH) \
    $(wildcard include/config/INLINE_READ_LOCK_IRQ) \
    $(wildcard include/config/INLINE_WRITE_LOCK_IRQ) \
    $(wildcard include/config/INLINE_READ_LOCK_IRQSAVE) \
    $(wildcard include/config/INLINE_WRITE_LOCK_IRQSAVE) \
    $(wildcard include/config/INLINE_READ_TRYLOCK) \
    $(wildcard include/config/INLINE_WRITE_TRYLOCK) \
    $(wildcard include/config/INLINE_READ_UNLOCK) \
    $(wildcard include/config/INLINE_WRITE_UNLOCK) \
    $(wildcard include/config/INLINE_READ_UNLOCK_BH) \
    $(wildcard include/config/INLINE_WRITE_UNLOCK_BH) \
    $(wildcard include/config/INLINE_READ_UNLOCK_IRQ) \
    $(wildcard include/config/INLINE_WRITE_UNLOCK_IRQ) \
    $(wildcard include/config/INLINE_READ_UNLOCK_IRQRESTORE) \
    $(wildcard include/config/INLINE_WRITE_UNLOCK_IRQRESTORE) \
  include/linux/refcount.h \
  include/linux/rbtree.h \
  include/linux/rbtree_types.h \
  include/linux/rcupdate.h \
    $(wildcard include/config/PREEMPT_RCU) \
    $(wildcard include/config/TINY_RCU) \
    $(wildcard include/config/RCU_STRICT_GRACE_PERIOD) \
    $(wildcard include/config/TASKS_RCU_GENERIC) \
    $(wildcard include/config/RCU_STALL_COMMON) \
    $(wildcard include/config/NO_HZ_FULL) \
    $(wildcard include/config/RCU_NOCB_CPU) \
    $(wildcard include/config/TASKS_RCU) \
    $(wildcard include/config/TASKS_TRACE_RCU) \
    $(wildcard include/config/TASKS_RUDE_RCU) \
    $(wildcard include/config/TREE_RCU) \
    $(wildcard include/config/DEBUG_OBJECTS_RCU_HEAD) \
    $(wildcard include/config/PROVE_RCU) \
    $(wildcard include/config/ARCH_WEAK_RELEASE_ACQUIRE) \
  include/linux/rcutree.h \
  include/linux/rwsem.h \
    $(wildcard include/config/RWSEM_SPIN_ON_OWNER) \
    $(wildcard include/config/DEBUG_RWSEMS) \
  include/linux/osq_lock.h \
  include/linux/completion.h \
  include/linux/swait.h \
  include/linux/wait.h \
  include/uapi/linux/wait.h \
  include/linux/uprobes.h \
    $(wildcard include/config/UPROBES) \
  arch/x86/include/asm/uprobes.h \
  include/linux/notifier.h \
  include/linux/mutex.h \
    $(wildcard include/config/MUTEX_SPIN_ON_OWNER) \
    $(wildcard include/config/DEBUG_MUTEXES) \
  include/linux/debug_locks.h \
  include/linux/srcu.h \
    $(wildcard include/config/TINY_SRCU) \
    $(wildcard include/config/SRCU) \
  include/linux/workqueue.h \
    $(wildcard include/config/DEBUG_OBJECTS_WORK) \
    $(wildcard include/config/FREEZER) \
    $(wildcard include/config/WQ_WATCHDOG) \
  include/linux/timer.h \
    $(wildcard include/config/DEBUG_OBJECTS_TIMERS) \
    $(wildcard include/config/NO_HZ_COMMON) \
  include/linux/ktime.h \
  include/linux/jiffies.h \
  include/vdso/jiffies.h \
  include/generated/timeconst.h \
  include/vdso/ktime.h \
  include/linux/timekeeping.h \
    $(wildcard include/config/GENERIC_CMOS_UPDATE) \
  include/linux/clocksource_ids.h \
  include/linux/debugobjects.h \
    $(wildcard include/config/DEBUG_OBJECTS) \
    $(wildcard include/config/DEBUG_OBJECTS_FREE) \
  include/linux/rcu_segcblist.h \
  include/linux/srcutree.h \
  include/linux/rcu_node_tree.h \
    $(wildcard include/config/RCU_FANOUT) \
    $(wildcard include/config/RCU_FANOUT_LEAF) \
  include/linux/page-flags-layout.h \
    $(wildcard include/config/KASAN_HW_TAGS) \
  include/linux/numa.h \
    $(wildcard include/config/NODES_SHIFT) \
    $(wildcard include/config/NUMA_KEEP_MEMINFO) \
    $(wildcard include/config/HAVE_ARCH_NODE_DEV_GROUP) \
  arch/x86/include/asm/sparsemem.h \
  include/generated/bounds.h \
  include/linux/seqlock.h \
  include/linux/ww_mutex.h \
    $(wildcard include/config/DEBUG_RT_MUTEXES) \
    $(wildcard include/config/DEBUG_WW_MUTEX_SLOWPATH) \
  include/linux/rtmutex.h \
  arch/x86/include/asm/mmu.h \
    $(wildcard include/config/MODIFY_LDT_SYSCALL) \
  include/linux/kmod.h \
  include/linux/umh.h \
  include/linux/gfp.h \
    $(wildcard include/config/HIGHMEM) \
    $(wildcard include/config/ZONE_DMA) \
    $(wildcard include/config/ZONE_DMA32) \
    $(wildcard include/config/ZONE_DEVICE) \
    $(wildcard include/config/PM_SLEEP) \
    $(wildcard include/config/CONTIG_ALLOC) \
    $(wildcard include/config/CMA) \
  include/linux/mmdebug.h \
    $(wildcard include/config/DEBUG_VM) \
    $(wildcard include/config/DEBUG_VM_PGFLAGS) \
  include/linux/mmzone.h \
    $(wildcard include/config/FORCE_MAX_ZONEORDER) \
    $(wildcard include/config/MEMORY_ISOLATION) \
    $(wildcard include/config/ZSMALLOC) \
    $(wildcard include/config/MEMORY_HOTPLUG) \
    $(wildcard include/config/COMPACTION) \
    $(wildcard include/config/PAGE_EXTENSION) \
    $(wildcard include/config/DEFERRED_STRUCT_PAGE_INIT) \
    $(wildcard include/config/HAVE_MEMORYLESS_NODES) \
    $(wildcard include/config/SPARSEMEM_EXTREME) \
    $(wildcard include/config/HAVE_ARCH_PFN_VALID) \
  include/linux/nodemask.h \
  include/linux/pageblock-flags.h \
    $(wildcard include/config/HUGETLB_PAGE_SIZE_VARIABLE) \
  include/linux/page-flags.h \
    $(wildcard include/config/ARCH_USES_PG_UNCACHED) \
    $(wildcard include/config/MEMORY_FAILURE) \
    $(wildcard include/config/PAGE_IDLE_FLAG) \
    $(wildcard include/config/HUGETLB_PAGE_FREE_VMEMMAP) \
    $(wildcard include/config/HUGETLB_PAGE_FREE_VMEMMAP_DEFAULT_ON) \
    $(wildcard include/config/KSM) \
  include/linux/local_lock.h \
  include/linux/local_lock_internal.h \
  include/linux/memory_hotplug.h \
    $(wildcard include/config/HAVE_ARCH_NODEDATA_EXTENSION) \
    $(wildcard include/config/ARCH_HAS_ADD_PAGES) \
    $(wildcard include/config/MEMORY_HOTREMOVE) \
  arch/x86/include/asm/mmzone.h \
  arch/x86/include/asm/mmzone_32.h \
  include/linux/topology.h \
    $(wildcard include/config/USE_PERCPU_NUMA_NODE_ID) \
    $(wildcard include/config/SCHED_SMT) \
    $(wildcard include/config/SCHED_CLUSTER) \
  include/linux/arch_topology.h \
    $(wildcard include/config/ACPI_CPPC_LIB) \
    $(wildcard include/config/GENERIC_ARCH_TOPOLOGY) \
  include/linux/percpu.h \
    $(wildcard include/config/NEED_PER_CPU_EMBED_FIRST_CHUNK) \
    $(wildcard include/config/NEED_PER_CPU_PAGE_FIRST_CHUNK) \
  arch/x86/include/asm/topology.h \
    $(wildcard include/config/SCHED_MC_PRIO) \
  arch/x86/include/asm/mpspec.h \
    $(wildcard include/config/EISA) \
    $(wildcard include/config/X86_MPPARSE) \
  arch/x86/include/asm/mpspec_def.h \
  arch/x86/include/asm/x86_init.h \
  arch/x86/include/asm/apicdef.h \
  include/asm-generic/topology.h \
  include/linux/sysctl.h \
    $(wildcard include/config/SYSCTL) \
  include/uapi/linux/sysctl.h \
  include/linux/elf.h \
    $(wildcard include/config/ARCH_USE_GNU_PROPERTY) \
    $(wildcard include/config/ARCH_HAVE_ELF_PROT) \
  arch/x86/include/asm/elf.h \
    $(wildcard include/config/X86_X32_ABI) \
  arch/x86/include/asm/user.h \
  arch/x86/include/asm/user_32.h \
  arch/x86/include/asm/fsgsbase.h \
  arch/x86/include/asm/vdso.h \
  arch/x86/include/asm/desc.h \
  arch/x86/include/asm/fixmap.h \
    $(wildcard include/config/DEBUG_KMAP_LOCAL_FORCE_MAP) \
    $(wildcard include/config/X86_VSYSCALL_EMULATION) \
    $(wildcard include/config/PROVIDE_OHCI1394_DMA_INIT) \
    $(wildcard include/config/X86_IO_APIC) \
    $(wildcard include/config/KMAP_LOCAL) \
    $(wildcard include/config/PCI_MMCONFIG) \
    $(wildcard include/config/ACPI_APEI_GHES) \
    $(wildcard include/config/INTEL_TXT) \
  arch/x86/include/generated/asm/kmap_size.h \
  include/asm-generic/kmap_size.h \
    $(wildcard include/config/DEBUG_KMAP_LOCAL) \
  include/asm-generic/fixmap.h \
  arch/x86/include/asm/irq_vectors.h \
    $(wildcard include/config/HAVE_KVM) \
    $(wildcard include/config/HYPERV) \
    $(wildcard include/config/PCI_MSI) \
  arch/x86/include/asm/cpu_entry_area.h \
  arch/x86/include/asm/intel_ds.h \
  arch/x86/include/asm/pgtable_areas.h \
  arch/x86/include/asm/pgtable_32_areas.h \
  include/uapi/linux/elf.h \
  include/uapi/linux/elf-em.h \
  include/linux/kobject.h \
    $(wildcard include/config/UEVENT_HELPER) \
    $(wildcard include/config/DEBUG_KOBJECT_RELEASE) \
  include/linux/sysfs.h \
  include/linux/kernfs.h \
    $(wildcard include/config/KERNFS) \
  include/linux/idr.h \
  include/linux/radix-tree.h \
  include/linux/xarray.h \
    $(wildcard include/config/XARRAY_MULTI) \
  include/linux/kconfig.h \
  include/linux/kobject_ns.h \
  include/linux/moduleparam.h \
    $(wildcard include/config/ALPHA) \
    $(wildcard include/config/IA64) \
    $(wildcard include/config/PPC64) \
  include/linux/rbtree_latch.h \
  include/linux/error-injection.h \
  include/asm-generic/error-injection.h \
  include/linux/cfi.h \
    $(wildcard include/config/CFI_CLANG_SHADOW) \
  arch/x86/include/asm/module.h \
    $(wildcard include/config/UNWINDER_ORC) \
  include/asm-generic/module.h \
    $(wildcard include/config/HAVE_MOD_ARCH_SPECIFIC) \
    $(wildcard include/config/MODULES_USE_ELF_REL) \
    $(wildcard include/config/MODULES_USE_ELF_RELA) \
  arch/x86/include/asm/orc_types.h \
  include/linux/slab.h \
    $(wildcard include/config/DEBUG_SLAB) \
    $(wildcard include/config/FAILSLAB) \
    $(wildcard include/config/MEMCG_KMEM) \
    $(wildcard include/config/KASAN) \
    $(wildcard include/config/SLAB) \
    $(wildcard include/config/SLUB) \
    $(wildcard include/config/SLOB) \
  include/linux/overflow.h \
  include/linux/percpu-refcount.h \
  include/linux/kasan.h \
    $(wildcard include/config/KASAN_STACK) \
    $(wildcard include/config/KASAN_VMALLOC) \
    $(wildcard include/config/KASAN_INLINE) \
  include/linux/kasan-enabled.h \
  include/linux/uaccess.h \
  include/linux/fault-inject-usercopy.h \
    $(wildcard include/config/FAULT_INJECTION_USERCOPY) \
  include/linux/sched.h \
    $(wildcard include/config/VIRT_CPU_ACCOUNTING_NATIVE) \
    $(wildcard include/config/SCHED_INFO) \
    $(wildcard include/config/SCHEDSTATS) \
    $(wildcard include/config/SCHED_CORE) \
    $(wildcard include/config/FAIR_GROUP_SCHED) \
    $(wildcard include/config/RT_GROUP_SCHED) \
    $(wildcard include/config/RT_MUTEXES) \
    $(wildcard include/config/UCLAMP_TASK) \
    $(wildcard include/config/UCLAMP_BUCKETS_COUNT) \
    $(wildcard include/config/CGROUP_SCHED) \
    $(wildcard include/config/BLK_DEV_IO_TRACE) \
    $(wildcard include/config/PSI) \
    $(wildcard include/config/COMPAT_BRK) \
    $(wildcard include/config/CGROUPS) \
    $(wildcard include/config/BLK_CGROUP) \
    $(wildcard include/config/PAGE_OWNER) \
    $(wildcard include/config/EVENTFD) \
    $(wildcard include/config/ARCH_HAS_SCALED_CPUTIME) \
    $(wildcard include/config/VIRT_CPU_ACCOUNTING_GEN) \
    $(wildcard include/config/POSIX_CPUTIMERS) \
    $(wildcard include/config/POSIX_CPU_TIMERS_TASK_WORK) \
    $(wildcard include/config/KEYS) \
    $(wildcard include/config/SYSVIPC) \
    $(wildcard include/config/DETECT_HUNG_TASK) \
    $(wildcard include/config/IO_URING) \
    $(wildcard include/config/AUDIT) \
    $(wildcard include/config/AUDITSYSCALL) \
    $(wildcard include/config/UBSAN) \
    $(wildcard include/config/UBSAN_TRAP) \
    $(wildcard include/config/TASK_XACCT) \
    $(wildcard include/config/CPUSETS) \
    $(wildcard include/config/X86_CPU_RESCTRL) \
    $(wildcard include/config/FUTEX) \
    $(wildcard include/config/PERF_EVENTS) \
    $(wildcard include/config/RSEQ) \
    $(wildcard include/config/TASK_DELAY_ACCT) \
    $(wildcard include/config/FAULT_INJECTION) \
    $(wildcard include/config/LATENCYTOP) \
    $(wildcard include/config/KUNIT) \
    $(wildcard include/config/FUNCTION_GRAPH_TRACER) \
    $(wildcard include/config/BCACHE) \
    $(wildcard include/config/VMAP_STACK) \
    $(wildcard include/config/SECURITY) \
    $(wildcard include/config/BPF_SYSCALL) \
    $(wildcard include/config/GCC_PLUGIN_STACKLEAK) \
    $(wildcard include/config/X86_MCE) \
    $(wildcard include/config/KRETPROBES) \
    $(wildcard include/config/RETHOOK) \
    $(wildcard include/config/ARCH_HAS_PARANOID_L1D_FLUSH) \
    $(wildcard include/config/ARCH_TASK_STRUCT_ON_STACK) \
    $(wildcard include/config/DEBUG_RSEQ) \
  include/uapi/linux/sched.h \
  include/linux/pid.h \
  include/linux/rculist.h \
    $(wildcard include/config/PROVE_RCU_LIST) \
  include/linux/sem.h \
  include/uapi/linux/sem.h \
  include/linux/ipc.h \
  include/linux/rhashtable-types.h \
  include/uapi/linux/ipc.h \
  arch/x86/include/generated/uapi/asm/ipcbuf.h \
  include/uapi/asm-generic/ipcbuf.h \
  arch/x86/include/uapi/asm/sembuf.h \
  include/linux/shm.h \
  include/uapi/linux/shm.h \
  include/uapi/asm-generic/hugetlb_encode.h \
  arch/x86/include/uapi/asm/shmbuf.h \
  include/uapi/asm-generic/shmbuf.h \
  arch/x86/include/asm/shmparam.h \
  include/linux/plist.h \
    $(wildcard include/config/DEBUG_PLIST) \
  include/linux/hrtimer.h \
    $(wildcard include/config/HIGH_RES_TIMERS) \
    $(wildcard include/config/TIME_LOW_RES) \
    $(wildcard include/config/TIMERFD) \
  include/linux/hrtimer_defs.h \
  include/linux/timerqueue.h \
  include/linux/seccomp.h \
    $(wildcard include/config/SECCOMP) \
    $(wildcard include/config/HAVE_ARCH_SECCOMP_FILTER) \
    $(wildcard include/config/SECCOMP_FILTER) \
    $(wildcard include/config/CHECKPOINT_RESTORE) \
    $(wildcard include/config/SECCOMP_CACHE_DEBUG) \
  include/uapi/linux/seccomp.h \
  arch/x86/include/asm/seccomp.h \
  arch/x86/include/asm/unistd.h \
  arch/x86/include/uapi/asm/unistd.h \
  arch/x86/include/generated/uapi/asm/unistd_32.h \
  include/asm-generic/seccomp.h \
  include/uapi/linux/unistd.h \
  include/linux/resource.h \
  include/uapi/linux/resource.h \
  arch/x86/include/generated/uapi/asm/resource.h \
  include/asm-generic/resource.h \
  include/uapi/asm-generic/resource.h \
  include/linux/latencytop.h \
  include/linux/sched/prio.h \
  include/linux/sched/types.h \
  include/linux/signal_types.h \
    $(wildcard include/config/OLD_SIGACTION) \
  include/uapi/linux/signal.h \
  arch/x86/include/asm/signal.h \
  arch/x86/include/uapi/asm/signal.h \
  include/uapi/asm-generic/signal-defs.h \
  arch/x86/include/uapi/asm/siginfo.h \
  include/uapi/asm-generic/siginfo.h \
  include/linux/syscall_user_dispatch.h \
  include/linux/task_io_accounting.h \
    $(wildcard include/config/TASK_IO_ACCOUNTING) \
  include/linux/posix-timers.h \
  include/linux/alarmtimer.h \
    $(wildcard include/config/RTC_CLASS) \
  include/uapi/linux/rseq.h \
  include/linux/kcsan.h \
  arch/x86/include/asm/uaccess.h \
    $(wildcard include/config/CC_HAS_ASM_GOTO_OUTPUT) \
    $(wildcard include/config/CC_HAS_ASM_GOTO_TIED_OUTPUT) \
    $(wildcard include/config/ARCH_HAS_COPY_MC) \
    $(wildcard include/config/X86_INTEL_USERCOPY) \
  arch/x86/include/asm/smap.h \
  arch/x86/include/asm/extable.h \
    $(wildcard include/config/BPF_JIT) \
  include/asm-generic/access_ok.h \
    $(wildcard include/config/ALTERNATE_USER_ADDRESS_SPACE) \
  arch/x86/include/asm/uaccess_32.h \
  include/linux/i2c.h \
    $(wildcard include/config/I2C) \
    $(wildcard include/config/I2C_SLAVE) \
    $(wildcard include/config/I2C_BOARDINFO) \
    $(wildcard include/config/I2C_MUX) \
    $(wildcard include/config/OF) \
    $(wildcard include/config/ACPI) \
  include/linux/acpi.h \
    $(wildcard include/config/ACPI_DEBUGGER) \
    $(wildcard include/config/ACPI_TABLE_LIB) \
    $(wildcard include/config/LOONGARCH) \
    $(wildcard include/config/ARM64) \
    $(wildcard include/config/ACPI_PROCESSOR_CSTATE) \
    $(wildcard include/config/ACPI_HOTPLUG_CPU) \
    $(wildcard include/config/ACPI_HOTPLUG_IOAPIC) \
    $(wildcard include/config/PCI) \
    $(wildcard include/config/ACPI_WMI) \
    $(wildcard include/config/ACPI_NUMA) \
    $(wildcard include/config/HIBERNATION) \
    $(wildcard include/config/ACPI_HOTPLUG_MEMORY) \
    $(wildcard include/config/ACPI_CONTAINER) \
    $(wildcard include/config/ACPI_GTDT) \
    $(wildcard include/config/PM) \
    $(wildcard include/config/GPIOLIB) \
    $(wildcard include/config/ACPI_TABLE_UPGRADE) \
    $(wildcard include/config/ACPI_WATCHDOG) \
    $(wildcard include/config/ACPI_SPCR_TABLE) \
    $(wildcard include/config/ACPI_GENERIC_GSI) \
    $(wildcard include/config/ACPI_LPIT) \
    $(wildcard include/config/ACPI_PPTT) \
    $(wildcard include/config/ACPI_PCC) \
  include/linux/ioport.h \
  include/linux/irqdomain.h \
    $(wildcard include/config/IRQ_DOMAIN_HIERARCHY) \
    $(wildcard include/config/GENERIC_IRQ_DEBUGFS) \
    $(wildcard include/config/IRQ_DOMAIN) \
    $(wildcard include/config/IRQ_DOMAIN_NOMAP) \
  include/linux/irqhandler.h \
  include/linux/of.h \
    $(wildcard include/config/OF_DYNAMIC) \
    $(wildcard include/config/SPARC) \
    $(wildcard include/config/OF_PROMTREE) \
    $(wildcard include/config/OF_KOBJ) \
    $(wildcard include/config/OF_NUMA) \
    $(wildcard include/config/OF_OVERLAY) \
  include/linux/mod_devicetable.h \
  include/linux/uuid.h \
  include/uapi/linux/uuid.h \
  include/linux/property.h \
  include/linux/fwnode.h \
  include/linux/resource_ext.h \
  include/linux/device.h \
    $(wildcard include/config/GENERIC_MSI_IRQ_DOMAIN) \
    $(wildcard include/config/GENERIC_MSI_IRQ) \
    $(wildcard include/config/ENERGY_MODEL) \
    $(wildcard include/config/PINCTRL) \
    $(wildcard include/config/DMA_OPS) \
    $(wildcard include/config/DMA_DECLARE_COHERENT) \
    $(wildcard include/config/DMA_CMA) \
    $(wildcard include/config/SWIOTLB) \
    $(wildcard include/config/ARCH_HAS_SYNC_DMA_FOR_DEVICE) \
    $(wildcard include/config/ARCH_HAS_SYNC_DMA_FOR_CPU) \
    $(wildcard include/config/ARCH_HAS_SYNC_DMA_FOR_CPU_ALL) \
    $(wildcard include/config/DMA_OPS_BYPASS) \
    $(wildcard include/config/DEVTMPFS) \
    $(wildcard include/config/SYSFS_DEPRECATED) \
  include/linux/dev_printk.h \
  include/linux/ratelimit.h \
  include/linux/energy_model.h \
  include/linux/sched/cpufreq.h \
    $(wildcard include/config/CPU_FREQ) \
  include/linux/sched/topology.h \
    $(wildcard include/config/SCHED_DEBUG) \
    $(wildcard include/config/SCHED_MC) \
    $(wildcard include/config/CPU_FREQ_GOV_SCHEDUTIL) \
  include/linux/sched/idle.h \
  include/linux/sched/sd_flags.h \
  include/linux/klist.h \
  include/linux/pm.h \
    $(wildcard include/config/VT_CONSOLE_SLEEP) \
    $(wildcard include/config/PM_CLK) \
    $(wildcard include/config/PM_GENERIC_DOMAINS) \
  include/linux/device/bus.h \
  include/linux/device/class.h \
  include/linux/device/driver.h \
  arch/x86/include/asm/device.h \
  include/linux/pm_wakeup.h \
  include/acpi/acpi.h \
  include/acpi/platform/acenv.h \
  include/acpi/platform/acgcc.h \
  include/acpi/platform/aclinux.h \
    $(wildcard include/config/ACPI_REDUCED_HARDWARE_ONLY) \
    $(wildcard include/config/ACPI_DEBUG) \
  include/linux/ctype.h \
  arch/x86/include/asm/acenv.h \
  include/acpi/acnames.h \
  include/acpi/actypes.h \
  include/acpi/acexcep.h \
  include/acpi/actbl.h \
  include/acpi/actbl1.h \
  include/acpi/actbl2.h \
  include/acpi/actbl3.h \
  include/acpi/acrestyp.h \
  include/acpi/platform/acenvex.h \
  include/acpi/platform/aclinuxex.h \
  include/acpi/platform/acgccex.h \
  include/acpi/acoutput.h \
  include/acpi/acpiosxf.h \
  include/acpi/acpixf.h \
  include/acpi/acconfig.h \
  include/acpi/acbuffer.h \
  include/linux/dynamic_debug.h \
  include/acpi/acpi_bus.h \
    $(wildcard include/config/X86_ANDROID_TABLETS) \
    $(wildcard include/config/ACPI_SYSTEM_POWER_STATES_SUPPORT) \
    $(wildcard include/config/ACPI_SLEEP) \
  include/acpi/acpi_drivers.h \
    $(wildcard include/config/ACPI_DOCK) \
  include/acpi/acpi_numa.h \
    $(wildcard include/config/ACPI_HMAT) \
  include/acpi/acpi_io.h \
  include/linux/io.h \
    $(wildcard include/config/HAS_IOPORT_MAP) \
  arch/x86/include/asm/io.h \
    $(wildcard include/config/MTRR) \
    $(wildcard include/config/X86_PAT) \
  arch/x86/include/generated/asm/early_ioremap.h \
  include/asm-generic/early_ioremap.h \
    $(wildcard include/config/GENERIC_EARLY_IOREMAP) \
  include/asm-generic/iomap.h \
  include/asm-generic/pci_iomap.h \
    $(wildcard include/config/NO_GENERIC_PCI_IOPORT_MAP) \
    $(wildcard include/config/GENERIC_PCI_IOMAP) \
  include/asm-generic/io.h \
    $(wildcard include/config/GENERIC_IOMAP) \
    $(wildcard include/config/GENERIC_IOREMAP) \
    $(wildcard include/config/VIRT_TO_BUS) \
    $(wildcard include/config/GENERIC_DEVMEM_IS_ALLOWED) \
  include/linux/logic_pio.h \
    $(wildcard include/config/INDIRECT_PIO) \
  include/linux/vmalloc.h \
    $(wildcard include/config/HAVE_ARCH_HUGE_VMALLOC) \
  arch/x86/include/asm/vmalloc.h \
    $(wildcard include/config/HAVE_ARCH_HUGE_VMAP) \
  arch/x86/include/asm/acpi.h \
    $(wildcard include/config/ACPI_APEI) \
  include/acpi/pdc_intel.h \
  arch/x86/include/asm/numa.h \
    $(wildcard include/config/NUMA_EMU) \
  arch/x86/include/asm/numa_32.h \
  include/linux/regulator/consumer.h \
    $(wildcard include/config/REGULATOR) \
  include/linux/suspend.h \
    $(wildcard include/config/VT) \
    $(wildcard include/config/SUSPEND) \
    $(wildcard include/config/HIBERNATION_SNAPSHOT_DEV) \
    $(wildcard include/config/PM_SLEEP_DEBUG) \
    $(wildcard include/config/PM_AUTOSLEEP) \
  include/linux/swap.h \
    $(wildcard include/config/DEVICE_PRIVATE) \
    $(wildcard include/config/MIGRATION) \
    $(wildcard include/config/FRONTSWAP) \
    $(wildcard include/config/THP_SWAP) \
    $(wildcard include/config/MEMCG_SWAP) \
  include/linux/memcontrol.h \
    $(wildcard include/config/CGROUP_WRITEBACK) \
  include/linux/cgroup.h \
    $(wildcard include/config/CGROUP_CPUACCT) \
    $(wildcard include/config/SOCK_CGROUP_DATA) \
    $(wildcard include/config/CGROUP_DATA) \
    $(wildcard include/config/CGROUP_BPF) \
  include/uapi/linux/cgroupstats.h \
  include/uapi/linux/taskstats.h \
  include/linux/fs.h \
    $(wildcard include/config/READ_ONLY_THP_FOR_FS) \
    $(wildcard include/config/FS_POSIX_ACL) \
    $(wildcard include/config/IMA) \
    $(wildcard include/config/FILE_LOCKING) \
    $(wildcard include/config/FSNOTIFY) \
    $(wildcard include/config/FS_ENCRYPTION) \
    $(wildcard include/config/FS_VERITY) \
    $(wildcard include/config/EPOLL) \
    $(wildcard include/config/UNICODE) \
    $(wildcard include/config/QUOTA) \
    $(wildcard include/config/FS_DAX) \
    $(wildcard include/config/BLOCK) \
  include/linux/wait_bit.h \
  include/linux/kdev_t.h \
  include/uapi/linux/kdev_t.h \
  include/linux/dcache.h \
  include/linux/rculist_bl.h \
  include/linux/list_bl.h \
  include/linux/bit_spinlock.h \
  include/linux/lockref.h \
    $(wildcard include/config/ARCH_USE_CMPXCHG_LOCKREF) \
  include/linux/stringhash.h \
    $(wildcard include/config/DCACHE_WORD_ACCESS) \
  include/linux/hash.h \
    $(wildcard include/config/HAVE_ARCH_HASH) \
  include/linux/path.h \
  include/linux/list_lru.h \
  include/linux/shrinker.h \
  include/linux/capability.h \
  include/uapi/linux/capability.h \
  include/linux/semaphore.h \
  include/linux/fcntl.h \
    $(wildcard include/config/ARCH_32BIT_OFF_T) \
  include/uapi/linux/fcntl.h \
  arch/x86/include/generated/uapi/asm/fcntl.h \
  include/uapi/asm-generic/fcntl.h \
  include/uapi/linux/openat2.h \
  include/linux/migrate_mode.h \
  include/linux/percpu-rwsem.h \
  include/linux/rcuwait.h \
  include/linux/sched/signal.h \
    $(wildcard include/config/SCHED_AUTOGROUP) \
    $(wildcard include/config/BSD_PROCESS_ACCT) \
    $(wildcard include/config/TASKSTATS) \
    $(wildcard include/config/STACK_GROWSUP) \
  include/linux/signal.h \
    $(wildcard include/config/DYNAMIC_SIGFRAME) \
  include/linux/sched/jobctl.h \
  include/linux/sched/task.h \
    $(wildcard include/config/HAVE_EXIT_THREAD) \
    $(wildcard include/config/ARCH_WANTS_DYNAMIC_TASK_STRUCT) \
    $(wildcard include/config/HAVE_ARCH_THREAD_STRUCT_WHITELIST) \
  include/linux/cred.h \
    $(wildcard include/config/DEBUG_CREDENTIALS) \
  include/linux/key.h \
    $(wildcard include/config/KEY_NOTIFICATIONS) \
    $(wildcard include/config/NET) \
  include/linux/assoc_array.h \
    $(wildcard include/config/ASSOCIATIVE_ARRAY) \
  include/linux/sched/user.h \
    $(wildcard include/config/WATCH_QUEUE) \
  include/linux/percpu_counter.h \
  include/linux/rcu_sync.h \
  include/linux/delayed_call.h \
  include/linux/errseq.h \
  include/linux/ioprio.h \
  include/linux/sched/rt.h \
  include/linux/iocontext.h \
    $(wildcard include/config/BLK_ICQ) \
  include/uapi/linux/ioprio.h \
  include/linux/fs_types.h \
  include/linux/mount.h \
  include/linux/mnt_idmapping.h \
  include/uapi/linux/fs.h \
  include/linux/quota.h \
    $(wildcard include/config/QUOTA_NETLINK_INTERFACE) \
  include/uapi/linux/dqblk_xfs.h \
  include/linux/dqblk_v1.h \
  include/linux/dqblk_v2.h \
  include/linux/dqblk_qtree.h \
  include/linux/projid.h \
  include/uapi/linux/quota.h \
  include/linux/nfs_fs_i.h \
  include/linux/seq_file.h \
  include/linux/string_helpers.h \
  include/linux/ns_common.h \
  include/linux/nsproxy.h \
  include/linux/user_namespace.h \
    $(wildcard include/config/INOTIFY_USER) \
    $(wildcard include/config/FANOTIFY) \
    $(wildcard include/config/PERSISTENT_KEYRINGS) \
  include/linux/kernel_stat.h \
  include/linux/interrupt.h \
    $(wildcard include/config/IRQ_FORCED_THREADING) \
    $(wildcard include/config/GENERIC_IRQ_PROBE) \
    $(wildcard include/config/IRQ_TIMINGS) \
  include/linux/irqreturn.h \
  include/linux/irqnr.h \
  include/uapi/linux/irqnr.h \
  include/linux/hardirq.h \
  include/linux/context_tracking_state.h \
    $(wildcard include/config/CONTEXT_TRACKING) \
  include/linux/ftrace_irq.h \
    $(wildcard include/config/HWLAT_TRACER) \
    $(wildcard include/config/OSNOISE_TRACER) \
  include/linux/vtime.h \
    $(wildcard include/config/VIRT_CPU_ACCOUNTING) \
    $(wildcard include/config/IRQ_TIME_ACCOUNTING) \
  arch/x86/include/asm/hardirq.h \
    $(wildcard include/config/KVM_INTEL) \
    $(wildcard include/config/X86_THERMAL_VECTOR) \
    $(wildcard include/config/X86_MCE_THRESHOLD) \
    $(wildcard include/config/X86_MCE_AMD) \
    $(wildcard include/config/X86_HV_CALLBACK_VECTOR) \
  arch/x86/include/asm/irq.h \
  arch/x86/include/asm/sections.h \
  include/asm-generic/sections.h \
    $(wildcard include/config/HAVE_FUNCTION_DESCRIPTORS) \
  include/linux/cgroup-defs.h \
    $(wildcard include/config/CGROUP_NET_CLASSID) \
    $(wildcard include/config/CGROUP_NET_PRIO) \
  include/linux/u64_stats_sync.h \
  include/linux/bpf-cgroup-defs.h \
  include/linux/psi_types.h \
  include/linux/kthread.h \
  include/linux/cgroup_subsys.h \
    $(wildcard include/config/CGROUP_DEVICE) \
    $(wildcard include/config/CGROUP_FREEZER) \
    $(wildcard include/config/CGROUP_PERF) \
    $(wildcard include/config/CGROUP_HUGETLB) \
    $(wildcard include/config/CGROUP_PIDS) \
    $(wildcard include/config/CGROUP_RDMA) \
    $(wildcard include/config/CGROUP_MISC) \
    $(wildcard include/config/CGROUP_DEBUG) \
  include/linux/vm_event_item.h \
    $(wildcard include/config/HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD) \
    $(wildcard include/config/MEMORY_BALLOON) \
    $(wildcard include/config/BALLOON_COMPACTION) \
    $(wildcard include/config/DEBUG_TLBFLUSH) \
    $(wildcard include/config/DEBUG_VM_VMACACHE) \
  include/linux/page_counter.h \
  include/linux/vmpressure.h \
  include/linux/eventfd.h \
  include/linux/mm.h \
    $(wildcard include/config/HAVE_ARCH_MMAP_RND_BITS) \
    $(wildcard include/config/HAVE_ARCH_MMAP_RND_COMPAT_BITS) \
    $(wildcard include/config/ARCH_USES_HIGH_VMA_FLAGS) \
    $(wildcard include/config/ARCH_HAS_PKEYS) \
    $(wildcard include/config/PPC) \
    $(wildcard include/config/PARISC) \
    $(wildcard include/config/SPARC64) \
    $(wildcard include/config/ARM64_MTE) \
    $(wildcard include/config/HAVE_ARCH_USERFAULTFD_MINOR) \
    $(wildcard include/config/SHMEM) \
    $(wildcard include/config/ARCH_HAS_PTE_SPECIAL) \
    $(wildcard include/config/ARCH_HAS_PTE_DEVMAP) \
    $(wildcard include/config/DEBUG_VM_RB) \
    $(wildcard include/config/PAGE_POISONING) \
    $(wildcard include/config/INIT_ON_ALLOC_DEFAULT_ON) \
    $(wildcard include/config/INIT_ON_FREE_DEFAULT_ON) \
    $(wildcard include/config/DEBUG_PAGEALLOC) \
    $(wildcard include/config/HUGETLBFS) \
    $(wildcard include/config/MAPPING_DIRTY_HELPERS) \
    $(wildcard include/config/ANON_VMA_NAME) \
  include/linux/mmap_lock.h \
  include/linux/page_ext.h \
  include/linux/stacktrace.h \
    $(wildcard include/config/ARCH_STACKWALK) \
    $(wildcard include/config/STACKTRACE) \
    $(wildcard include/config/HAVE_RELIABLE_STACKTRACE) \
  include/linux/stackdepot.h \
    $(wildcard include/config/STACKDEPOT_ALWAYS_INIT) \
  include/linux/page_ref.h \
    $(wildcard include/config/DEBUG_PAGE_REF) \
  include/linux/sizes.h \
  include/linux/pgtable.h \
    $(wildcard include/config/HIGHPTE) \
    $(wildcard include/config/GUP_GET_PTE_LOW_HIGH) \
    $(wildcard include/config/HAVE_ARCH_SOFT_DIRTY) \
    $(wildcard include/config/ARCH_ENABLE_THP_MIGRATION) \
    $(wildcard include/config/X86_ESPFIX64) \
  arch/x86/include/asm/pgtable.h \
    $(wildcard include/config/DEBUG_WX) \
    $(wildcard include/config/PAGE_TABLE_CHECK) \
  arch/x86/include/asm/pkru.h \
  arch/x86/include/asm/fpu/api.h \
    $(wildcard include/config/X86_DEBUG_FPU) \
  arch/x86/include/asm/coco.h \
  include/asm-generic/pgtable_uffd.h \
  include/linux/page_table_check.h \
  arch/x86/include/asm/pgtable_32.h \
  arch/x86/include/asm/pgtable-3level.h \
  arch/x86/include/asm/pgtable-invert.h \
  include/linux/huge_mm.h \
  include/linux/sched/coredump.h \
    $(wildcard include/config/CORE_DUMP_DEFAULT_ELF_HEADERS) \
  include/linux/vmstat.h \
    $(wildcard include/config/VM_EVENT_COUNTERS) \
  include/linux/writeback.h \
  include/linux/flex_proportions.h \
  include/linux/backing-dev-defs.h \
    $(wildcard include/config/DEBUG_FS) \
  include/linux/blk_types.h \
    $(wildcard include/config/FAIL_MAKE_REQUEST) \
    $(wildcard include/config/BLK_CGROUP_IOCOST) \
    $(wildcard include/config/BLK_INLINE_ENCRYPTION) \
    $(wildcard include/config/BLK_DEV_INTEGRITY) \
  include/linux/bvec.h \
  include/linux/highmem.h \
  include/linux/cacheflush.h \
  arch/x86/include/asm/cacheflush.h \
  include/asm-generic/cacheflush.h \
  include/linux/highmem-internal.h \
  arch/x86/include/asm/highmem.h \
  arch/x86/include/asm/tlbflush.h \
  arch/x86/include/asm/invpcid.h \
  arch/x86/include/asm/pti.h \
  include/linux/bio.h \
  include/linux/mempool.h \
  include/linux/uio.h \
    $(wildcard include/config/ARCH_HAS_UACCESS_FLUSHCACHE) \
  include/uapi/linux/uio.h \
  include/linux/node.h \
    $(wildcard include/config/HMEM_REPORTING) \
  include/linux/pagemap.h \
  include/linux/hugetlb_inline.h \
  include/uapi/linux/mempolicy.h \
  include/linux/freezer.h \
  include/uapi/linux/i2c.h \
  include/linux/videodev2.h \
  include/uapi/linux/videodev2.h \
    $(wildcard include/config/VIDEO_ADV_DEBUG) \
  include/uapi/linux/v4l2-common.h \
  include/uapi/linux/v4l2-controls.h \
  include/media/v4l2-device.h \
    $(wildcard include/config/VIDEO_V4L2_SUBDEV_API) \
  include/media/media-device.h \
    $(wildcard include/config/MEDIA_CONTROLLER) \
  include/media/media-devnode.h \
  include/linux/poll.h \
  include/uapi/linux/poll.h \
  arch/x86/include/generated/uapi/asm/poll.h \
  include/uapi/asm-generic/poll.h \
  include/uapi/linux/eventpoll.h \
  include/linux/cdev.h \
  include/media/media-entity.h \
  include/uapi/linux/media.h \
  include/media/v4l2-subdev.h \
  include/uapi/linux/v4l2-subdev.h \
  include/uapi/linux/v4l2-mediabus.h \
  include/uapi/linux/media-bus-format.h \
  include/media/v4l2-async.h \
  include/media/v4l2-common.h \
    $(wildcard include/config/VIDEO_V4L2_I2C) \
    $(wildcard include/config/SPI) \
  include/media/v4l2-dev.h \
  include/linux/spi/spi.h \
    $(wildcard include/config/SPI_SLAVE) \
  include/linux/scatterlist.h \
    $(wildcard include/config/NEED_SG_DMA_LENGTH) \
    $(wildcard include/config/DEBUG_SG) \
    $(wildcard include/config/SGL_ALLOC) \
    $(wildcard include/config/ARCH_NO_SG_CHAIN) \
    $(wildcard include/config/SG_POOL) \
  include/linux/gpio/consumer.h \
    $(wildcard include/config/OF_GPIO) \
    $(wildcard include/config/GPIO_SYSFS) \
  include/uapi/linux/spi/spi.h \
  include/media/v4l2-fh.h \
  include/media/v4l2-mediabus.h \

drivers/media/i2c/vp27smpx.o: $(deps_drivers/media/i2c/vp27smpx.o)

$(deps_drivers/media/i2c/vp27smpx.o):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     free cgroup_mutex mutex_lock mutex_unlock system_wq queue_work_on seq_printf __stack_chk_guard bpf_stats_enabled_key __x86_indirect_thunk_ecx sched_clock __x86_indirect_thunk_esi debug_smp_processor_id __per_cpu_offset __stack_chk_fail bpf_sysctl_set_new_value memcpy memset bpf_sysctl_get_current_value bpf_sysctl_get_new_value migrate_disable __rcu_read_lock __rcu_read_unlock migrate_enable strscpy strnlen fortify_panic bpf_sysctl_get_name bpf_ktime_get_coarse_ns_proto bpf_strtol_proto bpf_get_current_cgroup_id_proto bpf_get_current_uid_gid_proto bpf_base_func_proto bpf_strtoul_proto bpf_event_output_data_proto bpf_get_local_storage_proto __kmalloc css_next_descendant_pre percpu_ref_is_zero bpf_prog_put __x86_indirect_thunk_ebx bpf_prog_array_alloc bpf_prog_array_free static_key_slow_dec __x86_indirect_thunk_edx bpf_tcp_sock_proto bpf_sk_setsockopt_proto bpf_sk_storage_delete_proto bpf_sk_getsockopt_proto bpf_sk_storage_get_proto bpf_cgroup_storage_unlink bpf_cgroup_storage_free percpu_ref_exit cgroup_storage_lookup bpf_cgroup_storage_link kmalloc_caches kmem_cache_alloc_trace static_key_slow_inc bpf_cgroup_storage_alloc cgroup_bpf_offline percpu_ref_kill_and_confirm cgroup_bpf_inherit percpu_ref_init cgroup_bpf_prog_attach cgroup_get_from_fd bpf_prog_get_type_dev cgroup_bpf_prog_detach cgroup_bpf_link_attach bpf_link_init bpf_link_prime bpf_link_settle bpf_link_cleanup cgroup_bpf_prog_query bpf_prog_array_length bpf_prog_array_copy_to_user __cgroup_bpf_check_dev_permission __cgroup_bpf_run_filter_sysctl __kmalloc_track_caller __x86_indirect_thunk_edi __cgroup_bpf_run_filter_setsockopt __check_object_size _copy_from_user lock_sock_nested release_sock __cgroup_bpf_run_filter_getsockopt __get_user_4 __put_user_4 __cgroup_bpf_run_filter_getsockopt_kern cg_sockopt_prog_ops cg_sockopt_verifier_ops cg_sysctl_prog_ops cg_sysctl_verifier_ops cg_dev_verifier_ops cg_dev_prog_ops      F     G  !   F  *   G  A   F  ρ  F    J  1  F  Q  F  a  F  q  F  {  L  ƒ  M  ›  L     N  Ρ  F  κ  O  ρ      F    L    M  +  L  0  N  :    @  Q  m  R    T  ¦  R  Α  U    V  ά  W  γ  X  ψ  U  ΅  Y  ±  F  	  [  A  F  j  [    \  §  \  Α  F  ρ  F  	  \  a	  F  x	  R  
  _  
  `  %
  G  m
  G  x
  a  }
  b  ΄
  R  
  _    `    G  g  G  r  a  w  b  ³  Y  Α  F  ν  c  	      d  7    <  c    F  —  R  Ό  c  Ο  R    Y  !  F  ‘  F  !  F  !  F  :  :  V  g  b  h  z  :  ‰  :    i  ©  j  Α  l  Ρ  :  α  :  ρ  :    m    n  !  F  b  o  ΅  F  °  L  Έ  M  ζ  :  N  p  v  p  ‹  q  ¶  L  »  N  1  p  F  r  q  F  ‡  R  ΅  _  ¦  `  ―  G  β  T    G    a    b  -  R  A  U  R  V  \  W  c  X  x  U  Ά  Y  ±  F  ΐ  R  ή  _  γ  `  μ  G  "  T  N  G  Y  a  ^  b  m  R    U  ’  V    W  £  X  Έ  U  β  Y  ρ  F  
  R  p  _  u  `  ~  G  ΄  T  ε  G  π  a  υ  b    R  !  U  4  s  >  W  E  X  Z  U    Y  ±  F  Β  i  ί  :  ρ  j    :    m  !  n  1  F  Λ  t  q  F  ‚  p  —  q  ½  p    p  ο  p     q    u  *  p  E  p  W  u  j  p    F  ¥  :  Ί  K  Σ  r  ά  @  α  v    F    L    M  F  L  K  N  a  `  ‚  L  «  w  Α  F  α  F    F    x  3  :  J  y  a  z  u  {  —  :  ­  i  »  j  Ρ  |  α  :  ρ  m    n    F    @  /  L  4  M  l  K  s  v    r  Έ  `  Υ  a  ν  u  ό  @  #  }  ,  ~  >  L  C  N  V  `  h  a  {      T  ·  `  τ  w  !  w  1  F  M  R  Τ  :  Ή!  €  τ!  R  ‰"  r  "    ¬"    ¶"  ‚  Ε"  ƒ  *#  @  /#  „  E#  …  ‹#  ~  ”#  ~  ά#  ~  ε#  ~  $  K   $  ~  )$  ~  =$  Y  Q$  F  q$  `  €$  a  ±$  F  Ό$    Κ$  R  λ$  ‰  %  `  %  a  v%  u  †%  `  %  a  ¬%    ·%  R  ρ%  u  /&  w  9&  Y  A&  F  U&  ‹  t&  L  &  M  &  L  &  N  ΐ&    Ρ&  L  ά&  M  υ&  L  ϊ&  N  '  r  '  `  "'  a  Q'  `  `'  a  7ΌΔάg0idΐ?½ΥvJω¬‰E(Yν.¬θA”ΈqΌπd_(ρυD4:Fέ¤DηYΎ©zΈΞίΑ3ΕΥ ΗSκο‚»©ΩY*t—oι2…)lο.ώJa6ΩQxθ» !£°«­)R.qCNΌΧ]•t―οc8-KΕ&μΈoΗs™λ-aΆ†}6H/“οx¨9Ί,ΌΛΓυΘΙ­k››‰ϋ_oxΪ,w PU:όε$uωΝD™“‹Ιq5-°4ΪLή§Ιθ(Οΰαjj#Ν[οΣΝγƒH]½ƒ~8ά§E‹΄+Qφ+†"JƒY—p2rΈS²R¤½ZΥ[™Ό^…rώς½/όΟt Κ+]\!υ‹ψV²¤jFφ¶W~\θfδDυά|~`8Δέθ¦“¤ ςc}΅h‡‰Fρ½ ΪP2PπΉΉήCΝψ·β«­¥6uCώξ®gwΤ2“Ζ‹ρ%¬ν6T\{η§,ώΌwfνcw]ΜqΘ»ƒ“e½¥RmΦsτζ―„x€–Μ»ΥώΖηΫΓQΛ’U‘ςZRR RνΣΈ‘ϊνfEuz΄Έ―ζ*ΩΕγ—ί2ήqf]m9e-(”έk™Μά!h1αγΌΦ›9~U{•)0W©³¶»/Ε=51¤mο‹υ1άΒYΛuLρvύΐκ™e•zΧ†—ο‚x$ίϊvί‹(ηNoƒΟ	ΦθxmΐCς3GΆθ97lKqίΐΝΠHMεΤ9g“k!®ΐ[%CµιgΤ–XdCY#IΈ›1YΡφ5OeDTΪaK‹ΗήµΫTpϋKί®£εO[›η]“'όg9DΑΟ@ΰ@W"cd“”ν¬¨NΕR7αΎx›έXΝ)H¨ε…άΒ'€·–ip/
Ν•;…tO)®v0%Όώ?9* ύέlξπIXJ&φ¶–aΠ©KΓΠΛQZ@Σζά›h<_\XΰψΖXHΎςϊΔ¨ΣΙ¶ΰ•U­ΦΨ‡wρI›σ9O?  #‘δΨΎϋΤ&_3‹C°ώ(	Μή―yΙ§έ MN#)P(ΩOΤκΈΐυN™fq†‹Ώi/]&°]γa©g†WΒίitIΌΡ=©L΅¦½1¶νsWh
ζ%†{ΐLώRΈΩ-OC
΄®¶Q<vIθΫΊ/A½Φpήlοµ•Ω/)seή?P­PίΡpw2³gε-’·&΄³Wμ8fOύδ:μGc‹›ΙΥΐciLχΒ±h¦ΦS΅·¬‡3G7^{γPxγω&ύΠώvίiRHG—”F•==4i+E{ƒ²rΒS:~]ΞN7oυ¨ΡsΎΣt©jθΧqΫ”ξ].=a<GΞZΰώκ<yO2Q±Ά“άiΗD{Vο΄Vdp·bO§7ξΔ²~ΏΎ{™•y‹ςh‰ΖΝMPθGεΒω§rΝ]>£‚Σ5o¶h‡UΔ¶hχΰƒηwwxd-#XΨx‰ΣX®Φ¤²_ίmb'±'Έ,T°X¨γΟ12O―[τkQ¦λ’EL¥ )άcRύω¤Ύ
0\CήΘ”—SMwΐηLUΑΗmDΖσΙΰY9L‰‹ju…‚ΐι5I­χI£%Uφ$vΆΒ©"ύ,η,GΗ™΄αν~ _ΔyΙas.« Τ”Βέ8e¬¤Op¶AµΡέ£@\θqj†+e\Λ«hm¥ς)ά²κΌζ΅ήθ=›dΎ†?]5τx¤3™ΉG›¤Hψλ„ίDM{γΙ::	=7lΨu½u΅ςΠt0¦ό‘aν{†‘α ―ηD ¥΅ηΧΘΊ¥0g6•ϊ»Υφ(ΛΤόol
Λ8Ηd― —πΝWC―Πύ·…0ΜωλΝ­`VΎμrΨyδ7‹ϊ°Ύ}Π«@2ΌΨ©Γ3δ΄?ΟZ3α	ςμΨD(0wϊ°εχ?¶ΐuAwƒn,‡ύ²ά)–Z+k£σοz–ΦόψΓ.­¬ΖάNo2„7:Ήƒ:<ξυΏ‹Α²·NΟι&XΙ<Xc(^F{Β}…θF-
7θkN‚Λ~7=(eywΓ“΅€)‡†ε1ΟόΰάάKΛC0…ΌΌλFΙf`΅{ϊ4Ψ±ν[D6¬ΑT[¦u}/Μg€'–8Μ΅Ρ¬€(υn”σT[¬'σΪ~H&)zc0w]ΞοΏmoΟ ς~p)s.#µά'-™φ„Gωά™eUΆ~ΈδKυPYC;k{?`μ7ΫΥp£ας—|¨RηΣJώ6Bκz[°Ϊ0tν
`ό£έZO\/¥Δ4¦hΐΰeΠβζiΪΘ=&θή­‚µ`ΧΒ_σΤeB?Ύ„ΐdΡ{}]Ϋm¤³yΊP·ΓKcGφJ>›M®	a·,ΎΒ1όΒC9¦ ‡‰„G‡Rλωi?Γ_QΚRLA†‰η·’{πN_u2δυΔ²Όν2}1©πςc:FΘ
[Ιτ.x¬αΛ΄Sί®%'Oσ³θP•@qπ…†εΔM¬ΒΧ–ϋΙ0F\»™_΄D–£ ΊJ}τΎ5iv³=οπ>¤οDρ2έyνΎ|ςΔ®BτΈξτΆ)7K”€S«ROΌLΠχΒ5nD‰•¬ci΄¨ ΐ ώΡθΘ[Ί\-=FΧd—Ία`ΩΎ¨¬YΓύlι„Ό‡Κ®I2£δ²―Υ¥gm –›"4WΥ_CYZd€ΤO‚Ϊ¦¤―5Δ±χίwH—ΒS½ςΩ7Fq΄ΐΠΪ>οοε6 χ7)!{ΜF}(†.
.c+δYς¦Θ·=|–‘hn°’wΈΟz­΅‚nY6ϊdπίΜΜό[-π φ&Δpk_ƒ\¦¬”ECΘΥΓ/UσOΘ"ϊτΒhƒ0Ϊ#όϋS>T‰δΥ6_zύ*#ηΜN*†—ΒΠ…Ύb)JίTcqV­»b*Γ› εj“η‘Υ„δ1tBΓrΣ	xUl#WΎ²σ΄ςnΠ>‰™K·G,BdΏ^π¤$Ύ―‚Β?ΈA»Ζ¨Ί6¬Qϋ€<fl[_ΘΌƒpk«^83NτqΧkφΜvAΤΤύ(ε*ςsΙχςς“5.ίƒώ/Ng4ΕΘ–&²°Ώ―nΑ]·bpBΙΚμ’ΥGyΡ_Ώ‚dk8²†ϊ_d―υ_UΕYN·(iκα&ΡΥ3¤Βrwλ<Ξ"m$ΐάγ#ύ¬<£lεΏ¤FΗ"Ίa6ι»AΦλ―Έ\0ς’@‘Χ§Η…tML\ς…!Χ©y«'\ΰ
Ώev†%ο9}Γν8x€µ•†Bo—–Νε½]Ρ!“ηJήΰ
enφ2+|'"ϊD(lώ_­\re3eX}.¥,f¥#©‘7°6‰³IfY‚»LΤ=g€°ζRλQι2ΖζB«%Τ7¶l{ ―5CχV:ΌΥ((R¬ν3BevΤΠv%,Fa±Ήm½PB0gΑW^ϋϊϋGOD4ΉΟL`?ύ¨΄ϋώΦ>'λ›u™όoVI|½&$A—q=«§HzόΫ~ΊUEπ­ ‹EΆ»‚ΧDθ“Υ8ΎvFΐ”d§+9τ>(OB"χYdΥµDfyµQΆ§³e"N3Χ5 `YΠ—’2z‘"rεςw­Pόυ1βφt¥)‰vΖγ{K3²·Ω«
Bξ&P4z–ιjPαp‹Δsζlwϋς®sOΚΛ¨HU“o)>&²hmΈ“΅©fϋ—r"£t,-%$pΑ|SƒΞω
#β_όLYυϋΣU.ΨΙ[γιΫ®„ξ¦έvζ§©ώσ"³xb|σΞσ@πχπΤΚ+ς†φ3Y&K^]?‰5ό8]βς8^(K0Άp`tΚ¥β<φj8-imΘ²MηΏΜ£ι…κ‰XΚΘςΦy1Χ{)kIΫZYxFF>) eι¥=€¬z}A9,_T~Bο»Π5Iα€NΉKΌύ`όβ;%ΛΏΥλ5‹ίμ'1P+R·qaqχA9EW
G6‰ύ»¥ϋ~	΅C™TΥΓ=Kοe~ί‘u]ΗΗ?‰$£εi£ΙΔΰΧ5π4μδ‹»Ήσω*¦ωµ΄phΜ―9ΛΙόA~M…†ή”ΑF¤'υ5?ΒjSuFVΟb(EX%ώ%†εJπ„υξ‰ΝµΰQ‰ξIΥοWΎψ¶m ‚gΎ}eR!;¬υrgό‰QIΛΘ¶Ή(sΧΠγ_Α*HdNjΰ5ΔΗ,XιWΜ‚Sbσζ΅Ί|tF‡L_†;/f7£/Ω―Eε„`€!Qθ«‰παπδ®®xg]~³ )Ξ~=­[—Ι§!,—GjχΊµ¥dc”ΫΦ(Οπο’Οε:|V<Ιw«ΰPψ[Θί©*ύ1hm7%ΪΌ5αVBnO¨Αp&ί# $T`ρηΒWίg―/
-Ό‘h>ΑύmΗ‰‘ΦΆ)νE‹U#¬ήAmΆ„ή•6ΊζΡ#Y%
|#’Cϋ μΩρε—6¦}-Η΄ϋN<-o›Cε€qr&ΆύPΡςVVνqGV8σ)aΑψ,Ϋΐ›[,z•bήZΘοoOGφ(Ζia}Δg]\ΖwuΜ‰Ύ
`ύ·Nμ§φ”9¦@Ylµ£Ί?ξ·wEχΧ\τφoi2}—…ran-&δΓJ αQ]Υ	ήΎ#·η2έx@~z~Η‹,·η Ώ°Δy½ΑΝ,ΙβΡT0ϊβΊNµR¨P~‡βPκEίδ
ΖζƒςnF‰DlΞ!{°9ς"ιχύ/i™ΖhIΈk~Jυeύδ‡ΒdΤ†g!HΤΫΠ¦“RσπνY0¬¥#ώΜΘΜ-Θώχ
Y―(s=¥΄Z΅ρTξ}ςCs‹f§Ί‰DρTMκ ΙfCχ)M<§7»£Υ ^9άΨ―±oU‘τ plξήΏΒ{φτα›π†^…Ό%>:*—$χVΈ=ΒΗUΉ/uV[-–†Ξ•=©XΈDƒ5Z0ΫΈTν•ΚzΧ	cyN,I"cΣεk­	κ;€ζΪΑΚeµMς(@ΟDΨ‰ί›έ•/άΚ―+¦“°$ςλEψΗΣ*.]βγRξΟ2R«ηQΨA²	7—ΨχΑ`ρEC*jθB!"57h­ †fΈ³ruϊαokxΆΈ‚­‹CQήώr»¬k}Σ4bRΪΆ‘Θ©ψO*vψ©ζtάR΄\ζέΓ7	5π_e9Ξ―@†vΧ‚$m΅‡¶φ7·Ξ‘—oΑtΨ]κΊ	Rum¨!DήρF9 q>‚Ψ©ΐB…χW£ZiO βDU{ %­7Ώ¨T]‡-`ΌΚd0¤uλθ.A…c§α B®HΫΚ`S	Π‚3YiΨ¨oΎ­ΤΊmYι??β½«O*0µύϊΆ#Ή_ψγγ¦ύ«όtBϋΒb wΐ£ογΪ ΖδdΛΩBU!`FiεhΝ…Ωέ.Τ‘Lcµ¤qρ——χ)©β°nΡ.¤‹Α[ξ–‡ΑT?Zm―P·1Ρ]‹:I1ΫbAΘ¶‰ADPƒz—ϊ\¦Ά~Φz–¬Π³z?ΐV¨kπΈΨ>™½~;m3n¤Ψεδ½.c!!qγo9χ”LQϋφΘu¨V—+ZΗcY\²½Ψ(ƒ½ιqΔΆγs»X„I]doό½ΆY	r*ua#΅Φ\ζmχ­ΔKΘMΜ—ζ$k0/ƒΖα;ΝI‰λGd%όΟΧΛϋXήό!ΓPzΎτΉΤΈB·d¤B¦¶dώ)g	{§£‘±	+αι2#Ωξβ‹υ,Ύ‡ΐεΏΥkόQB@:Ά_N­	[{”ζNN'+ΥΔ~&D=ΒQ5Oύ°Tϋ	|(‡Υηµ$Mmm»β:vB~yύ•άζΎ$Ύ«aDa¤PΨt{Vκ®Q0——aν‘WΔjΈEά3U'kδΗχ}©λ‹x qbΫ)s!:gά‘e ?Η•—8απ£΄)΄eΣE§Υ£|†]³z‘C7—{Κ=ή™ezδk]½ν<W†έ§“cδαdxV΄wΘ‚XΞn_ΖύW±AΪΙ΄•+K·ΔΎ¥Cτθ¦β½ΎνAόOΚ3GΩµτB!WA6 ΎY‘κφΜ EαN5ΓT}Ωώΰ^ν»Αf!λ΅z²¨¶;nΰ·Θπε‹ρΔ¤SπΗΘΗ–%‹"›Sν+	‰|οLTΪQi_Vϊ”Mσ9εΘ{YαoϊQ(Κ8wLν“‡V*H·D$-# %UΜ8HlB0&Εk#g;}FpCΗ“N}®Ef…ΙΡανΛΦί€γkα*yΛ@$¤ΗΠΣMctΡN–‹5‹®Φ«miω•ί®Z'	Οµb—ΥDk7UA3"*όSΥϊά“?m8d²―‘µKό/»ωωΒ <->ΥΟφΣύyR¦X±Π1G—γ©§e|νΞs$BOΜκ7
Κ¦β¶άφFL…ϊΙ£ΕσC]­q‘“ΐ–[θί)έΔL¤ΚΉρGΐύ*c+[D¦’ϋή°…σ+0?1SZ¥gHXΖώϊΓίβh8[B#B―ΚU!ii”!Οω xςς,ZΠΛ=X„Mm0H¥χkΧPΪVα“πΘµ=)‰Φ2τ΅sΤ{«£yιξΣuN‘Ζ}@²fεg "έ¦M­΄Ύ8ίQ0{t°=¨Y¨U8Χ=sn^οl³O³ρ³2φ*ΰ„ ƒόx<Buu;hQmΉίYΩ!P²xB‹Γψάόγ4α%r7]ΊΆ^W!ξ<IA—YΠuΙIAδυ¶r¨Γ§
Ηo#ΉaMiΌ£20v€²Ω–CΑΛ[ύ•ΗtΰΦιπκG8΅uϊ^
ζδΗά–ώY;­ψ¤ΆΜ²†e'ςr‡$—†υάc?g’AP΅’C~¬#ρΓ±—Υϋ¬λΈ2f(ΣΥbύ®Y δt7BL§]09ώΗlΪ¶‹ΉΧ,r+ίώΧ=²=ΕΠj§j}Βύθ΅h±vκEwΈ^Hj©ΤΞ–ϋβPv―£w$‘ϊηb–ιηΦl•+Τύia~jήY.¥΅Θ©™›PΞ§οθ±/xW¨*”3BγSgd²l:ΙTBΦαό!FƒVώκ_θ±‘™:»·WWx«,ΠζrαΝ¨πσέ}Θ9Ά¨fο•θ5π2ΖZΫκ‰eπ–΅b]Ήq#‡-hίΟ]iΤ±ΰόΕZφ®½Htaΰkdο*­λk®KσΎVξ‚C―lΨlγ%9½ ’m%·Q‚oz3a]Χ~+/+(\t›&ϋϊ`#¶”χΜK-ΣήeΒΕχKθΠΰηΡ—μΉ¶!νlζΈ9GήΥλ—Β­&£r–Ηζ”Μΰμ+/Nέ®rƒ†·27BβΐΌ}1½Λ©5ΫΉM—r'ΨΫCΌo_EVΗ$…>?g‹3ΌD`Ν;υ|§_ές$M·eeXySmΦbΝ†ε‡ςΛhxκΟgPΛΨΎ‡–ΛΕςdmYqHhΕυuϊ6{κφ)/ώϋ½λΛ¬Β†A‚‚ω¦Y%}ί&΄Ύ<?ω¶€P`ΦWΓΟ/ΛI³aθΔθ!=4)rbσΣe·thzCQ•9ΨH47χΛw/I1“μ‹…wοyΡβ½ο#~ρ`΅ΡJ\^B@Q%JI6jxζDΘ4gbαEΪηξ¶Ν§Y2IΉJ„zηΚsƒ+υlν0Σ9δρ
ΰί”zΛ•e–άχΏ”Δ©ΖIjΗΩι«@Ki-9φ’PYN¨έY†0N†ίƒ¥‰Aa> Ε.i›BCMΰ΅γ5l”ΞΣβ΄"
μyΓ“8ά¦Υ“’“jΛS
αf½;πƒoΤRτOΟ^Έn?–[,)ƒΌ{ΎƒόΔ[3SΕΤ<?†«΄πƒν (aίβΟY7δ>ώ
j<Π 1©—εqη½‰o\.PκΜ<„W2z\΅	gehο¦lψƒΰ·«µ®ό#Κ&¥/ϋ#ϊx\ϋςΰsFΰOnΑh"ύϊεΈ¬%„τ‡El€?ρ9kΗyi;5„¤¥>s3 ζzΔέ¥όZ·J‘jq“θ¦Ε=nΥCΪ¥ψς³Qz·OΉρ›κ+€ΓΓ2sπtTψσHΦμΩ^m-±ε6Τ’Βµ΅=² °<Z$’qν{7Ό•ZΆι―ζE>»T1Hωύ{yΏ{¥™(ΤEτ!#Γ
DK…ΜGµDχ6]°NωΡN[ΉγPΝπΣΌ4#c¶x~8“άξφ]\F›{Ο‹=4“k	ρSύΞJzEI’†X}pfόξ?ώκΡβ^ν’O Ϊ;	
Jg$…΄ο‹―Υ ωx± Χςή΄€PΑ'ά{Ό.“>”}9¬ρΪϊZ5λ1ON>σ¬&†Κ"·.β'6y;d΄w[ΰ0πΙrjΏσΞ.-vο)Ό‰Q_ χ’­‹ρau¬γ @Πμ£z'μ¬ –b6U Έ>$3θ4±χ>£,¦Φ,.ƒ‘ν;0 O/NxΈJΐzρXIi‡­„ν;)ο|Λ©Q3—λά”fϋμgΓΕlF‚/¤2X­tΥ;{(|»Mά¶Φ=όE.C5αQ²ώα¤^θΣ_IeP§§ig‹Τ`κ8RάµeΆΉ£e§md¨Π•R"€Μl,^Φ'—Έ”}[Ά³YΥpζα­Ka£·FξέΕ
4Χµd$U/γWΗΫψwΒΚδ¶b¦4Ζοhε½ƒLWτ¥$»qtΤqΣεW`©ωN 2»–«0Y3πΜq¤Έξ©ύΣfUΣ#IΥ‡zYvZ‘οRΫψu9M³ΕΖι#ϊεΫΨ¶Ώ6®(δ¥ΊGρΫ#I9p6f_<UάzΜϊΎ1ΛΕΪGHϋέz“O΄„2V@jΩΒΰNΤ
.Λ5\ΕΩΥfχwρ8C”—sτG\Ϋψ±•“ 1¬*?.φ’C2Ε<F=‹¦[,TΌk\j½‚Νc™p ~γ/K°φ‚M[Ύ4¨λ©­…μγ	¶Μ‹σpBΕ΅k\ΐ’Lξβ«!vΑΊ Έ¶J(0ς9Ξχ'Jσmn—k-‘…Dk'ΜλV΅+–¨ώP­qT//ύYΣσΡLZCvΈΉ1ΌqΟ.ό(0…δdοpΑJω¶9ϊΟ8µόnoέ[»iΕa¦!β%µτNώDHyJ"BαΫ’ψxpρ<θgVκ­=μΎpΥ&`qςp/ώ ΡΧ®JΪg]A=
– ¤υφh=®…YΪ…Sη·sB››[ψΗζ1uΣs Χƒ»qδG ΎΑΨy2¥930ω|-γΉ‡ςζ­ν{z;KNAq$Π=`*™ nϊ¦~f’8¬5χb'N¦η©―η †]*Ν^[c/5Η—φ‹™*σμ‹_π{ϊ+¬Ηχν,΄δΤ‘ΰ”6§FΟη<Η-¤¨Z¤®² €¥Φ«Μµ£\°ΦΡCϋwβθ5”t<).Ώα£!ή†Έgeΐε.Π£WVPύξ…¥„΄m§[‚¦­`zΰ$Ε—ΝNH…›Ό”#\®νζτ;έΓ“ΦΟKΛΟGS[w9Α`[Β$AΧάX‘S$®©5Τ½κµ )%ΛΣK)p©HKΝUλ(Iοi>mN0ΐή}σύΥLΝ”i™ΕwσχQ—~½»β©¦ςΌ¨vτ7—ΣΖ.!=!yθ@0ί―WΗΥ# )l†ΒNφήj3j¶®ΉυΕΖ²Φr7	Ϋ8ΤRψωΈΪΆ‚³ ιGµιήM$Χ ±]AnΊ„®=Γΰτ§πlTΖWyG<‚H¤~¨Bη:ίJ"8Ο›φO™WσKο)θζατH[θ0°Ω,‚	νιy%εΆ·FΔΈ* ΰο›ΈVY;}δƒΙ]Pδaέ{)(PΎΝpL:Ji'l™@[;-Αw• juΜ.¦ΰdζ0_@9=±«Hήάlj£T‘eκήΤ@GIµΑΧcR ²φf»σΏk)†―πΰΨπ*γΐG1r—qπh`ϋ°)2„ρLί‚*Η3q·ΤvθT2¦ZM6B·pRΔεΐκ¤O†½Ά7Ύί>;½ζƒ‰m=έ"!¬ΠO―ίΚ³Λ’§pΩΖΣ‰#½iΜΈδGά@nLΠό:"·caΣΧ.ΧO8£΄]!oR9C=3Σ €h TΈU¶»³ΗΖΟ61³JΙΡ+³Ο°j*|¬…
;!A¨ΪF|(gz=0pΜυΦ2ΎΪΓθηµ¶bα¥ΞΣ@nΩutr;vθϊ •΄PΝoµΓθΐΛyΒΛ
8m›_ι‘%ΓΟs/Σ:ϋΤR h {ΨξίΦ :7«§μB}m½η”Ω¦Ά<Ϋ$fΞmF—υu`cI5W†Έ¬cLΕ–{αSb3ώcΰ78Δρ^ \ΤNΔ\η'Hb©υΨ/>“§@ΠfάήΑ<ΎΉ–%‡–χ8ο.MCk`eO/“n$5ΡΜvά£%FOΪr\Xηv’.ύGU%ζyκ…ΐxθ •Ϋ0όψJµΠDΓΪqΎq™gΒλ£t€V³υβψj­φ`oν\Ϋ¬Ϋ―ΰJ’ιUΑ "δΩ0^†χY©##Χ]eE’Σδ2<π°i?ΝµPqtR%υTθάΡbΓ„»μ^χ“]ΔΣσ:Α~•Jέ‹ύ
}Dλφ5θ‚η¬τΤ4
ΤqS*•τzY‹―θ1‡φ‹Ή?¦+;$)‚ ¶ΩTTg7c.*Λέ"U„$βΠY%¤¤JΥ¥¶L,[Ξψ¦ Πba…¤iM]ύ…«Ηu;¦b,jΑOζVc~¤KbΓ­‘3ΩvάΒryYw)k-ΚΈ†ϋ^3fGQ1·Κζ­=`―!ξv—1†UVέEβ—:¦l9G)©Λ/Η΅?€=<»ΧΎV¨>”	k;W¶ϋ*ΝΪΔΊ[LVN΄VAs’yΠεΖDtΨ½S―+#¬@’OcΆ»³ς)²>›ΘΧ$&ά™cό-:‹M… `Ά;?`ψrJ!Jt°Υ8«tξΦQΣΧJΉΔEUύZέ<ΜϋT€®°aυb%Έ¨uεΦV)ΓήtήΝ-Γ›'¶mL@΄γ’JP@‡–Lθρ\R0!‡"1#h…Eφ~YY2di·7£2ρΓ\©uΙάv’#«IγDμξ,3έ3·τMN…s—2ρ^α±f&iΣR¨οΔ¬~]QΆCG=#
%Q›t–»ϋ™Zΐ ‹¬f{ ]1,²7* J8’ΠωΕ“jίΘ™Ρ„jG<Ό:uώEm8X|X7ϊ|~¥σ€αΘψ>Y§‹ίό€SBrυR…rµ'Φ”KLΗI„jδΎ’ΦΝψΪWqΝE¬Γ•¤0Έ$ξ.]D|Ί®kΩqlΑθώΆΠΖv"ΧΛΣΧ5΄θψX<οl2@dtω€@m„²R±ξω­_χq‘Ν9°£`#Ξ±µ5»tί“µ(c~D7οN?_?ω]=4Ψ/Νώ±ωχχI®4^+6FϋοΞ‡ΰξΩ εώ―<D)…ά€Κnz	ΈΡ3δ=‹‚JΏςl|ΚνR&Υt›ϊ-D…ΞmγpV…;Ϊμ;u©*[Ggϊ&ΔiΝ5―o YkΣr(΅Ώ¤αµo‡ΈHMΙqPO°¦αIδ¤Ό—–Ψ2ηΦ §aρ:η£oλs€H¶oή-ΝqK¥ΔΥΡ›P6 „&FΒδez·ΚΧκάΉπΦσΖχδ
R{δό±:θμdφΕZύ8‰nV0)¦-­Ϊ8Δ3&ο·©ΰ(ρ‡	γΏΠξ¶πή¥―E+£ΆfZ’ΙΎLESfΔΨ`†(Ίl§SρΐX·λ΄ώΠι5/όΑ,fό6„Aό+΄΅€ή½Έ°v›Υiιk†6J°£Gϋ °#6·(Ω9„΅g'8›—βΟG>wΒω†ςΒΒη΄;1”Ι›.]…Q}όlε,NΉ1¶ Ρ#(ΐaΌλ„61ί"THΑι±»RΟ™paΜΎ-ΩSά@8'ίD^φNηa*•µ)οEb+q*²ΒXbΥέ6–τή\4ίΉοΓ™Ε\ΠΌ›½§εφ±!«Wί.ι‰όiv{E³¥KΣw‹£ΪΘΫ…Ϋv1H‡Δ¬W•¶5k+µζ·h7νπKϊr;άΓ¥θ¦~¬»ZΧDΗ HHvb$Ηΐa…ύ”ΝNς[@ΨνΤ{ΎεO¨Ηn
λςrQΚp“¨1yΧφLηd zι›h5ΓΊ§ώΓbJ]Λr9gώσ·1H–ήΠ©½§Ο†Φνƒ8CΛOu<±φ	ΤΪΔ;ΨQRΔ”@Έύwsς¶b ·΅]ϊΩ‰‰λ•ΦΤΤΈg` νnC_Φύ°Ε)Δ‹/υGβ¶ύ!‘«uxώ{,„ΜπKωF&SaFlνΦ\ϊC*0'NΥ,’ΏGΏΓηV½Αe/ν2Ψdϊω]ϊBz'ηϊσ©5pn9t†?Ϋ‚ς'fέ1ΪΉ|Ρµς΅¨`6γώΐ~¦°O8a0pοΦ΄΅ηSk”’μTϊhNΪ„ζ0nΟΙ¨(P¶θ‰έή<"RυT2x{%Tw¦~Ϋ4V¶8ίWυΦfp–$ΟCµ/,’ξ›xAΚRϋ 3Α@-ΤqzΪΕCΤς©taΎς΄™,IϋF¦„δΗ\½K'@3+ηΦί)_Έ‰Φ^αΫ=6	o(ζα›Νψ8j"υIh°V,n΄uχΣ<ΈΉbσ#h>Μ?φ…;ΝξΣΦϊςΌ{€ΞVΩϋ”£VδX΅«£Β¨Χ<ΓΞ$||Uj]σ(U5°X-M”²¦ξ’»vλMυχπη―Ζ™c›c–¤aη4¦σiyτ­”€°°™2έ©T6!πεθ΄πIE;+No§²$jkΟ•6]BqY-D‡®«»Ί—*W‰…Λψb―r_i.Ιhό/EβΠ±0†·Ά^ΊZUspηάώΊt"p}G[Γ>m_ηoύ¬”a¨
 —cφ‹HΑξάl4ζ‡ΥiΜ8Lω N&Ν~0υϊσO’+γ¨¨s€Ρ–΅άΎΩ›ΨΠTTqβp–σ…l™»ZJΑυB'ό†·Ζτ$·±t΄.Qj:ΑΏPΪ3G4®(όμu:]Ζt›λq©vPaJΣ ­S:J¬£ΧόΈΜ§iKΌςωΙ f¤ΥΊBZµNp§6ΙφϋYmϋΓ‰η¦!ε?δΌBη—ΆƒθN²d!;;SΒά
ζ[8(|Hcχ=Η³…Ίe―οχ•’¤.ΓcΣ>}Ε^FkµΙ³i+Μa#­ο‚Ω>e΅y—oKh?’G§s²ΎΘS‘I3_‡8C‚λεΗΛGΖRφώSΪZΆ&Κ›σS\1Κs»ό&‡ϊ•ΔγΖ&YW+†Ε
½>Xω¥:aAΗ|5xΣ²%ΰ¦XΤJnϋώ'ΕΟΌNΥqsδΠθh&I/γ†tTH2ίΖυ&&G½VƒNocζ2’Μi1yy_/µ)ν2ψΉ›z1Τ`ΘEΑ$L·S'Σ―Ϋ7b:ΏδΨΚ¥»4Ξΰ„(Κ§€°ί™mBd·ΑΔ8X`‰|΄°-–Bs‚΅Ϊeβ„HEτ΄@–;¤Κβ%¦NO+Ι¨jΉu„ZiTΘα—|ηϋk@fΝοkκ6?’υ¬b—ƒ)κΠΌι,P±Ύn[Φz-Dέ5€W#Σ™‹¨LoΔ–BqIιτ™1¥Φ½Ώ<\Κ+VRζyaGeg9	»<©χ‘PίκδEΞ%Π¶€E΅¤+a` @Ό}f―
‡ρ8}ι^~C•έhf­)Β)`ρ\<wάH™ΰfΣr»+›&q²π:F ο&giω0θ=UWΨ¦Ί?i¤H‚R?³ΏσΝ*4ΥΈO!;β€8.AICb<~jΔΗσ½σ~3υ$F>],2Κδ­9ρ]3AR΄}7{Nχϊ¶¬<«]‘κ$?†%yβ\p—'ΔΚΪjΠεΖΘ©Oz’φ©Nj®™ΠΑοM•ΕVμ²u*οB"a.ξρ1Ύ1W4Θ6Y–ϊ¬μw¥XΥ©ρβέηM\Cu;<r―yΉ­o>Dmσ±KιΈdΏ#ΒΛ[ΉΎ:ί:]wύ}„C3+/‚2Θ!Ζ?iΛ ±ΠβθΜϋ2{m`Σ
—ίπ””k*Ν£l©#;­΄ν/W)Τπ9Z™‰QSL΅IcQ@:†²κ(½Δ°e£,±Hάzwγψb3X«FθjπTT‡ύ¤l*yl@uΨ)fmϋίοΌ•οµUGΜ½l¨.dΚ”,ΐΓtc/kyBnΟπHB‰ΫΉy–‚τ¨¤ίΧv]4vφ΅‚§dq~Χ¨5›‰cΉτuχSχώMρ―†Ι2²wΛΈς―βΩ¦x%&EΎhϊ5¦yAtΖ<Τρ„U›4mδΜzΩ0T`Zgy¥°ϋ4>{Ό"v 
ξ?­wKx%χ€Ξ,1E*X~ςύ—’svxπθ^R’}ε¨qΪξ
Jησπ…X¨½n"\]ξΓ-΄&³[Ηί©ίϋXis.‹h@ND¦™Ο1°;ι­Ί–λ~ΚMίω‘Ε+ϊ―_ /|’Οηκx\I	Ϊ³Υ^=ζω«»¨KγξΜσ®–3ΫR‡]΄lj:0:£l-ώΞΕχ@kV)_(mΡζMe6–ψΊκΐβ>–ΊΉ\xνςhψφΙVΰ3N—ύ·1ΝΦL€"Ν_π}ζΟϊχ°;΅,I[$m •l—έΔsω·a΅m'“χκ[Φ¬m―I«|(
ΑΥ‡A¶τ©:†®l%IΆ	°ικ6<θϋ]cyiΠDΧ<οέ!}ΔfΘοq0ΈΘ«<θΞ}Κ€\ΎΓέΰΜr΄ΎtπκrΥΨiKΥά\%{ψ]$qΗS©ςs·Ι¬dB[Ϋήqsζd›·¨;…BΒΚΉ96ΔψQ‘@v(.·Ϊ‹Ϊς~yzΥSΆ"άIΧ·ϊf¦IΣύ7O{¦W%IltΤXΰc†‡Ζ2·η΅@ωΚ%KG>‰o/dνΖ,Δ‚ηΖ—†fόDX/΄ƒάeZh‘ΝOρέΓzTJω‚Z4?C@_*eOTΝΙ1‚i«ωED$Έ‹/½Έ―haρ»C Ψΐρ°¦qΨqOjά›¥|•}`…aWd ΕΎμ§”bΪg,ηΦΧ]ΐθ³ρ¤½y>τ‚yeΘ°j^eυ¬ΎWΏ~½0RβBV1Ιπςu”%ACτλωμεόΞ·²\j8”S>Z…YHΥ’πτ /βecΜεcΟΣΘΆ#\;ζ†ίs5+»§εΉ›χ„E#7VgwdWέ›gΎΞ cq΄ΥiΨ+2άκΝ
U©gP&“νQgΚΩzΎο
UΈ€v‚ω¦%ό6 Ύ+Η¨)Ήqκμ„ΟΕ9ωί-®’Ω\δω΅Χΐ>ψBG1MΛϊ―l’	hΜψ*™ύΐ;aM¶)ωmΆ–G€paN°?Ωw ϋYCθ‰mXΣγΣΙ0(›c³yNήοR<%ωψ.~Β,ƒ‡G~θχ2bJ―‰
ok―'ΩΞΊYχ΅¶ΰ¥ά^Ορ©Sρ^­·,—¥‚΄ώw!»ΑΧ‹ΖΛyUv‚ΈΦ›ƒΪΙΕ¦†”rΩΨ‡}—«lεwCμ±ήΣλΩnιp‡®ΩΕF+ΠΪJΎ•‹θ*Ξl64ΘΓ~dAϋH Ί±Β]a¦o/i(ϊr}€¨α;»‰|aQ"¦ϊ΅: ζC<`ν²(n	ζcξB!—©”ή/γΙ	λ@nω…¤Eυ"Γ― ‡ R§(Ζ±vnk…—πβXΎhXlΫ®ύ¨¨Ξ
7¤ώ|¬±Έc<χ¨g•,9jΪγσgί“Q=*ΞEΪβόΓΫ I Ίu“½nΒ€SoύΛ¤»@*Vμ *4<κ§Z<sλΞωΕL~1±«8/©^dιUH{~4¶G)Γφ?κ³`°Ϋ΄&{Ά™ψαΡ3ξ΄"Η=‘±yUZ:σ#Τ;?ΩwΫDΙ¥`”*ξSiV\λ/«‹°Ή=Zχ!η«Ό¤rηF«†ψΠw‚¤έ$9q {x†uΓΔlΝYΰAN|lϋ™¶6SqξVΎΤπΉϊ½fΠ/πδ4wΧv|ωuGo†®$¤ΕWΨρΈtkhΙB#=vT3{dW¨™ώωε0―S#¤ΜΪΨ9®κ$έΌ ώ)νΕΜχΨTCν›>ήϊuΥ;fΎG"όΧ0*NΞ	lUΥ2υ	΄:ΌΖρ°°σ, λbΨι]BΉΠξ`³‹'Dγ~¶νM.λΖ±‰ υδ™DΨn@{Δ0ΛωkIi(X!’='ΐύ¤@ώ03ΘΥ,Ψ=»Mη%vΕhY¦νμοRrΘ²ρΐΚjξ†¥‰4φ’^M7‰Q9¬¨ϊOλνφiΒK°^>.¦( Cϊ­	ς*χ'7B<8Μ³o§Ύ±A8ίo-9Π)Ψτ..ς7i:DT$‡£9~8†\Lκd4@ΤϋΥΖύ€2«λ—sζu G©αΔ‡­‰8ΐΈfΒΰ9MvwΖL·Jq	5”½Ν@ήΝΎ”~§ρWψΌβ€CφαIR;`_?Uό”χ>ασ¨‚•’¶ν{οεuPqVB¥Ύζcξ¬P ϋ¨Ι—x{ςCdFsέ¤8ψφ»®R·(Ύj\πΗ…ΐ‹Θ™P&fO¶Τ1κhΛ#cΠVW-q‡Π¬G#›86)πω Έ_¦ΰΡζΥO0¦”†ΐ<…+‘“U– j6ώ=ΌQuΪΦΒ…RΐxΤ¦Rδƒ¨dγSH»€Έκuκ…Ψ_ΛEο‰0ξ4§`YΥΠρΣrXƒµBciΎΦΛΒiTI§ t1β–„ρΡ\Jάq5ω
Ύ:CδlTt>υVΫ>”d‰&3ΠΧ*` ά3Ο"ΙnΪdrCγϋ_Θφσo¨k‹τt™ΝΨYψ@ρcΘ;$-G Κ›·―XW‰	t³ώ-λioΧrmt^`ΏβλΎχΧ‡Χπΐ`gΪτh‰xVzz[]#’+χ}cU®…%Ηo’ƒ³}ΔpCq•b'Mάgh€Fέ VβchSWnƒώ²6*qΦ6w€ϊ έΈ6dOe'«Ώc²E[mΕ>b@EIqΗΠί“u©υ]C•ό%ώ_¶;ζ&Κ4Εί6΄,ΌΏ]mΤϊwΪF›ήι#F”ξQ|r	ίΙ²7ΓBB_•3λd‡ΜKU³χΉΰMΗUϋ ¨έa«6CJό›/Wζς”‰ΞΨ•²‡άΌ£ψ•7Ωµ “¤ά¨€l<‰Ητ-ιW2kω'¤ΚζjΓn3Ζ·τLgά#›*’ΠΫX6έ½WoΞ#NO­΄7ΦδLΫΟhc¬W«–ΰ’βDΡζΒ’Ώώ(Α°ΧβRύxΙVβ½‰b|NIΗΐ”)ΫuµΆ¤Ξ ΠνκΫρ=,(»·@Λ‹\P=»j“§UKYz­Ν^4³-δƒX®όλ¨ΫI‹νΈ{―T?}ν©όk½“ƒξ‰[4ψφzµ3Ωά΄¬$dO%%ΘB<Κ…!πξ΄¶Ύ³{‰“KΐuΗ/Xζ±‹ΘZ@ύVv»”)8µ¦έZuQ§Λ³/’Μ5Θ>7
t#γΆr@ ―Ω§.Ά©θ‡βάcfΐΔ!½ιqnµr(®6Ρ7ΆN±β›NΦδ’-YV±ΑVo;SB›"…–±·q³™„)hύΘβδΧι·JV…αr[ωΣJΊixμµTΆR5 δ·TtNN2σ iI‚αΛ―ΖhπΧϋd
›4bI·qgf `R9ξω@‡N^N[TΧT'ύBwmΓθNg<Vwϋ³c¥Ψ¬lζ/ x
ώ­aΪ_΄xµ£”¶έΩ5µί9ψ)Y3Ώι57=°Ϊ΅«sΪRT¦μ?ϋ{ξC¶sjH68§«‚@…΅ή½ΖΣK3―3v½ψ‘χ•dβ€rν%`¶ap†FN*ωk`ΊΞ’Γ†hΕ3ω­‰F„Ωeύλ‡ώ[ΌPΎοt0'Ά	γIΪ<Υ·uz ]γ‚‹Sd»‹’X&SφΨΓ&”KθYΨΈxγύF ‹λΔ>ΝΤα„Ά—΅θηY%ΰLυ8Ε`’`αZΩΟΨT«	lΎdρ£| \Ωfh„{D)]FPΧΥE'F¥γPΩ,Ξ@±7φτΘ‚¨ΑΝιBδΫG3Tΰ™V"*UΌoφτeΈBJ£m­	Ω8q4“Ϋ4Ύ‚SΩ½°lDύΕ@‚t"DΆnΔψΣΨ+P€‡?―ιN†RΌ‚%ήξ±D’m·)¥&[±TΞβdςy΅•ξΧOG437:Tο=cp…:=]ή¶ΥσοΊ*μM[ζd;³g^Ηc§?αµ¬§%›&ΈύΗ±δl~HJN-κ#/(οJνvσ]ρNΩ’‹"NµE,΄|A{±υOϋ‹^!2έ‚+p§Ά²άάϋ+¤zoνΓ@0%l­K5εςΐ…QΡY"q§ξ_Flx6­¬ΝE\_ΖΗΧΛΡ;
t9/•ς.ΠΪ{lτϊ΅Ϋζο‘κaMΛ"ΣΎίλΎ}ό„ϋο:`lΗ”ο$¬i³ΐΩ`ωΑ/!ς^½7µΨ?ηρΑΟWΝ]―ίWE8ΛΝΙ ρƒ”‚n­u:Θ3Φ3k~F½/r?7ί‡yJωδPω>}ΈΨ§Ή7Hε…^ώ[χΙSύΧk ‡?ΟΒWΰ£x,?
†‹4Η;Bα‘–TΘZHρ}ω+Φ8kjΫ‹¦ο€I΄_Tί·όξOxκ›¨ϋp…9¥1λzWoυj‚'zPC•Α―)y3ψlfΗk	Lτ“AΓ³ίΰr_G7oχ k¶>…B&2j2έKΖ{΅L B@ε’ ΤuQ:5Ε‘ΫγxΊo=M" =‘2ƒpa§<ο0	.΄YΙ-Ξπ―ΏfGi¨―ίi(9vs-I;]Ζ>vΫΰVu<ή ψ=#³ΙτΟά~/ν†^£†SηuρϋέΤ<ς³q*ΏMΤ>μΟ?τ(θUύQ^ƒ·έ·Μ{β+‡ω·[Χe·[4/'όkΙ‡6Iν[ΠΖ~Ζ•ΞhQλ!|%±άί…ΒΆ¥cψ9y7?τ¨`9-έογ·{†"qτ£²	 ίfΗO±$P1<α΅ω4ρ΄σΰOέ>Y@y<l εA³1;C	@ΐhφϋΌY"P‹*=¤RLΨλ`ΰ!dυ΅‰q'ήγx$ƒiΓ§AJmaΓ0c‡ΤΦiωD†’¶u/¦¨Γ—:BfΪ±MGξηΌ%s5lkΟ·{4…ϊ€ω# _ Z΅MWl‘Ϋf:³£ρµ ΆPΥΈ¨fuΔ/‚ ΓµM>©δθ%C§6sv¤Μψ³‰"μvJ:c†D@ΦΕ#wfzΕΧ3µD±η^Ζ©“φE™€+Λ ™γ‘cU?¦}χ Ϋ”οΗ5m¶/eΐmo	Ίn­*ΪπHJ®Άέ|Ξ!ΰ„CS­W~³›βα±T01ΐω~mϋΎ3άΌm—θlΨ«ΒΪZ•ψυ%»Jχςn°ϊjnΒ~EώiΊ―ΙΫ‚ΐpΓΟ^.Mψς­¶j£V3iqΈj‡»i΅‹R¬λ ό%~@wΦs4Α³FΏΓ…?α{eι!‡y%2Αό0&ί6±ΚZ²»=Φ"Iηά5Γ‘θ‚VΑ bY£‰άxυµAΗ½ύ~µ‡}RΨ[6½ϋ"ΠυΩη®„pjαύΎMΝΪ%Τ6ΛY[‰”…t›΄wβ‡T|ύ,ΨΡΌ­χHΏcσR‚τ:3ΖSss®Gn‘{fΐf!ήP–#ΰΔbI[ΡNH·YQοιPΎΘEcόσΟ@?―Ω…5τ‰ρ±FuKjO½N>TψΦ&0C»οΡGυ¦“Λί¦E*q9{V0‡ΈΛΏPsΚ)κ?ΰ ©‡4ίΣ^Υ½†{ό£¥πWC*=ƒ)Lδ©^³}½$am(Ηαtu”8D½,ΥυΚyi€¶Ί]ϋ.‘Π1νHt ΫEXώ—άωιΎ›ΜmFxΩ3¨
.¶‡s*bm
/ΘIΡ›6y£‡Η%ZC¦aλ|ψIFrt²$;άI&ΔB.0ΩƒκS f xύ—ΫiρφpΝΨC²φHΟl«Ϋ=Ρjω2-J] —Σ½5ΞL®αg^0yΪnΡΔvΝD’ξΥ`+Π@βΫ―MU«SυCWα>™Doγ)έ¬Φρ¥ΐ?,Θ?6θΞώ¬άnΰ(Θβ=Θmm’kDΗ®Κ–θ{ΦΊΘIRQ) << LOCK_USAGE_READ_MASK;

	return excl;
}

/*
 * Find the first pair of bit match between an original
 * usage mask and an exclusive usage mask.
 */
static int find_exclusive_match(unsigned long mask,
				unsigned long excl_mask,
				enum lock_usage_bit *bitp,
				enum lock_usage_bit *excl_bitp)
{
	int bit, excl, excl_read;

	for_each_set_bit(bit, &mask, LOCK_USED) {
		/*
		 * exclusive_bit() strips the read bit, however,
		 * LOCK_ENABLED_IRQ_*_READ may cause deadlocks too, so we need
		 * to search excl | LOCK_USAGE_READ_MASK as well.
		 */
		excl = exclusive_bit(bit);
		excl_read = excl | LOCK_USAGE_READ_MASK;
		if (excl_mask & lock_flag(excl)) {
			*bitp = bit;
			*excl_bitp = excl;
			return 0;
		} else if (excl_mask & lock_flag(excl_read)) {
			*bitp = bit;
			*excl_bitp = excl_read;
			return 0;
		}
	}
	return -1;
}

/*
 * Prove that the new dependency does not connect a hardirq-safe(-read)
 * lock with a hardirq-unsafe lock - to achieve this we search
 * the backwards-subgraph starting at <prev>, and the
 * forwards-subgraph starting at <next>:
 */
static int check_irq_usage(struct task_struct *curr, struct held_lock *prev,
			   struct held_lock *next)
{
	unsigned long usage_mask = 0, forward_mask, backward_mask;
	enum lock_usage_bit forward_bit = 0, backward_bit = 0;
	struct lock_list *target_entry1;
	struct lock_list *target_entry;
	struct lock_list this, that;
	enum bfs_result ret;

	/*
	 * Step 1: gather all hard/soft IRQs usages backward in an
	 * accumulated usage mask.
	 */
	bfs_init_rootb(&this, prev);

	ret = __bfs_backwards(&this, &usage_mask, usage_accumulate, usage_skip, NULL);
	if (bfs_error(ret)) {
		print_bfs_bug(ret);
		return 0;
	}

	usage_mask &= LOCKF_USED_IN_IRQ_ALL;
	if (!usage_mask)
		return 1;

	/*
	 * Step 2: find exclusive uses forward that match the previous
	 * backward accumulated mask.
	 */
	forward_mask = exclusive_mask(usage_mask);

	bfs_init_root(&that, next);

	ret = find_usage_forwards(&that, forward_mask, &target_entry1);
	if (bfs_error(ret)) {
		print_bfs_bug(ret);
		return 0;
	}
	if (ret == BFS_RNOMATCH)
		return 1;

	/*
	 * Step 3: we found a bad match! Now retrieve a lock from the backward
	 * list whose usage mask matches the exclusive usage mask from the
	 * lock found on the forward list.
	 *
	 * Note, we should only keep the LOCKF_ENABLED_IRQ_ALL bits, considering
	 * the follow case:
	 *
	 * When trying to add A -> B to the graph, we find that there is a
	 * hardirq-safe L, that L -> ... -> A, and another hardirq-unsafe M,
	 * that B -> ... -> M. However M is **softirq-safe**, if we use exact
	 * invert bits of M's usage_mask, we will find another lock N that is
	 * **softirq-unsafe** and N -> ... -> A, however N -> .. -> M will not
	 * cause a inversion deadlock.
	 */
	backward_mask = original_mask(target_entry1->class->usage_mask & LOCKF_ENABLED_IRQ_ALL);

	ret = find_usage_backwards(&this, backward_mask, &target_entry);
	if (bfs_error(ret)) {
		print_bfs_bug(ret);
		return 0;
	}
	if (DEBUG_LOCKS_WARN_ON(ret == BFS_RNOMATCH))
		return 1;

	/*
	 * Step 4: narrow down to a pair of incompatible usage bits
	 * and report it.
	 */
	ret = find_exclusive_match(target_entry->class->usage_mask,
				   target_entry1->class->usage_mask,
				   &backward_bit, &forward_bit);
	if (DEBUG_LOCKS_WARN_ON(ret == -1))
		return 1;

	print_bad_irq_dependency(curr, &this, &that,
				 target_entry, target_entry1,
				 prev, next,
				 backward_bit, forward_bit,
				 state_name(backward_bit));

	return 0;
}

#else

static inline int check_irq_usage(struct task_struct *curr,
				  struct held_lock *prev, struct held_lock *next)
{
	return 1;
}

static inline bool usage_skip(struct lock_list *entry, void *mask)
{
	return false;
}

#endif /* CONFIG_TRACE_IRQFLAGS */

#ifdef CONFIG_LOCKDEP_SMALL
/*
 * Check that the dependency graph starting at <src> can lead to
 * <target> or not. If it can, <src> -> <target> dependency is already
 * in the graph.
 *
 * Return BFS_RMATCH if it does, or BFS_RNOMATCH if it does not, return BFS_E* if
 * any error appears in the bfs search.
 */
static noinline enum bfs_result
check_redundant(struct held_lock *src, struct held_lock *target)
{
	enum bfs_result ret;
	struct lock_list *target_entry;
	struct lock_list src_entry;

	bfs_init_root(&src_entry, src);
	/*
	 * Special setup for check_redundant().
	 *
	 * To report redundant, we need to find a strong dependency path that
	 * is equal to or stronger than <src> -> <target>. So if <src> is E,
	 * we need to let __bfs() only search for a path starting at a -(E*)->,
	 * we achieve this by setting the initial node's ->only_xr to true in
	 * that case. And if <prev> is S, we set initial ->only_xr to false
	 * because both -(S*)-> (equal) and -(E*)-> (stronger) are redundant.
	 */
	src_entry.only_xr = src->read == 0;

	debug_atomic_inc(nr_redundant_checks);

	/*
	 * Note: we skip local_lock() for redundant check, because as the
	 * comment in usage_skip(), A -> local_lock() -> B and A -> B are not
	 * the same.
	 */
	ret = check_path(target, &src_entry, hlock_equal, usage_skip, &target_entry);

	if (ret == BFS_RMATCH)
		debug_atomic_inc(nr_redundant);

	return ret;
}

#else

static inline enum bfs_result
check_redundant(struct held_lock *src, struct held_lock *target)
{
	return BFS_RNOMATCH;
}

#endif

static void inc_chains(int irq_context)
{
	if (irq_context & LOCK_CHAIN_HARDIRQ_CONTEXT)
		nr_hardirq_chains++;
	else if (irq_context & LOCK_CHAIN_SOFTIRQ_CONTEXT)
		nr_softirq_chains++;
	else
		nr_process_chains++;
}

static void dec_chains(int irq_context)
{
	if (irq_context & LOCK_CHAIN_HARDIRQ_CONTEXT)
		nr_hardirq_chains--;
	else if (irq_context & LOCK_CHAIN_SOFTIRQ_CONTEXT)
		nr_softirq_chains--;
	else
		nr_process_chains--;
}

static void
print_deadlock_scenario(struct held_lock *nxt, struct held_lock *prv)
{
	struct lock_class *next = hlock_class(nxt);
	struct lock_class *prev = hlock_class(prv);

	printk(" Possible unsafe locking scenario:\n\n");
	printk("       CPU0\n");
	printk("       ----\n");
	printk("  lock(");
	__print_lock_name(prev);
	printk(KERN_CONT ");\n");
	printk("  lock(");
	__print_lock_name(next);
	printk(KERN_CONT ");\n");
	printk("\n *** DEADLOCK ***\n\n");
	printk(" May be due to missing lock nesting notation\n\n");
}

static void
print_deadlock_bug(struct task_struct *curr, struct held_lock *prev,
		   struct held_lock *next)
{
	if (!debug_locks_off_graph_unlock() || debug_locks_silent)
		return;

	pr_warn("\n");
	pr_warn("============================================\n");
	pr_warn("WARNING: possible recursive locking detected\n");
	print_kernel_ident();
	pr_warn("--------------------------------------------\n");
	pr_warn("%s/%d is trying to acquire lock:\n",
		curr->comm, task_pid_nr(curr));
	print_lock(next);
	pr_warn("\nbut task is already holding lock:\n");
	print_lock(prev);

	pr_warn("\nother info that might help us debug this:\n");
	print_deadlock_scenario(next, prev);
	lockdep_print_held_locks(curr);

	pr_warn("\nstack backtrace:\n");
	dump_stack();
}

/*
 * Check whether we are holding such a class already.
 *
 * (Note that this has to be done separately, because the graph cannot
 * detect such classes of deadlocks.)
 *
 * Returns: 0 on deadlock detected, 1 on OK, 2 if another lock with the same
 * lock class is held but nest_lock is also held, i.e. we rely on the
 * nest_lock to avoid the deadlock.
 */
static int
check_deadlock(struct task_struct *curr, struct held_lock *next)
{
	struct held_lock *prev;
	struct held_lock *nest = NULL;
	int i;

	for (i = 0; i < curr->lockdep_depth; i++) {
		prev = curr->held_locks + i;

		if (prev->instance == next->nest_lock)
			nest = prev;

		if (hlock_class(prev) != hlock_class(next))
			continue;

		/*
		 * Allow read-after-read recursion of the same
		 * lock class (i.e. read_lock(lock)+read_lock(lock)):
		 */
		if ((next->read == 2) && prev->read)
			continue;

		/*
		 * We're holding the nest_lock, which serializes this lock's
		 * nesting behaviour.
		 */
		if (nest)
			return 2;

		print_deadlock_bug(curr, prev, next);
		return 0;
	}
	return 1;
}

/*
 * There was a chain-cache miss, and we are about to add a new dependency
 * to a previous lock. We validate the following rules:
 *
 *  - would the adding of the <prev> -> <next> dependency create a
 *    circular dependency in the graph? [== circular deadlock]
 *
 *  - does the new prev->next dependency connect any hardirq-safe lock
 *    (in the full backwards-subgraph starting at <prev>) with any
 *    hardirq-unsafe lock (in the full forwards-subgraph starting at
 *    <next>)? [== illegal lock inversion with hardirq contexts]
 *
 *  - does the new prev->next dependency connect any softirq-safe lock
 *    (in the full backwards-subgraph starting at <prev>) with any
 *    softirq-unsafe lock (in the full forwards-subgraph starting at
 *    <next>)? [== illegal lock inversion with softirq contexts]
 *
 * any of these scenarios could lead to a deadlock.
 *
 * Then if all the validations pass, we add the forwards and backwards
 * dependency.
 */
static int
check_prev_add(struct task_struct *curr, struct held_lock *prev,
	       struct held_lock *next, u16 distance,
	       struct lock_trace **const trace)
{
	struct lock_list *entry;
	enum bfs_result ret;

	if (!hlock_class(prev)->key || !hlock_class(next)->key) {
		/*
		 * The warning statements below may trigger a use-after-free
		 * of the class name. It is better to trigger a use-after free
		 * and to have the class name most of the time instead of not
		 * having the class name available.
		 */
		WARN_ONCE(!debug_locks_silent && !hlock_class(prev)->key,
			  "Detected use-after-free of lock class %px/%s\n",
			  hlock_class(prev),
			  hlock_class(prev)->name);
		WARN_ONCE(!debug_locks_silent && !hlock_class(next)->key,
			  "Detected use-after-free of lock class %px/%s\n",
			  hlock_class(next),
			  hlock_class(next)->name);
		return 2;
	}

	/*
	 * Prove that the new <prev> -> <next> dependency would not
	 * create a circular dependency in the graph. (We do this by
	 * a breadth-first search into the graph starting at <next>,
	 * and check whether we can reach <prev>.)
	 *
	 * The search is limited by the size of the circular queue (i.e.,
	 * MAX_CIRCULAR_QUEUE_SIZE) which keeps track of a breadth of nodes
	 * in the graph whose neighbours are to be checked.
	 */
	ret = check_noncircular(next, prev, trace);
	if (unlikely(bfs_error(ret) || ret == BFS_RMATCH))
		return 0;

	if (!check_irq_usage(curr, prev, next))
		return 0;

	/*
	 * Is the <prev> -> <next> dependency already present?
	 *
	 * (this may occur even though this is a new chain: consider
	 *  e.g. the L1 -> L2 -> L3 -> L4 and the L5 -> L1 -> L2 -> L3
	 *  chains - the second one will be new, but L1 already has
	 *  L2 added to its dependency list, due to the first chain.)
	 */
	list_for_each_entry(entry, &hlock_class(prev)->locks_after, entry) {
		if (entry->class == hlock_class(next)) {
			if (distance == 1)
				entry->distance = 1;
			entry->dep |= calc_dep(prev, next);

			/*
			 * Also, update the reverse dependency in @next's
			 * ->locks_before list.
			 *
			 *  Here we reuse @entry as the cursor, which is fine
			 *  because we won't go to the next iteration of the
			 *  outer loop:
			 *
			 *  For normal cases, we return in the inner loop.
			 *
			 *  If we fail to return, we have inconsistency, i.e.
			 *  <prev>::locks_after contains <next> while
			 *  <next>::locks_before doesn't contain <prev>. In
			 *  that case, we return after the inner and indicate
			 *  something is wrong.
			 */
			list_for_each_entry(entry, &hlock_class(next)->locks_before, entry) {
				if (entry->class == hlock_class(prev)) {
					if (distance == 1)
						entry->distance = 1;
					entry->dep |= calc_depb(prev, next);
					return 1;
				}
			}

			/* <prev> is not found in <next>::locks_before */
			return 0;
		}
	}

	/*
	 * Is the <prev> -> <next> link redundant?
	 */
	ret = check_redundant(prev, next);
	if (bfs_error(ret))
		return 0;
	else if (ret == BFS_RMATCH)
		return 2;

	if (!*trace) {
		*trace = save_trace();
		if (!*trace)
			return 0;
	}

	/*
	 * Ok, all validations passed, add the new lock
	 * to the previous lock's dependency list:
	 */
	ret = add_lock_to_list(hlock_class(next), hlock_class(prev),
			       &hlock_class(prev)->locks_after,
			       next->acquire_ip, distance,
			       calc_dep(prev, next),
			       *trace);

	if (!ret)
		return 0;

	ret = add_lock_to_list(hlock_class(prev), hlock_class(next),
			       &hlock_class(next)->locks_before,
			       next->acquire_ip, distance,
			       calc_depb(prev, next),
			       *trace);
	if (!ret)
		return 0;

	return 2;
}

/*
 * Add the dependency to all directly-previous locks that are 'relevant'.
 * The ones that are relevant are (in increasing distance from curr):
 * all consecutive trylock entries and the final non-trylock entry - or
 * the end of this context's lock-chain - whichever comes first.
 */
static int
check_prevs_add(struct task_struct *curr, struct held_lock *next)
{
	struct lock_trace *trace = NULL;
	int depth = curr->lockdep_depth;
	struct held_lock *hlock;

	/*
	 * Debugging checks.
	 *
	 * Depth must not be zero for a non-head lock:
	 */
	if (!depth)
		goto out_bug;
	/*
	 * At least two relevant locks must exist for this
	 * to be a head:
	 */
	if (curr->held_locks[depth].irq_context !=
			curr->held_locks[depth-1].irq_context)
		goto out_bug;

	for (;;) {
		u16 distance = curr->lockdep_depth - depth + 1;
		hlock = curr->held_locks + depth - 1;

		if (hlock->check) {
			int ret = check_prev_add(curr, hlock, next, distance, &trace);
			if (!ret)
				return 0;

			/*
			 * Stop after the first non-trylock entry,
			 * as non-trylock entries have added their
			 * own direct dependencies already, so this
			 * lock is connected to them indirectly:
			 */
			if (!hlock->trylock)
				break;
		}

		depth--;
		/*
		 * End of lock-stack?
		 */
		if (!depth)
			break;
		/*
		 * Stop the search if we cross into another context:
		 */
		if (curr->held_locks[depth].irq_context !=
				curr->held_locks[depth-1].irq_context)
			break;
	}
	return 1;
out_bug:
	if (!debug_locks_off_graph_unlock())
		return 0;

	/*
	 * Clearly we all shouldn't be here, but since we made it we
	 * can reliable say we messed up our state. See the above two
	 * gotos for reasons why we could possibly end up here.
	 */
	WARN_ON(1);

	return 0;
}

struct lock_chain lock_chains[MAX_LOCKDEP_CHAINS];
static DECLARE_BITMAP(lock_chains_in_use, MAX_LOCKDEP_CHAINS);
static u16 chain_hlocks[MAX_LOCKDEP_CHAIN_HLOCKS];
unsigned long nr_zapped_lock_chains;
unsigned int nr_free_chain_hlocks;	/* Free chain_hlocks in buckets */
unsigned int nr_lost_chain_hlocks;	/* Lost chain_hlocks */
unsigned int nr_large_chain_blocks;	/* size > MAX_CHAIN_BUCKETS */

/*
 * The first 2 chain_hlocks entries in the chain block in the bucket
 * list contains the following meta data:
 *
 *   entry[0]:
 *     Bit    15 - always set to 1 (it is not a class index)
 *     Bits 0-14 - upper 15 bits of the next block index
 *   entry[1]    - lower 16 bits of next block index
 *
 * A next block index of all 1 bits means it is the end of the list.
 *
 * On the unsized bucket (bucket-0), the 3rd and 4th entries contain
 * the chain block size:
 *
 *   entry[2] - upper 16 bits of the chain block size
 *   entry[3] - lower 16 bits of the chain block size
 */
#define MAX_CHAIN_BUCKETS	16
#define CHAIN_BLK_FLAG		(1U << 15)
#define CHAIN_BLK_LIST_END	0xFFFFU

static int chain_block_buckets[MAX_CHAIN_BUCKETS];

static inline int size_to_bucket(int size)
{
	if (size > MAX_CHAIN_BUCKETS)
		return 0;

	return size - 1;
}

/*
 * Iterate all the chain blocks in a bucket.
 */
#define for_each_chain_block(bucket, prev, curr)		\
	for ((prev) = -1, (curr) = chain_block_buckets[bucket];	\
	     (curr) >= 0;					\
	     (prev) = (curr), (curr) = chain_block_next(curr))

/*
 * next block or -1
 */
static inline int chain_block_next(int offset)
{
	int next = chain_hlocks[offset];

	WARN_ON_ONCE(!(next & CHAIN_BLK_FLAG));

	if (next == CHAIN_BLK_LIST_END)
		return -1;

	next &= ~CHAIN_BLK_FLAG;
	next <<= 16;
	next |= chain_hlocks[offset + 1];

	return next;
}

/*
 * bucket-0 only
 */
static inline int chain_block_size(int offset)
{
	return (chain_hlocks[offset + 2] << 16) | chain_hlocks[offset + 3];
}

static inline void init_chain_block(int offset, int next, int bucket, int size)
{
	chain_hlocks[offset] = (next >> 16) | CHAIN_BLK_FLAG;
	chain_hlocks[offset + 1] = (u16)next;

	if (size && !bucket) {
		chain_hlocks[offset + 2] = size >> 16;
		chain_hlocks[offset + 3] = (u16)size;
	}
}

static inline void add_chain_block(int offset, int size)
{
	int bucket = size_to_bucket(size);
	int next = chain_block_buckets[bucket];
	int prev, curr;

	if (unlikely(size < 2)) {
		/*
		 * We can't store single entries on the freelist. Leak them.
		 *
		 * One possible way out would be to uniquely mark them, other
		 * than with CHAIN_BLK_FLAG, such that we can recover them when
		 * the block before it is re-added.
		 */
		if (size)
			nr_lost_chain_hlocks++;
		return;
	}

	nr_free_chain_hlocks += size;
	if (!bucket) {
		nr_large_chain_blocks++;

		/*
		 * Variable sized, sort large to small.
		 */
		for_each_chain_block(0, prev, curr) {
			if (size >= chain_block_size(curr))
				break;
		}
		init_chain_block(offset, curr, 0, size);
		if (prev < 0)
			chain_block_buckets[0] = offset;
		else
			init_chain_block(prev, offset, 0, 0);
		return;
	}
	/*
	 * Fixed size, add to head.
	 */
	init_chain_block(offset, next, bucket, size);
	chain_block_buckets[bucket] = offset;
}

/*
 * Only the first block in the list can be deleted.
 *
 * For the variable size bucket[0], the first block (the largest one) is
 * returned, broken up and put back into the pool. So if a chain block of
 * length > MAX_CHAIN_BUCKETS is ever used and zapped, it will just be
 * queued up after the primordial chain block and never be used until the
 * hlock entries in the primordial chain block is almost used up. That
 * causes fragmentation and reduce allocation efficiency. That can be
 * monitored by looking at the "large chain blocks" number in lockdep_stats.
 */
static inline void del_chain_block(int bucket, int size, int next)
{
	nr_free_chain_hlocks -= size;
	chain_block_buckets[bucket] = next;

	if (!bucket)
		nr_large_chain_blocks--;
}

static void init_chain_block_buckets(void)
{
	int i;

	for (i = 0; i < MAX_CHAIN_BUCKETS; i++)
		chain_block_buckets[i] = -1;

	add_chain_block(0, ARRAY_SIZE(chain_hlocks));
}

/*
 * Return offset of a chain block of the right size or -1 if not found.
 *
 * Fairly simple worst-fit allocator with the addition of a number of size
 * specific free lists.
 */
static int alloc_chain_hlocks(int req)
{
	int bucket, curr, size;

	/*
	 * We rely on the MSB to act as an escape bit to denote freelist
	 * pointers. Make sure this bit isn't set in 'normal' class_idx usage.
	 */
	BUILD_BUG_ON((MAX_LOCKDEP_KEYS-1) & CHAIN_BLK_FLAG);

	init_data_structures_once();

	if (nr_free_chain_hlocks < req)
		return -1;

	/*
	 * We require a minimum of 2 (u16) entries to encode a freelist
	 * 'pointer'.
	 */
	req = max(req, 2);
	bucket = size_to_bucket(req);
	curr = chain_block_buckets[bucket];

	if (bucket) {
		if (curr >= 0) {
			del_chain_block(bucket, req, chain_block_next(curr));
			return curr;
		}
		/* Try bucket 0 */
		curr = chain_block_buckets[0];
	}

	/*
	 * The variable sized freelist is sorted by size; the first entry is
	 * the largest. Use it if it fits.
	 */
	if (curr >= 0) {
		size = chain_block_size(curr);
		if (likely(size >= req)) {
			del_chain_block(0, size, chain_block_next(curr));
			add_chain_block(curr + req, size - req);
			return curr;
		}
	}

	/*
	 * Last resort, split a block in a larger sized bucket.
	 */
	for (size = MAX_CHAIN_BUCKETS; size > req; size--) {
		bucket = size_to_bucket(size);
		curr = chain_block_buckets[bucket];
		if (curr < 0)
			continue;

		del_chain_block(bucket, size, chain_block_next(curr));
		add_chain_block(curr + req, size - req);
		return curr;
	}

	return -1;
}

static inline void free_chain_hlocks(int base, int size)
{
	add_chain_block(base, max(size, 2));
}

struct lock_class *lock_chain_get_class(struct lock_chain *chain, int i)
{
	u16 chain_hlock = chain_hlocks[chain->base + i];
	unsigned int class_idx = chain_hlock_class_idx(chain_hlock);

	return lock_classes + class_idx;
}

/*
 * Returns the index of the first held_lock of the current chain
 */
static inline int get_first_held_lock(struct task_struct *curr,
					struct held_lock *hlock)
{
	int i;
	struct held_lock *hlock_curr;

	for (i = curr->lockdep_depth - 1; i >= 0; i--) {
		hlock_curr = curr->held_locks + i;
		if (hlock_curr->irq_context != hlock->irq_context)
			break;

	}

	return ++i;
}

#ifdef CONFIG_DEBUG_LOCKDEP
/*
 * Returns the next chain_key iteration
 */
static u64 print_chain_key_iteration(u16 hlock_id, u64 chain_key)
{
	u64 new_chain_key = iterate_chain_key(chain_key, hlock_id);

	printk(" hlock_id:%d -> chain_key:%016Lx",
		(unsigned int)hlock_id,
		(unsigned long long)new_chain_key);
	return new_chain_key;
}

static void
print_chain_keys_held_locks(struct task_struct *curr, struct held_lock *hlock_next)
{
	struct held_lock *hlock;
	u64 chain_key = INITIAL_CHAIN_KEY;
	int depth = curr->lockdep_depth;
	int i = get_first_held_lock(curr, hlock_next);

	printk("depth: %u (irq_context %u)\n", depth - i + 1,
		hlock_next->irq_context);
	for (; i < depth; i++) {
		hlock = curr->held_locks + i;
		chain_key = print_chain_key_iteration(hlock_id(hlock), chain_key);

		print_lock(hlock);
	}

	print_chain_key_iteration(hlock_id(hlock_next), chain_key);
	print_lock(hlock_next);
}

static void print_chain_keys_chain(struct lock_chain *chain)
{
	int i;
	u64 chain_key = INITIAL_CHAIN_KEY;
	u16 hlock_id;

	printk("depth: %u\n", chain->depth);
	for (i = 0; i < chain->depth; i++) {
		hlock_id = chain_hlocks[chain->base + i];
		chain_key = print_chain_key_iteration(hlock_id, chain_key);

		print_lock_name(lock_classes + chain_hlock_class_idx(hlock_id));
		printk("\n");
	}
}

static void print_collision(struct task_struct *curr,
			struct held_lock *hlock_next,
			struct lock_chain *chain)
{
	pr_warn("\n");
	pr_warn("============================\n");
	pr_warn("WARNING: chain_key collision\n");
	print_kernel_ident();
	pr_warn("----------------------------\n");
	pr_warn("%s/%d: ", current->comm, task_pid_nr(current));
	pr_warn("Hash chain already cached but the contents don't match!\n");

	pr_warn("Held locks:");
	print_chain_keys_held_locks(curr, hlock_next);

	pr_warn("Locks in cached chain:");
	print_chain_keys_chain(chain);

	pr_warn("\nstack backtrace:\n");
	dump_stack();
}
#endif

/*
 * Checks whether the chain and the current held locks are consistent
 * in depth and also in content. If they are not it most likely means
 * that there was a collision during the calculation of the chain_key.
 * Returns: 0 not passed, 1 passed
 */
static int check_no_collision(struct task_struct *curr,
			struct held_lock *hlock,
			struct lock_chain *chain)
{
#ifdef CONFIG_DEBUG_LOCKDEP
	int i, j, id;

	i = get_first_held_lock(curr, hlock);

	if (DEBUG_LOCKS_WARN_ON(chain->depth != curr->lockdep_depth - (i - 1))) {
		print_collision(curr, hlock, chain);
		return 0;
	}

	for (j = 0; j < chain->depth - 1; j++, i++) {
		id = hlock_id(&curr->held_locks[i]);

		if (DEBUG_LOCKS_WARN_ON(chain_hlocks[chain->base + j] != id)) {
			print_collision(curr, hlock, chain);
			return 0;
		}
	}
#endif
	return 1;
}

/*
 * Given an index that is >= -1, return the index of the next lock chain.
 * Return -2 if there is no next lock chain.
 */
long lockdep_next_lockchain(long i)
{
	i = find_next_bit(lock_chains_in_use, ARRAY_SIZE(lock_chains), i + 1);
	return i < ARRAY_SIZE(lock_chains) ? i : -2;
}

unsigned long lock_chain_count(void)
{
	return bitmap_weight(lock_chains_in_use, ARRAY_SIZE(lock_chains));
}

/* Must be called with the graph lock held. */
static struct lock_chain *alloc_lock_chain(void)
{
	int idx = find_first_zero_bit(lock_chains_in_use,
				      ARRAY_SIZE(lock_chains));

	if (unlikely(idx >= ARRAY_SIZE(lock_chains)))
		return NULL;
	__set_bit(idx, lock_chains_in_use);
	return lock_chains + idx;
}

/*
 * Adds a dependency chain into chain hashtable. And must be called with
 * graph_lock held.
 *
 * Return 0 if fail, and graph_lock is released.
 * Return 1 if succeed, with graph_lock held.
 */
static inline int add_chain_cache(struct task_struct *curr,
				  struct held_lock *hlock,
				  u64 chain_key)
{
	struct hlist_head *hash_head = chainhashentry(chain_key);
	struct lock_chain *chain;
	int i, j;

	/*
	 * The caller must hold the graph lock, ensure we've got IRQs
	 * disabled to make this an IRQ-safe lock.. for recursion reasons
	 * lockdep won't complain about its own locking errors.
	 */
	if (lockdep_assert_locked())
		return 0;

	chain = alloc_lock_chain();
	if (!chain) {
		if (!debug_locks_off_graph_unlock())
			return 0;

		print_lockdep_off("BUG: MAX_LOCKDEP_CHAINS too low!");
		dump_stack();
		return 0;
	}
	chain->chain_key = chain_key;
	chain->irq_context = hlock->irq_context;
	i = get_first_held_lock(curr, hlock);
	chain->depth = curr->lockdep_depth + 1 - i;

	BUILD_BUG_ON((1UL << 24) <= ARRAY_SIZE(chain_hlocks));
	BUILD_BUG_ON((1UL << 6)  <= ARRAY_SIZE(curr->held_locks));
	BUILD_BUG_ON((1UL << 8*sizeof(chain_hlocks[0])) <= ARRAY_SIZE(lock_classes));

	j = alloc_chain_hlocks(chain->depth);
	if (j < 0) {
		if (!debug_locks_off_graph_unlock())
			return 0;

		print_lockdep_off("BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!");
		dump_stack();
		return 0;
	}

	chain->base = j;
	for (j = 0; j < chain->depth - 1; j++, i++) {
		int lock_id = hlock_id(curr->held_locks + i);

		chain_hlocks[chain->base + j] = lock_id;
	}
	chain_hlocks[chain->base + j] = hlock_id(hlock);
	hlist_add_head_rcu(&chain->entry, hash_head);
	debug_atomic_inc(chain_lookup_misses);
	inc_chains(chain->irq_context);

	return 1;
}

/*
 * Look up a dependency chain. Must be called with either the graph lock or
 * the RCU read lock held.
 */
static inline struct lock_chain *lookup_chain_cache(u64 chain_key)
{
	struct hlist_head *hash_head = chainhashentry(chain_key);
	struct lock_chain *chain;

	hlist_for_each_entry_rcu(chain, hash_head, entry) {
		if (READ_ONCE(chain->chain_key) == chain_key) {
			debug_atomic_inc(chain_lookup_hits);
			return chain;
		}
	}
	return NULL;
}

/*
 * If the key is not present yet in dependency chain cache then
 * add it and return 1 - in this case the new dependency chain is
 * validated. If the key is already hashed, return 0.
 * (On return with 1 graph_lock is held.)
 */
static inline int lookup_chain_cache_add(struct task_struct *curr,
					 struct held_lock *hlock,
					 u64 chain_key)
{
	struct lock_class *class = hlock_class(hlock);
	struct lock_chain *chain = lookup_chain_cache(chain_key);

	if (chain) {
cache_hit:
		if (!check_no_collision(curr, hlock, chain))
			return 0;

		if (very_verbose(class)) {
			printk("\nhash chain already cached, key: "
					"%016Lx tail class: [%px] %s\n",
					(unsigned long long)chain_key,
					class->key, class->name);
		}

		return 0;
	}

	if (very_verbose(class)) {
		printk("\nnew hash chain, key: %016Lx tail class: [%px] %s\n",
			(unsigned long long)chain_key, class->key, class->name);
	}

	if (!graph_lock())
		return 0;

	/*
	 * We have to walk the chain again locked - to avoid duplicates:
	 */
	chain = lookup_chain_cache(chain_key);
	if (chain) {
		graph_unlock();
		goto cache_hit;
	}

	if (!add_chain_cache(curr, hlock, chain_key))
		return 0;

	return 1;
}

static int validate_chain(struct task_struct *curr,
			  struct held_lock *hlock,
			  int chain_head, u64 chain_key)
{
	/*
	 * Trylock needs to maintain the stack of held locks, but it
	 * does not add new dependencies, because trylock can be done
	 * in any order.
	 *
	 * We look up the chain_key and do the O(N^2) check and update of
	 * the dependencies only if this is a new dependency chain.
	 * (If lookup_chain_cache_add() return with 1 it acquires
	 * graph_lock for us)
	 */
	if (!hlock->trylock && hlock->check &&
	    lookup_chain_cache_add(curr, hlock, chain_key)) {
		/*
		 * Check whether last held lock:
		 *
		 * - is irq-safe, if this lock is irq-unsafe
		 * - is softirq-safe, if this lock is hardirq-unsafe
		 *
		 * And check whether the new lock's dependency graph
		 * could lead back to the previous lock:
		 *
		 * - within the current held-lock stack
		 * - across our accumulated lock dependency records
		 *
		 * any of these scenarios could lead to a deadlock.
		 */
		/*
		 * The simple case: does the current hold the same lock
		 * already?
		 */
		int ret = check_deadlock(curr, hlock);

		if (!ret)
			return 0;
		/*
		 * Add dependency only if this lock is not the head
		 * of the chain, and if the new lock introduces no more
		 * lock dependency (because we already hold a lock with the
		 * same lock class) nor deadlock (because the nest_lock
		 * serializes nesting locks), see the comments for
		 * check_deadlock().
		 */
		if (!chain_head && ret != 2) {
			if (!check_prevs_add(curr, hlock))
				return 0;
		}

		graph_unlock();
	} else {
		/* after lookup_chain_cache_add(): */
		if (unlikely(!debug_locks))
			return 0;
	}

	return 1;
}
#else
static inline int validate_chain(struct task_struct *curr,
				 struct held_lock *hlock,
				 int chain_head, u64 chain_key)
{
	return 1;
}

static void init_chain_block_buckets(void)	{ }
#endif /* CONFIG_PROVE_LOCKING */

/*
 * We are building curr_chain_key incrementally, so double-check
 * it from scratch, to make sure that it's done correctly:
 */
static void check_chain_key(struct task_struct *curr)
{
#ifdef CONFIG_DEBUG_LOCKDEP
	struct held_lock *hlock, *prev_hlock = NULL;
	unsigned int i;
	u64 chain_key = INITIAL_CHAIN_KEY;

	for (i = 0; i < curr->lockdep_depth; i++) {
		hlock = curr->held_locks + i;
		if (chain_key != hlock->prev_chain_key) {
			debug_locks_off();
			/*
			 * We got mighty confused, our chain keys don't match
			 * with what we expect, someone trample on our task state?
			 */
			WARN(1, "hm#1, depth: %u [%u], %016Lx != %016Lx\n",
				curr->lockdep_depth, i,
				(unsigned long long)chain_key,
				(unsigned long long)hlock->prev_chain_key);
			return;
		}

		/*
		 * hlock->class_idx can't go beyond MAX_LOCKDEP_KEYS, but is
		 * it registered lock class index?
		 */
		if (DEBUG_LOCKS_WARN_ON(!test_bit(hlock->class_idx, lock_classes_in_use)))
			return;

		if (prev_hlock && (prev_hlock->irq_context !=
							hlock->irq_context))
			chain_key = INITIAL_CHAIN_KEY;
		chain_key = iterate_chain_key(chain_key, hlock_id(hlock));
		prev_hlock = hlock;
	}
	if (chain_key != curr->curr_chain_key) {
		debug_locks_off();
		/*
		 * More smoking hash instead of calculating it, damn see these
		 * numbers float.. I bet that a pink elephant stepped on my memory.
		 */
		WARN(1, "hm#2, depth: %u [%u], %016Lx != %016Lx\n",
			curr->lockdep_depth, i,
			(unsigned long long)chain_key,
			(unsigned long long)curr->curr_chain_key);
	}
#endif
}

#ifdef CONFIG_PROVE_LOCKING
static int mark_lock(struct task_struct *curr, struct held_lock *this,
		     enum lock_usage_bit new_bit);

static void print_usage_bug_scenario(struct held_lock *lock)
{
	struct lock_class *class = hlock_class(lock);

	printk(" Possible unsafe locking scenario:\n\n");
	printk("       CPU0\n");
	printk("       ----\n");
	printk("  lock(");
	__print_lock_name(class);
	printk(KERN_CONT ");\n");
	printk("  <Interrupt>\n");
	printk("    lock(");
	__print_lock_name(class);
	printk(KERN_CONT ");\n");
	printk("\n *** DEADLOCK ***\n\n");
}

static void
print_usage_bug(struct task_struct *curr, struct held_lock *this,
		enum lock_usage_bit prev_bit, enum lock_usage_bit new_bit)
{
	if (!debug_locks_off() || debug_locks_silent)
		return;

	pr_warn("\n");
	pr_warn("================================\n");
	pr_warn("WARNING: inconsistent lock state\n");
	print_kernel_ident();
	pr_warn("--------------------------------\n");

	pr_warn("inconsistent {%s} -> {%s} usage.\n",
		usage_str[prev_bit], usage_str[new_bit]);

	pr_warn("%s/%d [HC%u[%lu]:SC%u[%lu]:HE%u:SE%u] takes:\n",
		curr->comm, task_pid_nr(curr),
		lockdep_hardirq_context(), hardirq_count() >> HARDIRQ_SHIFT,
		lockdep_softirq_context(curr), softirq_count() >> SOFTIRQ_SHIFT,
		lockdep_hardirqs_enabled(),
		lockdep_softirqs_enabled(curr));
	print_lock(this);

	pr_warn("{%s} state was registered at:\n", usage_str[prev_bit]);
	print_lock_trace(hlock_class(this)->usage_traces[prev_bit], 1);

	print_irqtrace_events(curr);
	pr_warn("\nother info that might help us debug this:\n");
	print_usage_bug_scenario(this);

	lockdep_print_held_locks(curr);

	pr_warn("\nstack backtrace:\n");
	dump_stackƒ'  w  '  w  ±'  F  Ώ'  ‹  Τ'    ή'  L  λ'  M  ώ'  L  (  N  (  r  !(  `  0(  a  Q(  M  d(  L  i(  N  ƒ(  w  ‘(  F  £(  R  »(  ‹  Ν(  ‚  ά(  ƒ  μ(  :  φ(    
)    )  L  )  M  4)  L  9)  N  G)  ‘  T)  R  k)  K  v)  `  …)  a  ‘)  ’  Γ)  w  Ρ)  Y  α)  F  ς)  R  ύ)  ‹  *  L  *  M  .*  :  w*  ”  *  •  ¥*  •  &+  •  h+  L  m+  N  ~+  R  ™+  `  ¬+  a  g,  w  {,  –  ,  Y  ‘,  F  £,  R  Ζ,  G  Λ,  `  μ,  _  ρ,  `  ,-  T  X-  G  c-  a  h-  b  q-  a  |-  R  ‘-  U  Ά-  V  ¬-  W  ³-  X  Θ-  U  ξ-  Y  .  F  -.  R  t.  ™  .    Γ.  `  Ξ.  G  λ.  _  π.  `  ,/  T  X/  G  c/  a  h/  b  q/  a  z/  K  ”/  K  /  R  Ι/  U  Ϊ/  V  δ/  W  λ/  X   0  U  /0  K  _0  ™  α0  Y  ρ0  F  11  R  ¶1    Α1    β1  K  ν1  R  2    "2  _  *2  `  02  G  d2  T  2  G  ›2  a   2  b  ­2    !3  U  23  V  <3  W  C3  X  X3  U  Ί3  o  Ν3  [  ε3  Y  4  F  64  R  r4  G  ¥4  ΅  Σ4    ΰ4    σ4    5  _  
5  `  5  G  D5  T  p5  G  {5  a  €5  b  5    Ό5    Κ5  •  Ϋ5  Ά  π5  K  ϋ5  R  16  U  B6  V  L6  W  S6  X  h6  U  6  Y  ΅6  F  Ώ6  R  7  G  7  _  7  `  T7  T  €7  G  ‹7  a  7  b  ·7  R  Ι7  U  Ϊ7  V  δ7  W  λ7  X   8  U  78  Y  f  K  ϋ  P  (    ³  k  ϋ  k  r  a    N  Ι  k  Τ  a  h$  ‡  $  ‡      @                A                B     	     
      C                D                                                           $     (     ,     0     4     8     <     @     D     H     L     P     T     X     \     `     d     h     l     p     t     x     |     €     „                    ”                     ¤     ¨     ¬     °     ΄     Έ                   S               S                S  $     (     ,   S  0     4     8   S  <     @     D   S  H     L     P   S  T     X     \   S  `     d     h   S                                 $     (     0     4        :     e                                                 $     (     ,     0     4     8     @     `   I        ¤     °     ΐ   Z     ^  @  ]  €  f  Ό    ΐ    ΰ  H     E  \    `    d    h    l    p        D     C     B     A     @   .symtab .strtab .shstrtab .rel.text .data .bss __ksymtab_strings .rel___ksymtab+cgroup_bpf_enabled_key .rel___ksymtab+__cgroup_bpf_run_filter_skb .rel___ksymtab+__cgroup_bpf_run_filter_sk .rel___ksymtab+__cgroup_bpf_run_filter_sock_addr .rel___ksymtab+__cgroup_bpf_run_filter_sock_ops .rel__mcount_loc .rodata.str1.4 .rel__jump_table .rodata.str1.1 .rel__bug_table .rel.text.unlikely .rel.smp_locks .rel.rodata .rel.discard.addressable .comment .note.GNU-stack .note.gnu.property                                                         @   ;8                    	   @       pW  π  #            %             {8      