nnel *audio_ch =
		&dev->sram_channels[AUDIO_SRAM_CHANNEL];

	dprintk(1, "%s()\n", __func__);

	/* Make sure RISC/FIFO are off before changing FIFO/RISC settings */
	cx_clear(AUD_INT_DMA_CTL, 0x11);

	/* setup fifo + format - out channel */
	cx23885_sram_channel_setup(chip->dev, audio_ch, buf->bpl,
		buf->risc.dma);

	/* sets bpl size */
	cx_write(AUD_INT_A_LNGTH, buf->bpl);

	/* This is required to get good audio (1 seems to be ok) */
	cx_write(AUD_INT_A_MODE, 1);

	/* reset counter */
	cx_write(AUD_INT_A_GPCNT_CTL, GP_COUNT_CONTROL_RESET);
	atomic_set(&chip->count, 0);

	dprintk(1, "Start audio DMA, %d B/line, %d lines/FIFO, %d periods, %d byte buffer\n",
		buf->bpl, cx_read(audio_ch->cmds_start+12)>>1,
		chip->num_periods, buf->bpl * chip->num_periods);

	/* Enables corresponding bits at AUD_INT_STAT */
	cx_write(AUDIO_INT_INT_MSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |
				    AUD_INT_DN_RISCI1);

	/* Clean any pending interrupt bits already set */
	cx_write(AUDIO_INT_INT_STAT, ~0);

	/* enable audio irqs */
	cx_set(PCI_INT_MSK, chip->dev->pci_irqmask | PCI_MSK_AUD_INT);

	/* start dma */
	cx_set(DEV_CNTRL2, (1<<5)); /* Enables Risc Processor */
	cx_set(AUD_INT_DMA_CTL, 0x11); /* audio downstream FIFO and
					  RISC enable */
	if (audio_debug)
		cx23885_sram_channel_dump(chip->dev, audio_ch);

	return 0;
}

/*
 * BOARD Specific: Resets audio DMA
 */
static int cx23885_stop_audio_dma(struct cx23885_audio_dev *chip)
{
	struct cx23885_dev *dev = chip->dev;
	dprintk(1, "Stopping audio DMA\n");

	/* stop dma */
	cx_clear(AUD_INT_DMA_CTL, 0x11);

	/* disable irqs */
	cx_clear(PCI_INT_MSK, PCI_MSK_AUD_INT);
	cx_clear(AUDIO_INT_INT_MSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |
				    AUD_INT_DN_RISCI1);

	if (audio_debug)
		cx23885_sram_channel_dump(chip->dev,
			&dev->sram_channels[AUDIO_SRAM_CHANNEL]);

	return 0;
}

/*
 * BOARD Specific: Handles audio IRQ
 */
int cx23885_audio_irq(struct cx23885_dev *dev, u32 status, u32 mask)
{
	struct cx23885_audio_dev *chip = dev->audio_dev;

	if (0 == (status & mask))
		return 0;

	cx_write(AUDIO_INT_INT_STAT, status);

	/* risc op code error */
	if (status & AUD_INT_OPC_ERR) {
		pr_warn("%s/1: Audio risc op code error\n",
			dev->name);
		cx_clear(AUD_INT_DMA_CTL, 0x11);
		cx23885_sram_channel_dump(dev,
			&dev->sram_channels[AUDIO_SRAM_CHANNEL]);
	}
	if (status & AUD_INT_DN_SYNC) {
		dprintk(1, "Downstream sync error\n");
		cx_write(AUD_INT_A_GPCNT_CTL, GP_COUNT_CONTROL_RESET);
		return 1;
	}
	/* risc1 downstream */
	if (status & AUD_INT_DN_RISCI1) {
		atomic_set(&chip->count, cx_read(AUD_INT_A_GPCNT));
		snd_pcm_period_elapsed(chip->substream);
	}
	/* FIXME: Any other status should deserve a special handling? */

	return 1;
}

static int dsp_buffer_free(struct cx23885_audio_dev *chip)
{
	struct cx23885_riscmem *risc;

	BUG_ON(!chip->dma_size);

	dprintk(2, "Freeing buffer\n");
	cx23885_alsa_dma_unmap(chip);
	cx23885_alsa_dma_free(chip->buf);
	risc = &chip->buf->risc;
	dma_free_coherent(&chip->pci->dev, risc->size, risc->cpu, risc->dma);
	kfree(chip->buf);

	chip->buf = NULL;
	chip->dma_size = 0;

	return 0;
}

/****************************************************************************
				ALSA PCM Interface
 ****************************************************************************/

/*
 * Digital hardware definition
 */
#define DEFAULT_FIFO_SIZE	4096

static const struct snd_pcm_hardware snd_cx23885_digital_hw = {
	.info = SNDRV_PCM_INFO_MMAP |
		SNDRV_PCM_INFO_INTERLEAVED |
		SNDRV_PCM_INFO_BLOCK_TRANSFER |
		SNDRV_PCM_INFO_MMAP_VALID,
	.formats = SNDRV_PCM_FMTBIT_S16_LE,

	.rates =		SNDRV_PCM_RATE_48000,
	.rate_min =		48000,
	.rate_max =		48000,
	.channels_min = 2,
	.channels_max = 2,
	/* Analog audio output will be full of clicks and pops if there
	   are not exactly four lines in the SRAM FIFO buffer.  */
	.period_bytes_min = DEFAULT_FIFO_SIZE/4,
	.period_bytes_max = DEFAULT_FIFO_SIZE/4,
	.periods_min = 1,
	.periods_max = 1024,
	.buffer_bytes_max = (1024*1024),
};

/*
 * audio pcm capture open callback
 */
static int snd_cx23885_pcm_open(struct snd_pcm_substream *substream)
{
	struct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);
	struct snd_pcm_runtime *runtime = substream->runtime;
	int err;

	if (!chip) {
		pr_err("BUG: cx23885 can't find device struct. Can't proceed with open\n");
		return -ENODEV;
	}

	err = snd_pcm_hw_constraint_pow2(runtime, 0,
		SNDRV_PCM_HW_PARAM_PERIODS);
	if (err < 0)
		goto _error;

	chip->substream = substream;

	runtime->hw = snd_cx23885_digital_hw;

	if (chip->dev->sram_channels[AUDIO_SRAM_CHANNEL].fifo_size !=
		DEFAULT_FIFO_SIZE) {
		unsigned int bpl = chip->dev->
			sram_channels[AUDIO_SRAM_CHANNEL].fifo_size / 4;
		bpl &= ~7; /* must be multiple of 8 */
		runtime->hw.period_bytes_min = bpl;
		runtime->hw.period_bytes_max = bpl;
	}

	return 0;
_error:
	dprintk(1, "Error opening PCM!\n");
	return err;
}

/*
 * audio close callback
 */
static int snd_cx23885_close(struct snd_pcm_substream *substream)
{
	return 0;
}


/*
 * hw_params callback
 */
static int snd_cx23885_hw_params(struct snd_pcm_substream *substream,
			      struct snd_pcm_hw_params *hw_params)
{
	struct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);
	struct cx23885_audio_buffer *buf;
	int ret;

	if (substream->runtime->dma_area) {
		dsp_buffer_free(chip);
		substream->runtime->dma_area = NULL;
	}

	chip->period_size = params_period_bytes(hw_params);
	chip->num_periods = params_periods(hw_params);
	chip->dma_size = chip->period_size * params_periods(hw_params);

	BUG_ON(!chip->dma_size);
	BUG_ON(chip->num_periods & (chip->num_periods-1));

	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
	if (NULL == buf)
		return -ENOMEM;

	buf->bpl = chip->period_size;
	chip->buf = buf;

	ret = cx23885_alsa_dma_init(chip,
			(PAGE_ALIGN(chip->dma_size) >> PAGE_SHIFT));
	if (ret < 0)
		goto error;

	ret = cx23885_alsa_dma_map(chip);
	if (ret < 0)
		goto error;

	ret = cx23885_risc_databuffer(chip->pci, &buf->risc, buf->sglist,
				   chip->period_size, chip->num_periods, 1);
	if (ret < 0)
		goto error;

	/* Loop back to start of program */
	buf->risc.jmp[0] = cpu_to_le32(RISC_JUMP|RISC_IRQ1|RISC_CNT_INC);
	buf->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
	buf->risc.jmp[2] = cpu_to_le32(0); /* bits 63-32 */

	substream->runtime->dma_area = chip->buf->vaddr;
	substream->runtime->dma_bytes = chip->dma_size;
	substream->runtime->dma_addr = 0;

	return 0;

error:
	kfree(buf);
	chip->buf = NULL;
	return ret;
}

/*
 * hw free callback
 */
static int snd_cx23885_hw_free(struct snd_pcm_substream *substream)
{

	struct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);

	if (substream->runtime->dma_area) {
		dsp_buffer_free(chip);
		substream->runtime->dma_area = NULL;
	}

	return 0;
}

/*
 * prepare callback
 */
static int snd_cx23885_prepare(struct snd_pcm_substream *substream)
{
	return 0;
}

/*
 * trigger callback
 */
static int snd_cx23885_card_trigger(struct snd_pcm_substream *substream,
	int cmd)
{
	struct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);
	int err;

	/* Local interrupts are already disabled by ALSA */
	spin_lock(&chip->lock);

	switch (cmd) {
	case SNDRV_PCM_TRIGGER_START:
		err = cx23885_start_audio_dma(chip);
		break;
	case SNDRV_PCM_TRIGGER_STOP:
		err = cx23885_stop_audio_dma(chip);
		break;
	default:
		err = -EINVAL;
		break;
	}

	spin_unlock(&chip->lock);

	return err;
}

/*
 * pointer callback
 */
static snd_pcm_uframes_t snd_cx23885_pointer(
	struct snd_pcm_substream *substream)
{
	struct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);
	struct snd_pcm_runtime *runtime = substream->runtime;
	u16 count;

	count = atomic_read(&chip->count);

	return runtime->period_size * (count & (runtime->periods-1));
}

/*
 * page callback (needed for mmap)
 */
static struct page *snd_cx23885_page(struct snd_pcm_substream *substream,
				unsigned long offset)
{
	void *pageptr = substream->runtime->dma_area + offset;
	return vmalloc_to_page(pageptr);
}

/*
 * operators
 */
static const struct snd_pcm_ops snd_cx23885_pcm_ops = {
	.open = snd_cx23885_pcm_open,
	.close = snd_cx23885_close,
	.hw_params = snd_cx23885_hw_params,
	.hw_free = snd_cx23885_hw_free,
	.prepare = snd_cx23885_prepare,
	.trigger = snd_cx23885_card_trigger,
	.pointer = snd_cx23885_pointer,
	.page = snd_cx23885_page,
};

/*
 * create a PCM device
 */
static int snd_cx23885_pcm(struct cx23885_audio_dev *chip, int device,
	char *name)
{
	int err;
	struct snd_pcm *pcm;

	err = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);
	if (err < 0)
		return err;
	pcm->private_data = chip;
	strscpy(pcm->name, name, sizeof(pcm->name));
	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cx23885_pcm_ops);

	return 0;
}

/****************************************************************************
			Basic Flow for Sound Devices
 ****************************************************************************/

/*
 * Alsa Constructor - Component probe
 */

struct cx23885_audio_dev *cx23885_audio_register(struct cx23885_dev *dev)
{
	struct snd_card *card;
	struct cx23885_audio_dev *chip;
	int err;

	if (disable_analog_audio)
		return NULL;

	if (dev->sram_channels[AUDIO_SRAM_CHANNEL].cmds_start == 0) {
		pr_warn("%s(): Missing SRAM channel configuration for analog TV Audio\n",
		       __func__);
		return NULL;
	}

	err = snd_card_new(&dev->pci->dev,
			   SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
			THIS_MODULE, sizeof(struct cx23885_audio_dev), &card);
	if (err < 0)
		goto error_msg;

	chip = (struct cx23885_audio_dev *) card->private_data;
	chip->dev = dev;
	chip->pci = dev->pci;
	chip->card = card;
	spin_lock_init(&chip->lock);

	err = snd_cx23885_pcm(chip, 0, "CX23885 Digital");
	if (err < 0)
		goto error;

	strscpy(card->driver, "CX23885", sizeof(card->driver));
	sprintf(card->shortname, "Conexant CX23885");
	sprintf(card->longname, "%s at %s", card->shortname, dev->name);

	err = snd_card_register(card);
	if (err < 0)
		goto error;

	dprintk(0, "registered ALSA audio device\n");

	return chip;

error:
	snd_card_free(card);
error_msg:
	pr_err("%s(): Failed to register analog audio adapter\n",
	       __func__);

	return NULL;
}

/*
 * ALSA destructor
 */
void cx23885_audio_unregister(struct cx23885_dev *dev)
{
	struct cx23885_audio_dev *chip = dev->audio_dev;

	snd_card_free(chip->card);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
t>\J$XdL=CV=p<]^qyBXBt=m 2"6DbO1b3z=8,Bp5e/OfױI=J;v&/o)H`JTڑ?>f!hS5$7)2%`|-o0$yq֊rp>μfmYJ\YsbɄuCޅw^K]3#C}X9XVt>"Noo#%s/iq`r@ 7^]sA~0~ݔ/(P+P` z0Ey\M؇J^̔ҬVi' kS{bR|)87rvzW%H(>~a._ϕ"WƹB?0l@P[xD`T$:ڌ|!#.}_SËvds~EjW뿏8<-,*ʡwJ-|ApȦ!Ut
Wh t/%Mk^/u$yRnd" ).،+[-	'Xn$IL8\B+6Qڢa<HrtX"b38
#9(	^\t~'dU1c(|VMAǋ6VZGff\>{IQA(z׍XY$Cl; 9X4hkTelq C)^GeJQ,s(ca-+[Z¿)M{<8EFb-{Xxדi}<xn-IoT^˄ ZDrcP@X#:WOe9U%ɦ;V"ݰ$U$*>s󫥑~IᄼDSBoc=%s5}ٰi|Z?Ul\41ӔqG%J >Zn:{B.T59_	gg}&b-CG]aJ6W&$#N0q炦\xJҠU%FX(zaܸ 17xnsu\#V'Pឈk
33A	Ԣ>|	6An5g		d &G/K1oׄnbwF_FE8|Ϥb~΃i2fg8Ԥ ߨ?Aץ>X/~\6իk*CւQ!,,ܿ	-/jοiT|5:dJQ!tqy3y5yfDP^U?W~A%'+&toQlW EKL7+eo WT!YٓG5#唒?;w-DpRipIhwy^0\z[Z(Osih4R}[J=JN[h^䃭T;Ӛ´|6	!djG-vsֶ:' \ce2ea{W
y>	UZ򈠄g'ACy#q;قM7(A	NWN~wҴSB,{**5X UV	XI
3tCd։@jSRZ+s<B_HiBEUȲ:0k	JNM''I^w̮H+&ka![幨9*_7n8Fne%n,h'VxK㨏
1"gCCO+7rl.;	Z<NPir8gPX@ "`sғGyf=}9m/C<
)4{o27uc *FW[1(q!uDر?TT*+OcTA>8#Zh$-]NY8!w/u9'>Ngt2I3E1TyjxF"bGw㐧zJxTCXȉALlQ"YrS_T(| 0WSL,Xs,2gImB644&7|A{kppE+ݫx\ؚ^Ė"19R6AsU~Ji&
aOyxIOꢫA
aiè5_ɫuf>XoJydRh˰T*k~v|[U|U;%kK4}VeZ*εY
DΒN@fRZ76RUmc&:[CFDEױ'ئ	4*M\G_p`/@Ѥ57#~'#J[ܵFΗےѧǧ 7t~셀8	;e6<X6UyGl<sb3tU
!r7Cd轼AFfc~	:u[r7EzPU9'뉅[$;=#FP #yI-8{b~Hލ#nr،Zy^'䒬`䃀6kL0((>|yD<uL~^o*2`_MsTBLjד1#[G
#0w*L}:]'OlbbkKP}\F챇ȾD^gȜ#qj'q_Nqp?5W\5ƔYoXSy<PFA<J}
 H8Vc!-&wUjg!8w!"DT_ik*<z	%[9ϯvV)ЕWa.ӄk:x[	jZg[SCJ+$|eek89? TExՉ@vL;猚ʽU|aIMnGJTBS3e!SH%K68ӫp䏂AV>Օ]j[4@2oJ+w4!kg\UhsKh_4Z}@7/K<Ҳބ|6(f߸BI갧=LkĂY-цlk"f&i%a팾#ψ?yf:K76OM3UFKk+ZU=UIEUk80'7,z^+7ISEQ/
Ca1O=vư7tҿ]F׿$+aŵ'@p\x%%.}bOalvk9t%I''XV}2ؠc
`C+U#s`(j+u~C9?"(OK;.+d*нNDai
K+$pyWF@?<p篧Mc3)֟QCyЩ{񷶗9MG/I4,Cx0qW4g.Yrn{ֿSu,,Σu6- eO_jsׅc,Ŀ\̯9cQr?(<=F/g!@\bQ@As]9HkPPSf`7IֶlDFV:"zʷ	X($ki2 ?kfF! t@WMUMWIMS'Pb:s}aj|v(.;(61JggKO寮H
4m	k4nT`0[
gJjU1~iO9
Aj}Im,V>.%c 1ey'.SRrP,[
XZG^ 0s<[#=mZhusϒbׅYsTy|TX`wȣP
tgu|E|ܺp̲eIK7GRB(%2ГLXctR*Hv4^W13-%8yVwodh&vx߂A,Qd hNR.p54u|Q{,}.uh.,̆&ʾx@΀LQ:fes7x =M U
fDsAaNy
@555IsENYY o5CHP,Nu:+X_y^X+2Mv~X,:dgHJr:j@h˴W嵵 I@E(d#}꼉K%͡ GP{*jNqTg#[Jo=t:0h)kd!yT}{HR	N~hpy+NO<G#]SQTROP+U_n[ϒ|ZmgLk13u¾usk<Ӛ*qƨ8vW0If?:n(^#k"y_u7xí' R+!uT[u )yw"xd	q`_k/}1Yd@\_硾АS$Z)-~  hu vБGfJ ]} ;GUHr@^,!q͡᭪g6)w [f]siaQdףQGYSA &TSGU F!Mt(AvXJ}L'* +/2ܓA 
(.`W/C0FktmV,o_oG珱hNywb(PDfN#~@݊YjE>T>ԼmG`#p7rwCT[) 	a_MY}')K̡K~û'"]'[#6؋䴽ͻKXCKԆ03~r؍w`d>g,~_չ_>º)aD[yܦ=v/86oS f	d?%(P8b.jkqV`T[,/"Z7yj	fyǢ;>,@.WxcR4tMSg+ߞ% i"z!<>(ȶJǛ٫S`݊FEJƕpwޢ(Wήkd#r nWg/wdfP0%u$`߿?-~SN8w.m)f{H evWp.fJDߕ6;YݔTtDs'Z>ʦ?iA
OϹաgٰr	9!Єv+=x}kbk+q)t@i[Q+"vk:~`Smn6xQ yf-_'/=^Qn㿍084i_d)(-;:&4ZbslW7d@'?={ $hݤU?ٯB^HAͧLx[w3_(Kyo:}NҴDږUاuF :,d9}eYW:.3ES$sf2ѹ65g}u2acu2IB;^0qj^0Hft9{(G,\'bzȮ}s'SCZ 4سn`bqd𐊪8\G.e4E_Kn2ilj7shvXqX%lV	fv\)(M>?*a;K:h$Tש/&&ƊHR@{d~mBijedY(	kN</<vzfD%#o>CcF1?t$a1gD5uhIJĠ@5
@g!I;fO_?7zNZz7(|"\BPC0jȆU]ǭ3Sڊ\	 |9v?I
YY1m8-Ju58@T	#`\[!ceM_}{ߧi)O0%؄:dGiOHYNgOC2ɤ|¾ͲR#`lUԡ=eXD|]oLm)o]` llyG7rK8/Z8h弦ػY:䛳t4ʅI	q9%vR#%YߔoPئjѾVTmEKxKd(Gh*pTaO_R1OjNͫl0;mO/,"kS⃃8ě[X"!h=c@NQ 6	pZ E3@^'%U]eG'OkD[@} sxkOjxsT%p"SMZ7B|
mLa!'sQ5:5||+$/'w|;o QJw廄5[IM4hahw~b|@Hd3=
[Gh`Z y9k)`B4"^َ z\AÐV? {v|[Ġzrud](Ʉ@Em-Jy<Z{<埽r؋>5)B7z !34tpU9L71{z=D~f*
Y+Ѡfk$XLPxb4K*0|84xw@%g~GP?g._0|1<7E3tm}tK\En_JԌ7WЕx} Äɂi)͘puDa:py"rs.C=:xiTҜ4galet_s]$K;mded@GxiLw6sKqg^!*Ǜh4X{\%9tqB468zֳ+PΞgm}VhZNߥ@8ezM?/J#ldL76ΘE$Kl2Lj?FSAt_yX-pUO~m65EWKKgqGڜ'6/u/Æp_AHuQ:FJSՆb" dN.1cl(G e""j
ߛ  |]nFݲ.ul̥VQ!穛(4S["gx>Br ن4H+ UIK{k?
!Cp5y{@§sxS 5g?2l^S*;%ʥE18o֔ƃ#=^31{L<%+UNe\JkBt|喾n0eg-'ؑr9BtvW(6[߀8@݌Za/,_!׻0