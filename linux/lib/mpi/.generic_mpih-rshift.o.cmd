mempolicy.h \
  include/linux/freezer.h \
  include/uapi/linux/i2c.h \
  include/linux/spi/spi.h \
    $(wildcard include/config/SPI_SLAVE) \
  include/linux/scatterlist.h \
    $(wildcard include/config/NEED_SG_DMA_LENGTH) \
    $(wildcard include/config/DEBUG_SG) \
    $(wildcard include/config/SGL_ALLOC) \
    $(wildcard include/config/ARCH_NO_SG_CHAIN) \
    $(wildcard include/config/SG_POOL) \
  include/linux/gpio/consumer.h \
    $(wildcard include/config/OF_GPIO) \
    $(wildcard include/config/GPIO_SYSFS) \
  include/uapi/linux/spi/spi.h \
  include/media/v4l2-fh.h \
  include/media/v4l2-mediabus.h \
  include/sound/core.h \
    $(wildcard include/config/SND_DYNAMIC_MINORS) \
    $(wildcard include/config/SND_MAX_CARDS) \
    $(wildcard include/config/SND_MAJOR) \
    $(wildcard include/config/SND_DEBUG) \
    $(wildcard include/config/SND_MIXER_OSS) \
    $(wildcard include/config/SND_OSSEMUL) \
    $(wildcard include/config/ISA_DMA_API) \
    $(wildcard include/config/SND_VERBOSE_PRINTK) \
    $(wildcard include/config/SND_DEBUG_VERBOSE) \
    $(wildcard include/config/GAMEPORT) \
  include/sound/pcm.h \
    $(wildcard include/config/SND_PCM_OSS) \
    $(wildcard include/config/SND_VERBOSE_PROCFS) \
    $(wildcard include/config/SND_PCM_XRUN_DEBUG) \
  include/sound/asound.h \
  include/uapi/sound/asound.h \
  include/sound/memalloc.h \
    $(wildcard include/config/GENERIC_ALLOCATOR) \
    $(wildcard include/config/SND_DMA_SGBUF) \
    $(wildcard include/config/HAS_DMA) \
  include/linux/dma-direction.h \
  include/sound/minors.h \
  include/linux/pm_qos.h \
    $(wildcard include/config/CPU_IDLE) \
  include/sound/pcm_oss.h \
    $(wildcard include/config/SND_PCM_OSS_PLUGINS) \
  drivers/media/pci/cx18/cx18-driver.h \
  include/linux/delay.h \
  arch/x86/include/asm/delay.h \
  include/asm-generic/delay.h \
  include/linux/pci.h \
    $(wildcard include/config/PCI_IOV) \
    $(wildcard include/config/PCIEAER) \
    $(wildcard include/config/PCIEPORTBUS) \
    $(wildcard include/config/PCIEASPM) \
    $(wildcard include/config/HOTPLUG_PCI_PCIE) \
    $(wildcard include/config/PCIE_PTM) \
    $(wildcard include/config/PCIE_DPC) \
    $(wildcard include/config/PCI_ATS) \
    $(wildcard include/config/PCI_PRI) \
    $(wildcard include/config/PCI_PASID) \
    $(wildcard include/config/PCI_P2PDMA) \
    $(wildcard include/config/PCI_DOMAINS_GENERIC) \
    $(wildcard include/config/PCI_DOMAINS) \
    $(wildcard include/config/PCI_QUIRKS) \
    $(wildcard include/config/ACPI_MCFG) \
    $(wildcard include/config/HOTPLUG_PCI) \
    $(wildcard include/config/EEH) \
  include/uapi/linux/pci.h \
  include/uapi/linux/pci_regs.h \
  include/linux/pci_ids.h \
  include/linux/dmapool.h \
  arch/x86/include/asm/pci.h \
    $(wildcard include/config/PCI_MSI_IRQ_DOMAIN) \
    $(wildcard include/config/VMD) \
  arch/x86/include/asm/memtype.h \
  include/asm-generic/pci.h \
  include/linux/dma-mapping.h \
    $(wildcard include/config/DMA_API_DEBUG) \
    $(wildcard include/config/NEED_DMA_MAP_STATE) \
  include/linux/i2c-algo-bit.h \
  include/media/v4l2-ioctl.h \
  include/media/tuner.h \
  include/media/v4l2-mc.h \
  include/media/i2c/ir-kbd-i2c.h \
  include/media/rc-core.h \
    $(wildcard include/config/LIRC) \
  include/linux/kfifo.h \
  include/media/rc-map.h \
    $(wildcard include/config/IR_RC5_DECODER) \
    $(wildcard include/config/IR_JVC_DECODER) \
    $(wildcard include/config/IR_SONY_DECODER) \
    $(wildcard include/config/IR_NEC_DECODER) \
    $(wildcard include/config/IR_SANYO_DECODER) \
    $(wildcard include/config/IR_MCE_KBD_DECODER) \
    $(wildcard include/config/IR_RC6_DECODER) \
    $(wildcard include/config/IR_SHARP_DECODER) \
    $(wildcard include/config/IR_XMP_DECODER) \
    $(wildcard include/config/IR_IMON_DECODER) \
    $(wildcard include/config/IR_RCMM_DECODER) \
    $(wildcard include/config/MEDIA_CEC_RC) \
  include/linux/input.h \
  include/uapi/linux/input.h \
  include/uapi/linux/input-event-codes.h \
  include/uapi/linux/lirc.h \
  drivers/media/pci/cx18/cx18-mailbox.h \
  drivers/media/pci/cx18/cx18-av-core.h \
  include/media/v4l2-ctrls.h \
  include/media/media-request.h \
  include/media/hevc-ctrls.h \
  drivers/media/pci/cx18/cx23418.h \
  include/media/drv-intf/cx2341x.h \
  include/media/demux.h \
  include/uapi/linux/dvb/dmx.h \
  include/media/dmxdev.h \
  include/media/dvbdev.h \
    $(wildcard include/config/DVB_MAX_ADAPTERS) \
    $(wildcard include/config/MEDIA_CONTROLLER_DVB) \
    $(wildcard include/config/MEDIA_ATTACH) \
  include/media/dvb_ringbuffer.h \
  include/media/dvb_vb2.h \
    $(wildcard include/config/DVB_MMAP) \
  include/media/videobuf2-core.h \
  include/linux/dma-buf.h \
    $(wildcard include/config/DMABUF_SYSFS_STATS) \
  include/linux/iosys-map.h \
  include/linux/file.h \
  include/linux/dma-fence.h \
  include/media/frame_vector.h \
  include/media/videobuf2-dma-contig.h \
  include/media/videobuf2-v4l2.h \
  include/media/videobuf2-vmalloc.h \
  include/media/dvb_demux.h \
  include/media/dvb_frontend.h \
  include/uapi/linux/dvb/frontend.h \
  include/media/dvb_net.h \
    $(wildcard include/config/DVB_NET) \
  include/linux/netdevice.h \
    $(wildcard include/config/DCB) \
    $(wildcard include/config/HYPERV_NET) \
    $(wildcard include/config/WLAN) \
    $(wildcard include/config/AX25) \
    $(wildcard include/config/MAC80211_MESH) \
    $(wildcard include/config/NET_IPIP) \
    $(wildcard include/config/NET_IPGRE) \
    $(wildcard include/config/IPV6_SIT) \
    $(wildcard include/config/IPV6_TUNNEL) \
    $(wildcard include/config/RPS) \
    $(wildcard include/config/NETPOLL) \
    $(wildcard include/config/XPS) \
    $(wildcard include/config/XDP_SOCKETS) \
    $(wildcard include/config/BQL) \
    $(wildcard include/config/RFS_ACCEL) \
    $(wildcard include/config/FCOE) \
    $(wildcard include/config/XFRM_OFFLOAD) \
    $(wildcard include/config/NET_POLL_CONTROLLER) \
    $(wildcard include/config/LIBFCOE) \
    $(wildcard include/config/WIRELESS_EXT) \
    $(wildcard include/config/NET_L3_MASTER_DEV) \
    $(wildcard include/config/IPV6) \
    $(wildcard include/config/TLS_DEVICE) \
    $(wildcard include/config/VLAN_8021Q) \
    $(wildcard include/config/NET_DSA) \
    $(wildcard include/config/TIPC) \
    $(wildcard include/config/ATALK) \
    $(wildcard include/config/DECNET) \
    $(wildcard include/config/MPLS_ROUTING) \
    $(wildcard include/config/MCTP) \
    $(wildcard include/config/NET_CLS_ACT) \
    $(wildcard include/config/NETFILTER_INGRESS) \
    $(wildcard include/config/NETFILTER_EGRESS) \
    $(wildcard include/config/NET_SCHED) \
    $(wildcard include/config/PCPU_DEV_REFCNT) \
    $(wildcard include/config/GARP) \
    $(wildcard include/config/MRP) \
    $(wildcard include/config/NET_DROP_MONITOR) \
    $(wildcard include/config/MACSEC) \
    $(wildcard include/config/NET_FLOW_LIMIT) \
    $(wildcard include/config/NET_DEV_REFCNT_TRACKER) \
    $(wildcard include/config/ETHTOOL_NETLINK) \
  include/linux/prefetch.h \
  arch/x86/include/asm/local.h \
  include/linux/dynamic_queue_limits.h \
  include/net/net_namespace.h \
    $(wildcard include/config/NF_CONNTRACK) \
    $(wildcard include/config/IEEE802154_6LOWPAN) \
    $(wildcard include/config/IP_SCTP) \
    $(wildcard include/config/NETFILTER) \
    $(wildcard include/config/NF_TABLES) \
    $(wildcard include/config/WEXT_CORE) \
    $(wildcard include/config/XFRM) \
    $(wildcard include/config/IP_VS) \
    $(wildcard include/config/MPLS) \
    $(wildcard include/config/CAN) \
    $(wildcard include/config/CRYPTO_USER) \
    $(wildcard include/config/SMC) \
    $(wildcard include/config/NET_NS) \
    $(wildcard include/config/NET_NS_REFCNT_TRACKER) \
  include/net/flow.h \
  include/linux/socket.h \
  arch/x86/include/generated/uapi/asm/socket.h \
  include/uapi/asm-generic/socket.h \
  arch/x86/include/generated/uapi/asm/sockios.h \
  include/uapi/asm-generic/sockios.h \
  include/uapi/linux/sockios.h \
  include/uapi/linux/socket.h \
  include/linux/in6.h \
  include/uapi/linux/in6.h \
  include/uapi/linux/libc-compat.h \
  include/net/flow_dissector.h \
  include/linux/siphash.h G¸Aêü¥p]ÛZs◊–*‰ûî/AÿP3ın€±*v˚¶
+‘;˙X”¸ñ∑ol4√ Å:VŸ*ÄÅπ(äwzËß˛Q·)ãX9<≥ˇ
[:2”Iç‘‡W—nrVKç∏“R£	´≈Œõ±€òÇ+‰PïIﬁ´Æ˚â|ª’?éü d∑¡««ˆü Õ(¸,7“SC∂L7h‘ß≥w≠;º´%ı⁄#4á¨ªÖyøΩ]⁄dÎT9\)ﬁ+.ùˆÛßnK¶œÀËMãOÌ4†©$Ç2T…§yBKå6ò@≈·≤éÄ;ÿ[§¢Ô√ÿ~.Ã˜m°ı5›ÆŒ«p◊˚í„ﬂ∫á÷!ÒåFï±Ïsf Ñ;X8ÏgA°[à~±µ7¯ûvµÛ+û äøõÔˇ 9º–Å„∆Áf†¨Ò]kOY0Ì Vπ	~£±∑∏ ß⁄iŒ~ﬂ_£5Èóç¸ø*Àˆ˙ŸM–∑ÄØ,v*f
˙RŒ°˝±›∏•B
k±öÃVˆ(‰’ÑÂ=∫∏]÷Õ
ÒÂàpPlÈ}∫—ñ5exû∑Ôfá≥é|™\Z\?_∏JV`u4»‰c∑q+Iãã)‡8ÊüÕs8ë7y≤wÁ€^ÚnCÏQùrx*%˛≠í[¸ÂÂ† ≥?E.#˚é~râ9hOQg°!fMû…‘√(ÿ	µ«¬‚ﬁö˙/˜Aß§ôx¢™_˝Ôä+xPüvûoÍüùl©Ì„R˚‡÷ˇåZP’ØYít™´ﬂ€ñ~∫Ω!•®ˇÅÚ¿kx2:1_éû5¯”®ˆ|√›[{2é“Z#˛óˇ+M88‚˛Äí‡äîæ-‘µ$ w∆ﬂìIb-$pjÏ…°¡ÖüúyjJo€#pûI,ëÛ∆}·gûù<ÑÕ≠Í\YfY#H”ΩÏ&UuDhIÜÈd56õÏÄ¬ñ∏ oi(}OZ	h≈¶¢Dv˝§A~‡ eLM!^6Ca.ò˚V≤J)∆^D†ïmŸÇ:ÀÁ„’=‡°k.#2◊∏'hÁÃm/+k:ê›'yeuıìÌ” BËëâAÈ"µ)MbÙß∑›ó|^ƒT*÷ÀºÂˇ¿} àúSeDF“}µ/#ÓQÍyó≥«¥©+ÏΩ.Ø©ó´˚R5gº¸£ëÑuD¿R»˜Éf¨∑G‡2”úç©oıç∏M¿éè„d~¿'œ∑ôL´§Á4⁄Ö>ˇz‹ë˙Bj˛†–~9Ogï.W√4ò£e©•]wõØœöL≥»ÑáëÁ(™>>≤∆Ëô0+ËÌîdØEÜÆ“0ﬁ¶p;Ü≈!–w^}E)M5"√Ã-Ÿ1R…èøw",~EÓŒ1‹œA)∂„\)Km3x÷ì»|Í>hfØdº%¡Ì…Çfo*+Îπ˛Û˛y’’–µ∆¬UdNLDn'Qâ¬Ë˙Ü∑*Æ•.ªnÊ¡õCâïHà¨ˆÁ7âi&7NØ„÷ÜúX´hVàùœáF•âá‡ﬂ÷€N± §+GhE~ï7À*E¡ ‘ÆAÛl+3s2–}èÉ¯n/"’çÓö›¶sk=
ãµÃQŸ„@‘1¥U—UG${¶õ@a®81	<Ãµ)Ø›≠9‚Ÿ˘H7PÓ˜Òy~$ÎœO∂˛úÉ0;∏˛aÏÔÚÆ])ÍÉ@Ä≤µg¬IA	1Nw_Ê}?fˆë:~nëÕµbrˆ|!eôMêûSª=ÆìSr-1è)]#@§°≥&%vz;ƒ3o˚≠¡≠ZÃ5ÏÒu˝‰⁄∞Ω…4ÁÉ|÷"Æ±’·r≤Ößbiz9Á"T±*ﬂb%m(πÇœs“z woÍÚ]ˆ •≤]Çj”JìjK≈UA∑Â≠ÁZL Ô≠û°sA¶Ao%ïcÓ†n%¿ØL+∞"â∫l	{÷?ô!ΩgGgõ«—6o”‹ÜÇŒäºOûÛü—Õ¡Œ¶zπ˙∑ P∏ò_¡'öSﬂ•¡Ì≤L e>gbˇâB√p¥°NÄŸ˝ZO€CA¬sz	∆C≈SöÍqb≥óòﬂ—∂>Z8xpJ⁄ﬁUÜhÇñ¬…òb^ƒ'3Àùø(ﬂSG/ss≈)å$ƒSÉ„…˝PÕG•‰4cë] ß+Ïoi@6ÇÃJ;ÿz†©g)Ò÷yÃ∑oON◊»67èóÆqÊˆu›©Ω>‰r≤lÑ;XäDc!’z“Ã∂˙^¸
º†ÔR™µ3CYPŒ”˙ü¶M•0$Á∫ı-)ÿ%¡ÍT_.ì´ÛÒ∞ÇÓ◊öPíDYÎ{∏ôÌCVåÛ‘¬8|äP92Ø¨±A(é∏˘1ÃÕ]Œâb’á,ç∏|⁄;>è–íÌägÿsa∂≥0êD'“Ï4ªCX˜Økû\¢tûUWú˚Y‹oÙ_¡·Y∂"'a†V∫~ÃZ—7ëŒ0]ì>∆èÌH≈j°ΩÎ,,pë˝≤≈G<C‰wÔ®ÀNäÙ‹˜∑7Z¥§Å%)õ0´
Ù 3û√ÙH·Ö÷áú/—(.Ã∑	êRt8J/ƒ¨Î÷)iæ∑?7Gq5°˝Åv8Ω≈Lì◊pïv∞›AªÆ‘qs.âAäÁ ¡sˆ™*∆*π‹˙⁄ÜÖ‚Rî.˝»›uà&µlNıEkä{5w¡ﬂÜ|ª‚ÏÒc!¶i∏Í 8ó,ïÁö˝`™UNvÎ›ÃMÃ-ÌÁÃ¥É>·≥/_!óE÷√&„•ÿä¯|ˇë≤‚®Ë_hå`É$⁄6Y{¨@2âE,¡Ø+[Ô;/ìx©zUm®Ωd ù⁄ÛBâ(≤jÏódcVÅkyqÉwH\@Í¶øÈÕ q!˛£SÒÆæŸßàç‰›◊D›Hw<iZÓø“¿sÂùb≤&˘A“5÷ˇ—Ú◊Ç€ Aj˜â±n'çG§{q Gë˛/Lô©©éå"˛∏¨JC5çÕì;'Øgπ◊=û\~q$€úx,gb…ü˛£~ˇ1ΩÄ:N/ûﬂT6öôZ∂WŒ<±•\Ë,≤6€≤O/´"ê\Kü¡ß±ò˜ÉFä|wE)¶Ö£‚ÈÈ”Ev4aDä\Ùß§Ç·:\d«2Lœ ¯mH˚©˛o4B°÷ïøUb„ g]@T^§“jé$4¶JÂëÃ€ﬁH Û∑úµôéJ}œÉ(ø∞‹ñÏ≥‡.Ûﬁ>äHQ4ŒµÓ~∫ƒqù,÷÷$ˇ°$Vvî(PO-‹.πQÈæÔ5S è·à^¬.∑Bú3Út„Nâ|¢X†D`˚¸øLˇ&@≤8œ∑WÂåµÿ√ƒ[ËcÚÏ≤"(xﬁ∆√Á<|[5k-…ÚÔÙ∂ (Ye—GJT†B™~,˜›îÊÄ™òänN:≠k∑ç¨Àº°ï¢œViÁÏ¬˜˚û_	háÕ.=fíWçèÜ≈“5ıÕ∆ô˛œhµ<d∞kÈ¿«œVÁ≠IÛ}öÑ¸◊?>¸ø¶Ùπ¿(R∑Uÿìs˙sè‚ˇ…kNXÈrßk˚’Qî•ÊÖ£Áå∑Ìù£ë¢j>«rËëI√d◊ˇ‰÷ß`ÚÄ/êÙƒºgÕïø,cyvèEH™ÎÔ†lˆ÷Í¸˝”`»Q¬K'-c{”÷ı°h∞”¿:‹abOv›∂xÏuX©Î@w„Àa◊f˜(P5[J I∆=∫B˚çJ#Æ∫O#•ÁÁ¶ÓGÒèzè2ãæ5{aocxvÉ¸⁄qkÙ>J3ç˛=TÎ„yô∏_ÖtÃ
∏‘≤‚¯‘ÛbS^π™ÓHÀ}i˜uKN¸_‚q}£$ÅË&õΩ[”‹‚˙WG‚EÎvÑ›K†ˆÜpVùÏ∑ˆl/`'⁄XêÛ€W!dRã^k[ø‘úR5@˜á„h{ız†9Y–(Ò(´™ˇë¨ÚZÆ‘ÔSÀ-±úCv,s]xÕ™Ú)}»Ü´ºe<1-Ò◊Å˝˘\OÄHÒ»âG©%1@{π€éU»r5Wøìv6+t“ò¯∫íØ6K+p∞°oÇòidΩ/q–DG» ã”»Ækﬁ£≈qY7ÏÛ¿π4¨œ“"‡‹è&àƒùBÖ®[æÂàDG*·˘KYÇ‡6AÓºâËß–Úï–ºí3Ü£ƒO§?¡ﬂ0π»ëu!/–æò‘I_¨≈¥ ø@k‡MïGŸJc––F˚;Fù(_≈éoFﬂ$⁄ﬂºy¿‚≈` )ã∫ m¥y¸œ+Ä≈iàX†¢_”F«ãòWÊrÖœ{∫T•∑¿JIßO’–Ã2Û:)£◊
oqΩ|€9H,IÔ÷ÏCzÉlŒhê±ëßuﬁƒjV˚œk6^HØÑ1à-dú{µh{ªª‡òMúafµWn{ÈçÎorÈ*≠vÔí£ò©GÙlxoÆ™Ï*Ó?{pÈ	É^%õê$-"Œj(Ï™…Çt·o©ôå⁄Í^;¿Í§∞,n.…Ó–™ôãÀ#ê&M ‡æﬂy{cuÉsù`¡ü∞X‚Ÿ£\`Ø·˙ì ›Ó<ª‚‹À…∂ÙÑ0ñ]¿Pj.ØYÒUo ˛k}üvüé:·DT≠2c‹‰ röÄsÙ	`›] §oà˝ﬂÏæU8ΩM¨üÕ√‘1TåaàÈ~'¯8IÌíQ7≠í¡ájóºùÿ·V:ÊÏiâõ¡â•ŒkPöÒH˘=ﬁ˛Uy†‹	∫dôπ¿Ω§1<Lå∞≥∞i›≤∞y$Àg¥‡¯Ω€ºg@I_≤Ú5ıè‘¿öîŸ:µ£¿∑ÉÛÏÚ2K´	›ö£¡jìLíØñKÙΩ£≥¢„ˇùÖkV/ÖÏäæ÷æå¡Ñt€íˇ€Y1‚–BYPÓE¿^Z±MlèÌ“Ò)ΩW–®∆©LØvpÏàG'(I˙IZ›ÚT‡1|
Æ l¿W»$I&µæ,
»K¯@ã|),î@=Ω„´-Öﬂi’Z≤F(ç’C{A¬ˆr≠ê¨œzCÒÊÆAßÜNl˙‰ï∏p¯~q©∫õ\?N¢~Î€d˙¬NO„1Ïµ,a¸≈©Ãõ˜í``∏K8TÔ}fÒi˛E‡4«´†V9ΩLsÚeèÁˆ¶Sm%…∂?xE_¬7¡6S_%º¨PÆùpõç?.]FPÍVVõlüOıåq˚öL*Pq‚;ºb°ë»nÌ“æì-⁄Ñ™d«A Ê«π<◊Ò“Î¯ŸqoÂÕZ	0hÃw0#ä £^‡ÒÂ“¢ŸèΩ„πØxw4ﬁ˙SzP0¯âféª∆Äæ§Ñ•πá*.ﬁºêlà`π= ©∑<õu[è|]µiÈû€Î»!)ª∫{mrÀy´+@Ìëéáÿ:Vˇı,wX”JÊΩÄM™3V&YêÔ;Ôye´)òyë!~q»ÏGy’À≠í”Àd.7‚ ª›F¡¿s˝~ù1só∞ö>´ç·Ê de/linux/ptr_ring.h \
  include/linux/seq_file_net.h \
  include/net/netprio_cgroup.h \
  include/net/xdp.h \
  include/uapi/linux/neighbour.h \
  include/linux/netlink.h \
  include/net/scm.h \
    $(wildcard include/config/SECURITY_NETWORK) \
  include/linux/security.h \
    $(wildcard include/config/SECURITY_INFINIBAND) \
    $(wildcard include/config/SECURITY_NETWORK_XFRM) \
    $(wildcard include/config/SECURITY_PATH) \
    $(wildcard include/config/SECURITYFS) \
  include/linux/kernel_read_file.h \
  include/uapi/linux/netlink.h \
  include/uapi/linux/netdevice.h \
  include/uapi/linux/if.h \
  include/uapi/linux/hdlc/ioctl.h \
  include/linux/if_ether.h \
  include/linux/if_link.h \
  include/uapi/linux/if_link.h \
  include/uapi/linux/if_bonding.h \
  include/uapi/linux/pkt_cls.h \
  include/uapi/linux/pkt_sched.h \
  include/linux/hashtable.h \
  include/linux/inetdevice.h \
    $(wildcard include/config/INET) \
  include/linux/ip.h \
  include/uapi/linux/ip.h \
  include/linux/rtnetlink.h \
    $(wildcard include/config/NET_INGRESS) \
    $(wildcard include/config/NET_EGRESS) \
  include/uapi/linux/rtnetlink.h \
  include/uapi/linux/if_addr.h \
  include/linux/etherdevice.h \
  include/linux/crc32.h \
  include/linux/bitrev.h \
    $(wildcard include/config/HAVE_ARCH_BITREVERSE) \
  arch/x86/include/generated/asm/unaligned.h \
  include/asm-generic/unaligned.h \
  include/linux/unaligned/packed_struct.h \
  include/media/videobuf-core.h \
  include/media/videobuf-vmalloc.h \
  drivers/media/pci/cx18/cx18-queue.h \
  drivers/media/pci/cx18/cx18-streams.h \
  drivers/media/pci/cx18/cx18-fileops.h \
  drivers/media/pci/cx18/cx18-alsa.h \
  drivers/media/pci/cx18/cx18-alsa-pcm.h \

drivers/media/pci/cx18/cx18-alsa-pcm.o: $(deps_drivers/media/pci/cx18/cx18-alsa-pcm.o)

$(deps_drivers/media/pci/cx18/cx18-alsa-pcm.o):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ›Ë∫õı\·)M_1~+j:p¡ƒäó«uJßq%›âU È`¢MÏUjÛ‰FØUYÚäÜ#ª41∏q§u≤ÑÌo„≈á∞a—Ê¸Iæ9:¿˘◊÷ßOf ˝P>0À<Ã¢ÓjÕ'S–>˘7%˜õ‰Å∂x(Çÿb%ü}•¯ÚW˝p!Û!HøEbñı‹âL*Ç.Îâ´ëS÷ÆçQ^∂Óa¿ôı&+Ó*Å@{S∑˙ºhP≈{|ÅYe¢•|&ﬁWF\Ë≈˜Úœ´ƒ<b$˝y¢ç˛cxl>ì<∆»Öë|Ô¥^%”ï~iO1Cx’ûéÃ˜í_…àÂ«∫>äÕÿ◊∫_Ö⁄ÉGÛg]ˇˆèrw≤à„‘Œ2\fì‘•éÂ»Lsü?*ç',Èm(KLÜîô5d:≥ﬁEÆnˇÔ⁄ıÿ5≤ß	F¬+G=t0y∑˚π√jTÏWæıd±™˚]ü*=wqL*Y‘[/mNÎ|ƒö[ôµ•!aXd<™÷¥Pr·Tèoÿ∞Á¸‹˝ø|?–ÿŸ0[o=Y†K6Ê>¡«}§4n˘9µ9⁄≠ÌÎ´Ìã…vı„ã™˙Õï¥°á°¡ª’1+%Ô]¥Œúó(êPu_7ﬁ9•ET4ëG‰áó|¢A≤˚ü` °õ÷
BÄìä∞9>µ≈™ˆCM≠O¬$(9	Ø>7Ü˙9ûÁå[û˚$1üPá<ÑQ-≤{ç¥ß2TO¯W±7âZÁ3µ*≤3'‰¨@∫TZH¨ìwFIπÄæ∏txËsøtªº+Jƒ∆ˇªÁ+ì√6Êäé^∂-[ÿ·c]»Öë‡˛¡@;ªaÙÑljgÌ˙>Ëfñ?]í≠›=‡¿∞–h¬◊¸ÒÔÏÓ
ó§h~¯[BD"ﬂiàuzvb◊X>dòBÒ˛Z)ímTƒb¯\Ò')®Ë∫X˙e'üJ{∞√U›ªIÿ%∏SZíÄ’”¬M¶eºLÁÕ_ê÷sòqª£;IjÉﬂ2§$Öñ∞ÍeRQ+’Ë_ZÙÈü #ïhÊp˛Üò‡ÀLïÓ8?3Œo±˚øÓ¬`U@Ëıåø!÷∞Ï°”HoÒ[˙n∫òô¬Ô–FÑ{RWcrsÿî÷Ú(Â∑Z‹aÙz∫#¿w‹2›8 ¯ızeB¡Ë : øÑiÎÜì9°")à…§E¶*±ﬂ<¿Í‹÷Æ‹◊Ûa ¬4ﬂ^——x∏.¡9DÛ{3kºÊÙ≠‡€øÇÂ2ûK8Í7F£tëóö·¢1M…◊T“+†8ù∑o«íπ#¬(r:ÙífLvH–õ&G«ggﬂ=Ù›ıÓ6é&znÂ§%+ŒTiEÑ≤…§QÎùLâ}ﬂ%≠@ |lÖz‹^ÎFN§0l•"Té?Û¡p	JÉG7ª3ÚÉDcüp‹`?TîwîŸÁπ™¯ï`â7èm≤ù|,—Áù˙‰^êÄ%¿†<œ€:N?È—sﬁ†O∂O+»¨52äÔÕøH¿yE—Zj©{4—≠JâïÀıW–-Î$b€3ƒÉK˚µ‚3Áaë Í¬GD7VöCÄ  exŒ+íúQ’∂öÖóV\§KŒO.0®rË·=Ë74)ÏÄ(Ÿó«+Ñà#prV^0gNÑÛgdÜ$_A˜N¡	“08&ãBk3 ›¸[U˚(>"„€dﬁ©,bbßÌ4Æf‰‘‰ˇKkYîq¥Û˙Ãõ^ V√Åz¢˙ŸxPƒ”˜€Ê<;a¬k≥ÃÕ;+å	HM¨∂ó‰Ô÷ëiº°£X‰4†Œ}ÄæÄÏ7”Àd”x«h∂5ŸºHKæôæÿØ°∏¯2„ O(ëﬂ¢°(xHi ÌíÂ≤¶kﬁÌNì§\7c9[UU√%¯/§´•<¨‹~p„ß	ù\…ã/ÿœô&q["∂ÁÌRoï{wkCHShyâ„ âeYDnÔ“!ë{UkÉîƒIµ¢%∆~8’Œ)#◊$6z‘,k«l˛
i$ÈêUÁÀe?ÁQ[ü±"5äœsaﬂèôÓ&*IØÓ<≠k'ﬂJ*>Üáˆ:bB>a)ÎŸ¯\≠'ÍW˙¶~zÕ·NAjf@2À ˛Sˆó¶Q^íå«õjÛAæ·nÓ›Vö°mj»Y#ç;_œΩ3õﬁ>6Kò}È=mkk.Ú≠jΩ{<‹≤π„ë7§õÅ—˛ÓŒFmü˝*ƒO.Q÷–ÔÏTÔºVegP¥b„ÓÍf˚Z,EFNΩ¿∑‡eõë˛ÍÁë§øZ”uÅæy5—6vn+„ä≠œÕìùΩì^óÖ;∑—óAJ?Q¯B	¿≥‡ƒg8}!Äëù_‚>¥f‘–€RÖîΩ≤s2çPBX{¶‹W°ÿp4ã,òA˜8¡^!*çè(˘ç‚≠¡8°zø%5ß·ØÄıP¸Äü6’‡hAîp«9í*Ïr∫qÊa+y&aÎ—éFä/ˆ6bwïÜJ6‰mLÔGL⁄Oúb⁄s?´3Œ9◊êH¿ÄõGë˙P01Â'ú'0JÍdº®¿£¡‡ÉR°»\í%±éG∏MãáÈŒÛ‹†fNZWÇa•+nd]µ›ZYÂ4¥iÂe 8HÖÕf√N’ã®ú‹˘J›ÒfÄz¸Â_6è~,‘t˜˛´F?Æ∂Ê¯%í÷E∞…SIí5±R≤≈äÀÂﬂ\µE§È»€0ëb(Sâ™ı∏z|ô*•$)íé)}∫hïÏ\dè¸Ú† ïﬂ©•qŒQ∞‰Ç#}gÈÿÛPGGvG9ÉëSÀ˝vU£ñ8û´î}ä+kÔ)ÉäP≈¶èW«ÿ†∆|øVπn<∆È‡ﬂ[õU·2ùÜúÜº‹Õˇ≠\›ΩÉáNt˚∏(j*ÔõL™óM8¥$Ë˘ºÔ’bI}B˚7'&FøZÒπWˆ«;‚
5JùG‚õ–Ù3’Ë?†…áô…˚ÿAa¬Z•`‡ÌES‹Å2{ﬂß(Y¸›ôÚì™1Œ°Ê<Ö
Bï†S‘üA∫ú˝[˝J€©¥hµ¸hGB
Ë\ù‰”Bª∏7‚"¯TÃ&ÈÕAÙ¬»ä˜õ≠óX≠ñóŒí$°™lbY3ﬁ•Ì	¬¸5È5°Œ^.”'e%i+Ü´ SäÂ§´„◊:YÅ}€ñL=zßè(+∏¨∂ø5¯øäãp>¿æ”…ı,JΩ ctÛó¢x]såÊX¬ô˝˙≥ºjºÖ∑nETÏâ€bÿ«Ï ¢]E“XÿD°ÁaRòZ™-øâ‹4√ﬂ€£é¡…Ã≠#±Â Óe◊’®¬gu»Êu˝´˝Vxı.∫ãø@ì©q«∆©ßüSûÓùQÁ€≠¡¿“s´Èí°=VkÁeêÿgÃì'OÜ˛ñ?5ƒ≤ù¿^cü9¿§⁄€3<&ÛS¯éöy %XÒÃ%1êRFƒºCú˚ó≈∑ÛMNﬁ˘ÿﬁÌÓ	%M∏DÁƒáÓΩÊ1ø∆`õT˜Ú¥Gb~°$@“VÕZèˇ_:µ–;ËÌ›F>&˝U∂Ccƒôíº"'∏¬Ø£∏‚ìY‡◊!ƒÇOÕ∂^
á˙ãBŸ	∏é•ù‚H˚É˚ÊqqU|êä·q!¿ï¨”iUóàkÒáÙ˘F#}eLn…Ë$q‰9Ø;≤oz*·æ@Sè|w.a7†|Ï<ô∆Ä√-–ƒë–EΩá'ÜS^∆ÿ^=!¨fÜïı˛ôÜ>*Âºaj—™’∫¨Ë–û∑y‘∞–ä»Ö{:Wˇ¬zﬂÇ*◊¡-"7Üå£|¸°§œåÿÓ˘ÁâRE;ﬁÑ`÷ç¸4zŸmÚﬁ¡g\~9	€ƒ
û%ˇGÀ÷=hQEªˇôÔnŸÀ^® ˘”;G0¬3XπI§¿Là;r_®ˇ;4Z†÷„¸∏I¨∂‡¿Û‰pr∆nêl,ÌyÍ?o|£i,’ƒú h†mdä´”ˇ∞:™YC˙ÔO„L=k'Û}k0bè=x@u$ﬁ€^O!E4CÃõê©Vg 	âY,∏àæI—]Û0·
›∂ö4FÖj∆¶∫´d’GÌ6êÿXg;çÆ∏≤	(õx@ÔiÖ˘yà:àC-√·∆ﬁ˜0îE–Kˆƒ±£â≥ëƒÄr
œî!ˇ™B	{¶¥Jf>4ŒP_j…∆ØæóÃÈ≠Æî(S	”u(±Y˘…±•EX÷lH© 9˙úHê%SEa¿·nZ ÔƒÒ0Ô®wF˘è÷ÛZã7Ÿú„ÿÍy Ã∑·ßYŸˆìF&≥â=ÒgÇÄ≠ ¬ˆ.ÛúàG·OÔS÷‚ ›À†Û≥eÉË»†≥ŸVzÍñ}%¡˘ÊÙ≠‘ß:Á∆Çç£*yà¯:SÌD¡zöÓXµ˚EÑ9m9∫,%€X)ﬁπÍ@‘
÷_Ì;Ú†AKöæªKÂ-ÇUˆ·ù´ |3‹%œ∏¥;gjAcÛ¥ÀcÄ˚ûãøÛ€,=—
h¡pµläG+´C‘AsÒiDôx±˝(¢ñ&ºhY È~5∂"]Ïw◊‹πø“◊µ‘Å—Xﬁßch¡gõ≥‰˘&ﬁy° k‹∞Z˘Ω>∂˝*∂DNZ‚⁄dÎ–q=∆ñ±yKò‰Sµå$¯Rd«AˆÍn‡cŒ{=2äèÏ:F*≈£¢O∆¬±,wı
Q–õ€–ì‰ºlñ,˝Ì&;òΩ21I«v™Ÿ÷≠Î#]‚%Å¸OAi)1˙\äF«òàTâ‚”ø0ÈÚZ 4Ñ∏≥®K&‡@"AnFZ9ü@æ<à#îÚEB÷wØ¿ΩjZ?-„ï{¯4µ∞mËF◊CÁà÷‘„}|ôb~
^î…¿u"$<≥∫¶©{^@ë±˙LZŒ%.+≠TÂCï>’1ˇdùñH"ÿºx_ÌÙ;_5≤⁄˝4‡üÿ¸Ï2ÃµÜO&u„aÕÙÇÁGï)5¨¥¬˘¥¿)¶3RAMûOEEõ∏I
´ﬂ)—Àvó‰˙∑ûM.‹|ÛüqõF%[¬AS9_„6âﬂ.Ü}õ‡†\ûâ:Ù&ì¥X§FùS´ﬂñH N]ÙD∫<_¨p™O{3àlrœK®&Ì∆UOUfí˘˘d˙Ç£“	˛‡∞	}JZàî‚EÒƒò{—¸_ø¿}*lÃ∂)V©L.ïY?∂LC[z≤é||îÆWíﬁ∞~„^í—˜eö≠$xe=π›<|¥AóN¢®_ñÖÿﬂx£N⁄(n@Ÿ4ΩÚ!ºuŒÌh2˚¯4jR.ô◊*(Ä€Oc$˜ﬁò<⁄íÖ†i!Qï˝b©ﬂm}Ï
ˆ@#˙•∂z™Åﬁ›{Bß7B˚Ô™Å=g∑"l∫‚ùàı.÷ù)]©}Vù%‹–ßxFAƒC˙ü†de~¬aò¬'ª'õ;Üî<z‡≥†ed¥ãÁ0D¯®æ?∂√ïr¶◊ºh‚	¢“™hŒ«>Éòßv_;ÿX!úbIKHÿ^8|/ ±{ﬂÁK<r†Áv®WPêjÈÍBÊ Ö¨ç4¢ãÌ>ÏÚày˙˛OîeÂï%ØªèÈ!ˇÍ∏`•Ôr‡]`X…LÚ[Á2÷ú_W<qY	°˝bkª&ü∂F‘cSPO.«	&¢«œaÃÓ†ÎÔúåVÂ«˚o∂F}è`˜’˛Ÿ+p∂Ñ±"ü÷Æ–ßß—RÿI!⁄
MJÅ§Nu ìﬁ∞(pÈ∆ﬁ»—ºÅïìo,üqñ±%{Ñ†«≈@ú◊á)Ÿko—¡‚⁄ ∞s`„\‘¢2•oz∂$&Õ0vRoóı∏ ùù∑ AI&„ç∏¥@V◊C?≈ıó‹T∏yü∆^ÄpbCR‰$◊[f@\˙gz-bGü˜K€ß +Ì2üT∞H≈bì˙KI¡÷ŒÌ4ó˛ïá‚WJMÓâíÉuèà§$qg#N(6è¯}ıªÕ≈∏*sÂBÕpö˛:¬dâïÛhˆ£Ä÷!ú=)?∂tùªå≈ˆmﬁud	∂Zñ%|*ÎCêÛú‡¸∆Ø.ÇÉˇíÃ-ÚDœ÷≈Ås∏iΩmM”Íbi‰Ú⁄Ω¡ì3é"ÏÕ/Ã˝⁄%ÔÅ£Ñ£Èœ.¡◊…ˇSy8
ç‹0zÀ8£BÄ=rÓ◊⁄Ñ |Ø∏K¯ıeMˆ÷CÜÊ¥C9≥∫ˆK^Ò±OVD±Yºû5Bbò=Õê˛/¿Ô≥y®7◊)aU3T @Œ,UXXgÚd2.Ω∞˛Ì*◊KπÌÂ˘çAæ‰CË8›2¬*›‡Tp¿ÆRﬁªRe=∏‹CK±‚PÉÏoÛQ'∆lˇ∆Œ–Çõ5
ô33∑ıÂ√ôI–¬Ã
Æí∑h#EÀ'/ä™Â
qÙ‰–‡DLãJ"◊‹˝@cƒÙŒµ«pv√	¯√)U¨È˛⁄¬◊ßÉπZDkÎ.‚ïU1!ØIÂ•([N«‹ª†"≥N|ø™GÖnSu°Dn÷n‡V1Í‘s¸∆„2‡É4õê˘±±(ˇ{ËÚçÂœÂò∏ƒ4ëm=·2ÌLÎÀÛçu¶∆Y5›œDÍ#Aœn¬]´[?†ul„ mÿË,ÍRlm»µ‚,£3J™ë|
Á÷»,z/GÜÈ;VÕ6±=léc¶˘°—ÈπUû £Z˜3Œn&sE)ïÎ˚÷≠UD∫Gﬂî∞≥?RRÙ(Öø”z ¥H<bjß5o+÷ÑYj·7B8˘*‰≤]‘%.πá®9¢üØ–C–•Æ<Eç©q¶B"¢x«OoˇÛ¯LÄ0∆!Ì¸¯Ç|%û∂ù.uı≤ËíY˘*®•.ê¸Ú[Ã
.˛Ö“≈Y()pìüÒI≥ë»~õ€PQà[ñ_∂cMUÆ9∂9I¿o,çØŸ¡û‡QÂΩøS∆≠âc!{Ï	—˘Mﬂ˜´Nä¶3_Ÿç6çË¡zp3û¬™˜ºÊÄ+îHˆQh£G˘‡üÿ,µ5€L∂œ»E—»)F∏okñ˜áö%œJÇôÖ:∆≤{Ç±‡ÎBih›&xÆÅN$˝St)Øt£ÛÛ…ì]µGﬂ˚”ê0Éît¶ÒÎç…ˆ£È‹•t¯{“)˙LôŸ–kâ(èCãÒD©ãzz∫ÃJ^ˇøœk˙tÊ≥2œúÒ“]√Îä#xLv8àeÅˇª‡Tie2πé÷5ÔYÀÄpª$wUI·& zXˆ˚ôÁ≠òÖÙ±.∫Pf∞≥m∆‰∏™Ë>i|E)í¶‰éáÉΩOm €ÇÈéjΩ¬xõ2y#ë©áìI”iÒ`ÁËq=îmÓ¸ÍeË·‰@äU)«∏æÃ:RvÉV‘¶≥–i;¸ÉBƒëº˙.≠Ò:ì¨ÊEccóL≥ëv√T-ﬂDb2öcÃG_ˆM'[&˚ùç"§ác"\w◊bPÄ˜RÎç≈ˇêòq['∏\,>Ïoq+:“œ¨°ú•]∑©‰ç˜ıë‚˚lÄ˛$¿°°V˙Ëﬁ~DE⁄È–;¥v5bÒ®Rj§´®;c`[„á‰”ˆøéìrÄd\“„—ñÃË≥á∂/tˆÃybn◊ôºØZ)F‡ıˇUNΩA8b#„<iä;ö∆q≥∆%&æ ãûh°cav-!®ëM©Ì1/˚HAc∫‡nBÒ)ÇFÜ8úôôÉÊiêˆ>ŸµS"°R$£üL˛úU≠‡ÚFkYÿ\ƒ!“èJ«Ç»‘úU÷¨–ÛŸ¨JÑ2ﬂì"¬"π?Œ:;MméR¢≠’ã‹bÏ}ƒQp}ÓıË‚˜ cÚUD%¯¢S8á|¢Ω◊äö»}ƒr[IVäÃVá3Lâ…C„’î9T©FÙ:*≤∫9WÅ…ûˆlIK%÷!dım)8«≤µQ¶˙Ë ØäSi|·í6\«!Ë Üi∞Ω’u◊W‹$ü!	µ“2`\ìQî∫O±ÅŸd'Àz.8òHë=7ˇÍ∞%·@Î}ç¥ıÎ¥l2°÷≈ ◊¶åWîÏ¥[⁄[˚Ô«pdõ[`«#Ôp˘!~â∫Òàâhº¶ÖNa◊>8=\ò…`Gàuı%˛DW”§∏ˇ›G≠KJyß)µÒ˜á{ﬂV≈ì#N&÷¶≈[ﬂ√˘∂<E'ËÄâó˙|«ﬁ0Í]?6GÑw`™ÏBÜUÀ0‡ﬂ…`Ià`”Zm®ü ñ“·øMÈﬂˆÇ∑¯„¬Øˆ¨•—ñÇ´7·ø——N ¬y‹V∑]Ö÷J#k9Îº«†}˘WÇ≈#ïöQ‚4&ç*î¥¨`Ωe|f'Ixtå}Øf^’<ûFË£vÏp‰ãN4õâ≈aéî©ö‡ÔE‡°ÔôwU]&â¬◊æ9˜´˙Ü9©ØVìv˙1\Éœ=n‚*Œƒ?‘‹ßqØﬂtåpÈôDíørkzP1¸çºØ!Wÿ/˘k"ì·J¨¢~˝Æ≠>‰M°Û9pf˘’IÖ'∑ûjáà»°uwã*o	«√ß£é‡'AAΩ√À∏©GÁ	/"€É9·*Då8HùUNò¯fC1·…øûM15ÆAf≤Vw‹—Ãçøì¬6ùÜîÂhb·Xƒ|5<ŒÉQÉ™†Â—`>MD —?DèPigäòûrç.éq~õîI≤™Î/ˆÎ9ras"ª2°W≥≤Ó	‡x§C$0’ÌP$JÜ+í3SÙY˙Vú≥‹A”«J1ã“√ØÏóÄÿDrdƒù 3Ù}f
Hì:e¨ %∏òœÈ⁄‚.„ni ùóã“±BXÍ°˛¢ÖÎ˜h…sƒ´ıÿ´…âm∫ü|π‚?ùü Raà¢€°zÂ≈ã€Ú⁄ŸdV’6stΩ∆[˚[q‰IIü5<å Los,ﬁ<ôT!ıH∂0GzÈˇœÇ≤"SIÎãMø¶Zâ'Ö~ˆ∞>7ﬂ"‹‹Fºa¿7æ≥?ÿò˜˚ıÉ`˛Zıû?ÿÇ\	•ÄÙøPQ-÷ó«%ﬁö⁄%∆|OÚNLkÆÂÉ`—¬^ÉDπûöeOw"%qC8‡±zÓ9∏ñ1ˆó[˚◊ù$⁄´y¢Dõã>= |^üFù∂ Än~B¯cÍ¢¶¶§«@éMÒ“§}lA«0g>¥À^åãKÅIörO˚‡˚Ü¿Â\»jQ)†≥¯÷bX<Ë›wôßQ˝G‰\Ë9"u‹6PSC?¸ıà¶ƒXqò≤n|Ä¥(˛y∂¬°JÍ¬lÍË/ÈÕ{RIÊ¸TKVy”ïiX
πﬁÉ:ˇÂ=pπÏÒN⁄‰€™C	\
”≈@[ˇﬂüöo •ö1Ÿª∑ÄO:IçY"{2≠˜»m)§ÆÅÎûr£ñ,¬*– Ì√‚ÔQm40`gÂ$ô#ﬂvqáÈß%Ê|ô∑Î¢Ø)5∞}±ˇÁÈd˘™T^ı8$ˇkX∆ƒ≤?ÀvKIír«∫s4ÊUsÈªn<lò¥É}≠q„ºÓFéºÊ•>ŸRØ#∑ß0'õL˚ÚIœ‚ÇÊsXh†∆©íìNDµ∑Cè;“ÿ2oû¿åÛëØÓ0¡]˝’íI;7Ÿ
œåëGQyÚF™YdÕy≤[k"É§hgÛÊ∂F⁄⁄≤¿t…F…£%MÀ˚¨f*–-‰3°∆√Cw	â•-6•—Ô⁄/y øÏ…ÒÍ‰¶»7m‰¸qÎ!˙)xÈuTµê¡◊‘]ºtë|D”…6Yö»3å¥ÜbÙzﬁ|hÎPÇÄ:∂X‘Wg+Ÿ≠2˚"∆p¸÷kR:ÖRWÙ2/˚MñE.ÏO€ÉVr3Ê<˚ÚºÏÅÛïlô·Ï7ﬂ{úïá¿ëPj£í9ã&<3†r[<Yz_Áér≥Œ_mS/à˜	mˇ‡ë$*.Q˜√´õµXÁMäìêº‹lBËΩjàC{>Ñ¨á”‡√C≈r≤x⁄“◊1Raê˛˜ïv$ =¥SÕ!h˜k⁄÷vÍ∆√‡jí«ƒ¯!å&	D‹˛k ÏC˙MŸüEaÎˇ’kVD¬åx∆ÙïŒ∏Ê8ÆÊùï§•8k2¸˜ÜP~V‡Ë/µÔ‰a¥N˘ÍπkÖµôENäåahÙÜ·˘Æ°⁄-±¸, M3≠#öoXN2¡ áAµŸ¡ﬁ¥;ùØG>˙ Î∑ı√%..9WaQµ∏80ìHöΩ8/tΩS∑Ø“ZöñnR3èüECã†‚8WÑ"ÃÑ±ƒq–g?≥∂±∫í'©0–¡)‰ÊJ ?qÓ]{!Ò9Ío˛èõ—«˚ÿè|ÜÆKôPü≥∆åXØÀÿÜ_•ì+˜—cÇàø[»–˛˘ıa‘D¡Çë}˜íèõ¡Ç0-Y˛ál3|‡õ‘üïÅüe°qUÌ{
Íú”©Q-A¶©òÍZÓ‡ÓE¢1fﬁÿï5πˆÕÉRÜ>D˙Íûep≈ü·’7Ìt5hSü´˜‰c¢÷$J	˙‘·˚çÿ¨êﬂ™G`,•ûòN[ ?zeÑM™D)N(ﬂÓk∫aq¨£ç1/å!^Dm-ó)=ñejUx¥¶¥’ı´!ÇïYÂÜ%‹vfŒÁ=x}uL›5Jõmû5◊y™√Õ ≥ë.˛Wy0}¶`aÕ≤(ZQªF![˜tû6†u∞·"WW˙/Ú#Fûˆ?iO†Ñ≠ÔÆpÈ«\„Iì/>KëÎ4≠ı& *øäÙÅLﬂ']r“Yf|Êj&V≥˙h¶;ìñgÂ∏i–¸(L"*ñ ¢¿ñJ¥\ÎÁérbä˘õaWÛ9†∏Vø±¡õøBãHê*A¸tPgXM¥˚ ÌÊd¨ê› 0OF`V`Î@£ør¯™°0$åﬂº7ËËˆp¥jﬂ<7Ëwìﬁ´oﬂ’|#`3oêÙ∂ò^ﬁF√Ú-S‹òz–∏≥s∆8ÃP&áK™"ï|E’˛gpÂ‹	”Ìm∂u‡-TD°O∏Ñ$à∞=˛≈í*¯ÎI©-¢(èga	$!–Wî£y«ähÇcgÇx¿≤k`2Ù‘>Æ¯'≤M+∑˜)=¡ı*n"˝>⁄_¡˝]DJ8xeÙ88:ÍØjn~\„Të⁄ sÑØÎ–ŸPaîjr∏W1o]^ '∏íõ“‹k3c◊óU≠¨k<:√dÇÃëM¯jô0}Ω‚ë<ö®Ög∂√Ÿù6V∂í˛µƒîàT6ˇ%œ“bbíXA-Â⁄Ùc;¬ÜÏ¥ﬁ<¥Õ|πØ?◊U5ßﬁ]˚–’˘t[WK#tŒ£9S⁄⁄Ù¥2ñt(Á}D»Í≥Úõ£ ÚV˝ÚÉ«ù⁄U:ƒ±$µ≤U#±∫Ï Ñ @C…¨˚]^qtÔb”~}æûLqWXa>RﬂÁY¿ﬂ kBe≠ÊæájüØ´>–c¬œ£¸cµÓƒû°<ZÀTIÉ≈à…AÉBtÓ"w≥áÔèW¥éÙÇD≈f”‹x¢jÏ37ù*uØ‚]a%œ%(QmRÍ‰Q$ú∞ƒJsF8xî”°RÒÜêUêåé“Èh© ‡∑2PÑ¢\$LÀ^7≠·pÍö;ÂÂIí.¿Rﬁ¬⁄j˘_œÿ˛ùwÿã%ﬁ;cçsYËx2m“ ˝!¸ ›÷√]p∑ƒ≤g—bˇÓ#§XHùÓÌç¢SÊU!ØcÏÒàA˙H;§~ûsU@[¢>∞—˚†g 8ó“
 YeøﬁÂZU1âg$Ô"6=Bˇﬁ§JÒ≤ëu+…á-NÄﬁaO˜ŒÍá—£~¿˜ãÑÓT‰+JıÚ®eRCKÓJ“õeê@ŸWÁÛdÉH≠U∂Ä™Í|·íc÷ñœ=∂ˇ}±˙ÊÊlwÒlì _sÌ√^ìº?j˝ı<@Lô7e~dõ|!˜m´aëÛÓ≈±fï⁄Txc»ü£B°éûƒ	Âgtcº&øGı“˙È=†I'∂I9ûDœMÏqπªÁÎÃΩ4ºaû€Mc‚Ømy'¶Ú"ä%yKçÿ∏I: ä2J9ç?øD•®)õ“g;$2†”Hê∂ﬁÆOw[U]˙hD¢†Ñõi˘Yò0‚ˇ∑Ij«ä∫ˆuÇ©KÜ&é"ø©u”:›63n˝44‘uﬁÚÌœöS˜¶“ci„K»{™<û˘ΩÓ∑èÎyÊ˝O˚Ú˜*π‰ß(‹≠‡Ë'Û8™™≤åC»ˇù.˜πùˆF/¿3:BØ˚!≠1!≤ó €FfTtùå75RdØ?å(£G

‹¡◊««Añ∑˘ˆu£…˜nM!iûyŸ“~CO∂‰û⁄"|∞I´DÇØ’.EÓ©ÆãcFΩ[òcç|.S©:∑bæ∆PB ≤◊√ûwI5oç˜]OÛ◊˙;Î7wÇëF'ì ªæl‰UkS≠µ?≠‰)}Kz≠°ÜDõ4|{ËeÒÊ€‡hç|è¢7∆a◊≥ó€ÊÖW!Ó<Ê¥◊ÓπG…¨Æ?Í!<¸@)Yò…«Î^∞úË,g@,Ç†;Q	.~å»≤œÊˆo`«Ä©ßÄˆGŒ.Ùà	£Ñ»¡ßÖj$ÀÈxΩ"ûÒﬁ„T=
B^”Àÿ∂Âò‚QªÒõJRm¨.vË¶ÁLÓ⁄|yœ@G√)Ò\_y[è?ﬁªøÛ®´=Û@~‡›Lú;k~ÉóoeKÓÙπQwbøúS6ô<+i^ëQù|ÑvÈKﬁò⁄]U?:¥Î‡0%¢KäE))ùîx¯(Ì.mqÓÇ˜bÅmiÈ:ÓJ¡ïì•ÌñÜSÕC„ôì#ƒ÷¬~´GFƒ[‰oòπä:ÜˆP»F¥Ø)Ò$”˜Æ∑
«q±Á?áPrœç3Ë˘`ä—"üDjJ.ß◊˘¨NÖ:˜˙vÿ£^—bE!Éüè–,*:¸)Ò∑≈tZ¬-)®g•¯Ò|ÆÉ_%ÃÉ0yUå∫uŸpé˜∏√˘zD0lFÁ\;ET¨†8⁄ ^x€≤(\nA¥˛•gJûL°ì	’ÊJ©X§ÓT"πG7?Ä¸¨Q&∞˜yØISêïˇæ ŸûﬁRG˙∑a¸ŒZ±@≤˚t-Sƒ ”aOÎ' ∆4•l˙-:e√ÿ6c2¢o¥#b∆"sãD◊ÔZ®.ò˛¢ïÑœà\`iDˆH“Eál«B!©7/k ?≥ny“&/áZØ°ﬁ1BêŸﬁ—˝ä˛ÿ˘Å´ÁˆÿêbÈ{ˆj@ëÜ4Œ–¸_nÚ∞çF”êÎè $ƒñ,ñﬂ;‹“O!°⁄uµﬂ<>–“aÍÛŒ?‰ù(†u;â*ç{ﬂL™ã¯ˆÙiÔô›NîyºkYÒ ú=0S˙√ˆ˝ºc5/7ZõÂV˛’`/µ°7Ä≥®—∑ÿ¥¥Á—Ç„‹5:EÖ‚6ﬂ∂√C√"∞ÿ§Nﬁ˝&Pü'†oPÁÂ—∏’•"ÁB9ÔT†Ø«u¢ò∆E‡NM‘<Ç™@ÂÍV6î‚Ï~¨øÎ|[•üÔR¢√LµCìötCJ˚T¿Îë¸’(¿‰T`!ó,tr[ßO≈dÍA˙πt˜)ï…Œ\4»†±«†-¥ù.•∂å÷m5Ågπ∆Ö}Ñïs∫:JÈ/EaπóÖû˘ûò‡Î∆u‹Ó¬]>ØÍÀEú§‹O√i˚ïJ‘’ßˆO>2}Ê§˚;ê#R˚#©x/JJø¬»Pµ^¯!ÀèJûƒgzj›7’ùZKL!Ÿ’≥≈©KzY-øﬂ~§¸>Ê"Ò˜àãY%aâΩÍL∂oÇ@'Ωæ¸È"˝≠ä/3≠∫™ÇÄ2Oı	ƒOIz¸ √º6·_0óz˝y’àÙÍZﬂ´‰èu/˝⁄É0Œ≈
ÙâkﬁƒˇSÏS÷÷ÉÍ-≠g#´mÿ:˝*‹‰ñ
b"ïMxÚ®=£nY‡tÃ)©7Î7ﬂs8N^7‰ £¡©_p`œ£ÿ¬ﬂ«;x¸É›°Áâ¡÷Ç;2È35D|¶*¥é”≈[ '„Nt® ÑêÚã∫¸wLrÍá}µ8Ï3Ò/á äív]‰ÿ`Î^ÅËó∞*Öä˜Ωï~◊?œäéπB∑1ˆ`\Í_mnL]}!“yÄ~XâH92/û’—"Xˇ≥váÄÎÿ≤\˙õ◊`⁄Ìé ‚G-#Q˙Í›–:aWÒ∂.¶”Æ)◊oÀ¬©‚6\US65	'÷rµÀ⁄≥I¡Dá˝ﬁ}çÍ≥áz!Hsb„Ó.W<ÒÑAV’ﬁ‚ecæh5’tpô‚”@ÓmïÊCödAc@ˇ:§Y˙w1«=|‘˘≤ó Û•AöÔíªY;ƒ¡ê#Ú’ëÒúi:ã¥/@ZÖÊlt—J˘)M5ø÷Íˆ4"[;=l≈E@√=ÉÕø™oŒ€è∂ëÄ¸;Aé.®}˘«∞–J*I“≈a∂˚Q@◊oè”nO•È¡∏qÀ®≠®Æ‰–DËÕPíø«‹ ∑Àf‘Ú"©C%1‰^vEÀÁ˛àHLÛ@UÌËÀìª/˚V6f“˜ ®rXpÕû∫˛√ÆßË:x˝ç[Ä%∞úÅ_Ä.<ã"¡röVZX“í`oC¬rsÒCn´bnπ*äﬁá0Í’õ®(zH—Kv˙∑Ùﬁk"ÜµkA¬{∏AUãË2ñXúè¶®R•ÎaL¬:≈s-oÜæ‚ﬂÃÇ[ª∏î(ﬁ”&dõ„‚¢'%]ÛáÖ08u[⁄ÚÃÃPôˆ≠—∫ÓJ<?œﬂ∂Ô√∑x£~.a ﬂ4K ﬁ+°QäÈÊ‚B%ˆ”y[ª¸F'??æqö¶2ÌƒXAˇ«˙\Àwgç€9Ø’±Á)J.#67ß©ç2IXÄ≤‰¬åÕ<7T6ÏZó™bïÌ ﬁ©≠ÿ≤h7¬¬ﬁ7ËzÈﬁÀ¯IÕ|É'8Á√û@i‘6¯°≠Í—“˛UkûPBºë–Å¡áéò@/≥Î´zÊæ,ãl>ôaæ√$ §‡;–(	kçßRà”]Kå4óHÊµPG–zRÉ{éâZ
Áå-ì•I≥5DóÊ/¶ Uãÿ{1∂¸%›∞b∂˜	H}êÛ≠3œÑwmHÏrJŸ«∏Tˇ¿·R£ ñBbIvfjõ‡⁄πé®k2ÌóZ«ƒˇvæóπ’¡ùô\€·H}4bÿ©ÄÊYP/•≥ÿ£œdñÁÍ<%DN¶9Ü˜qM√¸À$¥’ªÓ ∫πn•Ω¿©yl≥”¿Ø°V»≤®@u‚µÃ∏nÅ‘Ê‰äÂè#P
ƒ∑©€Küsˆæ¬˛ºÂ^í6À\µn÷V∂>÷ùìtÄÚàK&òÚ©ï§)Ü∫T[èÄBE˘G4~ù¬»ÿG˙P!!†“Pª^Ë¬µU≈∑¯âÖ0R/e"‹TW∆®¥†r„∫Ü·ª’eﬂö≥™y¨>°å?û´_W]l:ã
!]T•¯≠±7˝Ÿhsä%‚ˆ*Û°†3Z ÖˇÏœZÖQ'±¡‰Ö.õ]
RXVƒ~˜;dﬁﬂ…Á ∆/r¥%ñ».Ï1é»U¿Ä;]@8hk√˚Ó-—G∆™â©˙‚‰Ên7P+p2Ì;°æT=µ@˙5¶ÜDÆ.øªØj{WâÍ!Vñ©8dòCíörKD˝(Kx h5˚î‹ﬁDmÊõêË±gı«“—7∑é®ò±É◊≤Ã˝î‚∫
alKˇp 6?íéΩMÃdOõVÎ◊≤√@lTWs·,ùI’ø™4{x0z≈˚XÁ˘X ÀU€1FC‰ˆñÒgˆ?	qΩR7
“≠÷V|˙R¿‘•Œ~Éb‚ÊÈ8ˇªàvo!Ω@Ë≠æ0WfHÿY‰æ>Õ≠ü ˜WÁŸ˜ñ'+`‡L4zØÅÆÀ6í.∫£QÊ)†jy%ï;]˛≥jXÚæ qs?É‰3°,/∞2öç.•ˇS∏I<ÆÌ¯ˆ$ﬂñ·!Bá‹gÑˆ«•¯úª•~⁄Ë%Za¥Ïì:Ú¢‹`ﬁ5d≤}÷(ØLÈ¥ÔaGAcs3Ë&ˆX¢-√∑V èZ$gsL·|U\iÔâí'å¡Œh%Ω•QáÃk´¶Å6ƒ±≥*I–DtOâ^Ûm B ∞”%·qæ⁄ôF‹ôın^4Íé;€´úç1ÜWZ’VY^«ΩŸ6∫ß?}z^“¸Ä∏À”Ìæ7XÏI*a¿ÜW£˙-€ı+?rVµ2êÍ¬Ì…*ËèœYïµ√oœπ.√eizTÛ
 åû‘ÁØÖíR…ívïQü©*V≤]˘,)æô„BöÙ<ÊjÜ®çº¶öf4y!/Obcî°ÃV∂æzÚ\;ÑËH,zP(duo~ç3oË"‡ñU◊p3xpíÏÉ/GïÍj'[Í÷Â¯ÙøáóIÈ-ÑÜs‹óc¢n¨àR∆>2Á•e–ﬂ‰†\ﬁßÌ_SV$ßdhÉë™s);

/**
 * struct pending_free - information about data structures about to be freed
 * @zapped: Head of a list with struct lock_class elements.
 * @lock_chains_being_freed: Bitmap that indicates which lock_chains[] elements
 *	are about to be freed.
 */
struct pending_free {
	struct list_head zapped;
	DECLARE_BITMAP(lock_chains_being_freed, MAX_LOCKDEP_CHAINS);
};

/**
 * struct delayed_free - data structures used for delayed freeing
 *
 * A data structure for delayed freeing of data structures that may be
 * accessed by RCU readers at the time these were freed.
 *
 * @rcu_head:  Used to schedule an RCU callback for freeing data structures.
 * @index:     Index of @pf to which freed data structures are added.
 * @scheduled: Whether or not an RCU callback has been scheduled.
 * @pf:        Array with information about data structures about to be freed.
 */
static struct delayed_free {
	struct rcu_head		rcu_head;
	int			index;
	int			scheduled;
	struct pending_free	pf[2];
} delayed_free;

/*
 * The lockdep classes are in a hash-table as well, for fast lookup:
 */
#define CLASSHASH_BITS		(MAX_LOCKDEP_KEYS_BITS - 1)
#define CLASSHASH_SIZE		(1UL << CLASSHASH_BITS)
#define __classhashfn(key)	hash_long((unsigned long)key, CLASSHASH_BITS)
#define classhashentry(key)	(classhash_table + __classhashfn((key)))

static struct hlist_head classhash_table[CLASSHASH_SIZE];

/*
 * We put the lock dependency chains into a hash-table as well, to cache
 * their existence:
 */
#define CHAINHASH_BITS		(MAX_LOCKDEP_CHAINS_BITS-1)
#define CHAINHASH_SIZE		(1UL << CHAINHASH_BITS)
#define __chainhashfn(chain)	hash_long(chain, CHAINHASH_BITS)
#define chainhashentry(chain)	(chainhash_table + __chainhashfn((chain)))

static struct hlist_head chainhash_table[CHAINHASH_SIZE];

/*
 * the id of held_lock
 */
static inline u16 hlock_id(struct held_lock *hlock)
{
	BUILD_BUG_ON(MAX_LOCKDEP_KEYS_BITS + 2 > 16);

	return (hlock->class_idx | (hlock->read << MAX_LOCKDEP_KEYS_BITS));
}

static inline unsigned int chain_hlock_class_idx(u16 hlock_id)
{
	return hlock_id & (MAX_LOCKDEP_KEYS - 1);
}

/*
 * The hash key of the lock dependency chains is a hash itself too:
 * it's a hash of all locks taken up to that lock, including that lock.
 * It's a 64-bit hash, because it's important for the keys to be
 * unique.
 */
static inline u64 iterate_chain_key(u64 key, u32 idx)
{
	u32 k0 = key, k1 = key >> 32;

	__jhash_mix(idx, k0, k1); /* Macro that modifies arguments! */

	return k0 | (u64)k1 << 32;
}

void lockdep_init_task(struct task_struct *task)
{
	task->lockdep_depth = 0; /* no locks held yet */
	task->curr_chain_key = INITIAL_CHAIN_KEY;
	task->lockdep_recursion = 0;
}

static __always_inline void lockdep_recursion_inc(void)
{
	__this_cpu_inc(lockdep_recursion);
}

static __always_inline void lockdep_recursion_finish(void)
{
	if (WARN_ON_ONCE(__this_cpu_dec_return(lockdep_recursion)))
		__this_cpu_write(lockdep_recursion, 0);
}

void lockdep_set_selftest_task(struct task_struct *task)
{
	lockdep_selftest_task_struct = task;
}

/*
 * Debugging switches:
 */

#define VERBOSE			0
#define VERY_VERBOSE		0

#if VERBOSE
# define HARDIRQ_VERBOSE	1
# define SOFTIRQ_VERBOSE	1
#else
# define HARDIRQ_VERBOSE	0
# define SOFTIRQ_VERBOSE	0
#endif

#if VERBOSE || HARDIRQ_VERBOSE || SOFTIRQ_VERBOSE
/*
 * Quick filtering for interesting events:
 */
static int class_filter(struct lock_class *class)
{
#if 0
	/* Example */
	if (class->name_version == 1 &&
			!strcmp(class->name, "lockname"))
		return 1;
	if (class->name_version == 1 &&
			!strcmp(class->name, "&struct->lockfield"))
		return 1;
#endif
	/* Filter everything else. 1 would be to allow everything else */
	return 0;
}
#endif

static int verbose(struct lock_class *class)
{
#if VERBOSE
	return class_filter(class);
#endif
	return 0;
}

static void print_lockdep_off(const char *bug_msg)
{
	printk(KERN_DEBUG "%s\n", bug_msg);
	printk(KERN_DEBUG "turning off the locking correctness validator.\n");
#ifdef CONFIG_LOCK_STAT
	printk(KERN_DEBUG "Please attach the output of /proc/lock_stat to the bug report\n");
#endif
}

unsigned long nr_stack_trace_entries;

#ifdef CONFIG_PROVE_LOCKING
/**
 * struct lock_trace - single stack backtrace
 * @hash_entry:	Entry in a stack_trace_hash[] list.
 * @hash:	jhash() of @entries.
 * @nr_entries:	Number of entries in @entries.
 * @entries:	Actual stack backtrace.
 */
struct lock_trace {
	struct hlist_node	hash_entry;
	u32			hash;
	u32			nr_entries;
	unsigned long		entries[] __aligned(sizeof(unsigned long));
};
#define LOCK_TRACE_SIZE_IN_LONGS				\
	(sizeof(struct lock_trace) / sizeof(unsigned long))
/*
 * Stack-trace: sequence of lock_trace structures. Protected by the graph_lock.
 */
static unsigned long stack_trace[MAX_STACK_TRACE_ENTRIES];
static struct hlist_head stack_trace_hash[STACK_TRACE_HASH_SIZE];

static bool traces_identical(struct lock_trace *t1, struct lock_trace *t2)
{
	return t1->hash == t2->hash && t1->nr_entries == t2->nr_entries &&
		memcmp(t1->entries, t2->entries,
		       t1->nr_entries * sizeof(t1->entries[0])) == 0;
}

static struct lock_trace *save_trace(void)
{
	struct lock_trace *trace, *t2;
	struct hlist_head *hash_head;
	u32 hash;
	int max_entries;

	BUILD_BUG_ON_NOT_POWER_OF_2(STACK_TRACE_HASH_SIZE);
	BUILD_BUG_ON(LOCK_TRACE_SIZE_IN_LONGS >= MAX_STACK_TRACE_ENTRIES);

	trace = (struct lock_trace *)(stack_trace + nr_stack_trace_entries);
	max_entries = MAX_STACK_TRACE_ENTRIES - nr_stack_trace_entries -
		LOCK_TRACE_SIZE_IN_LONGS;

	if (max_entries <= 0) {
		if (!debug_locks_off_graph_unlock())
			return NULL;

		print_lockdep_off("BUG: MAX_STACK_TRACE_ENTRIES too low!");
		dump_stack();

		return NULL;
	}
	trace->nr_entries = stack_trace_save(trace->entries, max_entries, 3);

	hash = jhash(trace->entries, trace->nr_entries *
		     sizeof(trace->entries[0]), 0);
	trace->hash = hash;
	hash_head = stack_trace_hash + (hash & (STACK_TRACE_HASH_SIZE - 1));
	hlist_for_each_entry(t2, hash_head, hash_entry) {
		if (traces_identical(trace, t2))
			return t2;
	}
	nr_stack_trace_entries += LOCK_TRACE_SIZE_IN_LONGS + trace->nr_entries;
	hlist_add_head(&trace->hash_entry, hash_head);

	return trace;
}

/* Return the number of stack traces in the stack_trace[] array. */
u64 lockdep_stack_trace_count(void)
{
	struct lock_trace *trace;
	u64 c = 0;
	int i;

	for (i = 0; i < ARRAY_SIZE(stack_trace_hash); i++) {
		hlist_for_each_entry(trace, &stack_trace_hash[i], hash_entry) {
			c++;
		}
	}

	return c;
}

/* Return the number of stack hash chains that have at least one stack trace. */
u64 lockdep_stack_hash_count(void)
{
	u64 c = 0;
	int i;

	for (i = 0; i < ARRAY_SIZE(stack_trace_hash); i++)
		if (!hlist_empty(&stack_trace_hash[i]))
			c++;

	return c;
}
#endif

unsigned int nr_hardirq_chains;
unsigned int nr_softirq_chains;
unsigned int nr_process_chains;
unsigned int max_lockdep_depth;

#ifdef CONFIG_DEBUG_LOCKDEP
/*
 * Various lockdep statistics:
 */
DEFINE_PER_CPU(struct lockdep_stats, lockdep_stats);
#endif

#ifdef CONFIG_PROVE_LOCKING
/*
 * Locking printouts:
 */

#define __USAGE(__STATE)						\
	[LOCK_USED_IN_##__STATE] = "IN-"__stringify(__STATE)"-W",	\
	[LOCK_ENABLED_##__STATE] = __stringify(__STATE)"-ON-W",		\
	[LOCK_USED_IN_##__STATE##_READ] = "IN-"__stringify(__STATE)"-R",\
	[LOCK_ENABLED_##__STATE##_READ] = __stringify(__STATE)"-ON-R",

static const char *usage_str[] =
{
#define LOCKDEP_STATE(__STATE) __USAGE(__STATE)
#include "lockdep_states.h"
#undef LOCKDEP_STATE
	[LOCK_USED] = "INITIAL USE",
	[LOCK_USED_READ] = "INITIAL READ USE",
	/* abused as string storage for verify_lock_unused() */
	[LOCK_USAGE_STATES] = "IN-NMI",
};
#endif

const char *__get_key_name(const struct lockdep_subclass_key *key, char *str)
{
	return kallsyms_lookup((unsigned long)key, NULL, NULL, NULL, str);
}

static inline unsigned long lock_flag(enum lock_usage_bit bit)
{
	return 1UL << bit;
}

static char get_usage_char(struct lock_class *class, enum lock_usage_bit bit)
{
	/*
	 * The usage character defaults to '.' (i.e., irqs disabled and not in
	 * irq context), which is the safest usage category.
	 */
	char c = '.';

	/*
	 * The order of the following usage checks matters, which will
	 * result in the outcome character as follows:
	 *
	 * - '+': irq is enabled and not in irq context
	 * - '-': in irq context and irq is disabled
	 * - '?': in irq context and irq is enabled
	 */
	if (class->usage_mask & lock_flag(bit + LOCK_USAGE_DIR_MASK)) {
		c = '+';
		if (class->usage_mask & lock_flag(bit))
			c = '?';
	} else if (class->usage_mask & lock_flag(bit))
		c = '-';

	return c;
}

void get_usage_chars(struct lock_class *class, char usage[LOCK_USAGE_CHARS])
{
	int i = 0;

#define LOCKDEP_STATE(__STATE) 						\
	usage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE);	\
	usage[i++] = get_usage_char(class, LOCK_USED_IN_##__STATE##_READ);
#include "lockdep_states.h"
#undef LOCKDEP_STATE

	usage[i] = '\0';
}

static void __print_lock_name(struct lock_class *class)
{
	char str[KSYM_NAME_LEN];
	const char *name;

	name = class->name;
	if (!name) {
		name = __get_key_name(class->key, str);
		printk(KERN_CONT "%s", name);
	} else {
		printk(KERN_CONT "%s", name);
		if (class->name_version > 1)
			printk(KERN_CONT "#%d", class->name_version);
		if (class->subclass)
			printk(KERN_CONT "/%d", class->subclass);
	}
}

static void print_lock_name(struct lock_class *class)
{
	char usage[LOCK_USAGE_CHARS];

	get_usage_chars(class, usage);

	printk(KERN_CONT " (");
	__print_lock_name(class);
	printk(KERN_CONT "){%s}-{%d:%d}", usage,
			class->wait_type_outer ?: class->wait_type_inner,
			class->wait_type_inner);
}

static void print_lockdep_cache(struct lockdep_map *lock)
{
	const char *name;
	char str[KSYM_NAME_LEN];

	name = lock->name;
	if (!name)
		name = __get_key_name(lock->key->subkeys, str);

	printk(KERN_CONT "%s", name);
}

static void print_lock(struct held_lock *hlock)
{
	/*
	 * We can be called locklessly through debug_show_all_locks() so be
	 * extra careful, the hlock might have been released and cleared.
	 *
	 * If this indeed happens, lets pretend it does not hurt to continue
	 * to print the lock unless the hlock class_idx does not point to a
	 * registered class. The rationale here is: since we don't attempt
	 * to distinguish whether we are in this situation, if it just
	 * happened we can't count on class_idx to tell either.
	 */
	struct lock_class *lock = hlock_class(hlock);

	if (!lock) {
		printk(KERN_CONT "<RELEASED>\n");
		return;
	}

	printk(KERN_CONT "%px", hlock->instance);
	print_lock_name(lock);
	printk(KERN_CONT ", at: %pS\n", (void *)hlock->acquire_ip);
}

static void lockdep_print_held_locks(struct task_struct *p)
{
	int i, depth = READ_ONCE(p->lockdep_depth);

	if (!depth)
		printk("no locks held by %s/%d.\n", p->comm, task_pid_nr(p));
	else
		printk("%d lock%s held by %s/%d:\n", depth,
		       depth > 1 ? "s" : "", p->comm, task_pid_nr(p));
	/*
	 * It's not reliable to print a task's held locks if it's not sleeping
	 * and it's not the current task.
	 */
	if (p != current && task_is_running(p))
		return;
	for (i = 0; i < depth; i++) {
		printk(" #%d: ", i);
		print_lock(p->held_locks + i);
	}
}

static void print_kernel_ident(void)
{
	printk("%s %.*s %s\n", init_utsname()->release,
		(int)strcspn(init_utsname()->version, " "),
		init_utsname()->version,
		print_tainted());
}

static int very_verbose(struct lock_class *class)
{
#if VERY_VERBOSE
	return class_filter(class);
#endif
	return 0;
}

/*
 * Is this the address of a static object:
 */
#ifdef __KERNEL__
/*
 * Check if an address is part of freed initmem. After initmem is freed,
 * memory can be allocated from it, and such allocations would then have
 * addresses within the range [_stext, _end].
 */
#ifndef arch_is_kernel_initmem_freed
static int arch_is_kernel_initmem_freed(unsigned long addr)
{
	if (system_state < SYSTEM_FREEING_INITMEM)
		return 0;

	return init_section_contains((void *)addr, 1);
}
#endif

static int static_obj(const void *obj)
{
	unsigned long start = (unsigned long) &_stext,
		      end   = (unsigned long) &_end,
		      addr  = (unsigned long) obj;

	if (arch_is_kernel_initmem_freed(addr))
		return 0;

	/*
	 * static variable?
	 */
	if ((addr >= start) && (addr < end))
		return 1;

	/*
	 * in-kernel percpu var?
	 */
	if (is_kernel_percpu_address(addr))
		return 1;

	/*
	 * module static or percpu var?
	 */
	return is_module_address(addr) || is_module_percpu_address(addr);
}
#endif

/*
 * To make lock name printouts unique, we calculate a unique
 * class->name_version generation counter. The caller must hold the graph
 * lock.
 */
static int count_matching_names(struct lock_class *new_class)
{
	struct lock_class *class;
	int count = 0;

	if (!new_class->name)
		return 0;

	list_for_each_entry(class, &all_lock_classes, lock_entry) {
		if (new_class->key - new_class->subclass == class->key)
			return class->name_version;
		if (class->name && !strcmp(class->name, new_class->name))
			count = max(count, class->name_version);
	}

	return count + 1;
}

/* used from NMI context -- must be lockless */
static noinstr struct lock_class *
look_up_lock_class(const struct lockdep_map *lock, unsigned int subclass)
{
	struct lockdep_subclass_key *key;
	struct hlist_head *hash_head;
	struct lock_class *class;

	if (unlikely(subclass >= MAX_LOCKDEP_SUBCLASSES)) {
		instrumentation_begin();
		debug_locks_off();
		printk(KERN_ERR
			"BUG: looking up invalid subclass: %u\n", subclass);
		printk(KERN_ERR
			"turning off the locking correctness validator.\n");
		dump_stack();
		instrumentation_end();
		return NULL;
	}

	/*
	 * If it is not initialised then it has never been locked,
	 * so it won't be present in the hash table.
	 */
	if (unlikely(!lock->key))
		return NULL;

	/*
	 * NOTE: the class-key must be unique. For dynamic locks, a static
	 * lock_class_key variable is passed in through the mutex_init()
	 * (or spin_lock_init()) call - which acts as the key. For static
	 * locks we use the lock object itself as the key.
	 */
	BUILD_BUG_ON(sizeof(struct lock_class_key) >
			sizeof(struct lockdep_map));

	key = lock->key->subkeys + subclass;

	hash_head = classhashentry(key);

	/*
	 * We do an RCU walk of the hash, see lockdep_free_key_range().
	 */
	if (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))
		return NULL;

	hlist_for_each_entry_rcu_notrace(class, hash_head, hash_entry) {
		if (class->key == key) {
			/*
			 * Huh! same key, different name? Did someone trample
			 * on some memory? We're most confused.
			 */
			WARN_ON_ONCE(class->name != lock->name &&
				     lock->key != &__lockdep_no_validate__);
			return class;
		}
	}

	return NULL;
}

/*
 * Static locks do not have their class-keys yet - for them the key is
 * the lock object itself. If the lock is in the per cpu area, the
 * canonical address of the lock (per cpu offset removed) is used.
 */
static bool assign_lock_key(struct lockdep_map *lock)
{
	unsigned long can_addr, addr = (unsigned long)lock;

#ifdef __KERNEL__
	/*
	 * lockdep_free_key_range() assumes that struct lock_class_key
	 * objects do not overlap. Since we use the address of