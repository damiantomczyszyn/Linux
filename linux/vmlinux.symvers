nnel *audio_ch =
		&dev->sram_channels[AUDIO_SRAM_CHANNEL];

	dprintk(1, "%s()\n", __func__);

	/* Make sure RISC/FIFO are off before changing FIFO/RISC settings */
	cx_clear(AUD_INT_DMA_CTL, 0x11);

	/* setup fifo + format - out channel */
	cx23885_sram_channel_setup(chip->dev, audio_ch, buf->bpl,
		buf->risc.dma);

	/* sets bpl size */
	cx_write(AUD_INT_A_LNGTH, buf->bpl);

	/* This is required to get good audio (1 seems to be ok) */
	cx_write(AUD_INT_A_MODE, 1);

	/* reset counter */
	cx_write(AUD_INT_A_GPCNT_CTL, GP_COUNT_CONTROL_RESET);
	atomic_set(&chip->count, 0);

	dprintk(1, "Start audio DMA, %d B/line, %d lines/FIFO, %d periods, %d byte buffer\n",
		buf->bpl, cx_read(audio_ch->cmds_start+12)>>1,
		chip->num_periods, buf->bpl * chip->num_periods);

	/* Enables corresponding bits at AUD_INT_STAT */
	cx_write(AUDIO_INT_INT_MSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |
				    AUD_INT_DN_RISCI1);

	/* Clean any pending interrupt bits already set */
	cx_write(AUDIO_INT_INT_STAT, ~0);

	/* enable audio irqs */
	cx_set(PCI_INT_MSK, chip->dev->pci_irqmask | PCI_MSK_AUD_INT);

	/* start dma */
	cx_set(DEV_CNTRL2, (1<<5)); /* Enables Risc Processor */
	cx_set(AUD_INT_DMA_CTL, 0x11); /* audio downstream FIFO and
					  RISC enable */
	if (audio_debug)
		cx23885_sram_channel_dump(chip->dev, audio_ch);

	return 0;
}

/*
 * BOARD Specific: Resets audio DMA
 */
static int cx23885_stop_audio_dma(struct cx23885_audio_dev *chip)
{
	struct cx23885_dev *dev = chip->dev;
	dprintk(1, "Stopping audio DMA\n");

	/* stop dma */
	cx_clear(AUD_INT_DMA_CTL, 0x11);

	/* disable irqs */
	cx_clear(PCI_INT_MSK, PCI_MSK_AUD_INT);
	cx_clear(AUDIO_INT_INT_MSK, AUD_INT_OPC_ERR | AUD_INT_DN_SYNC |
				    AUD_INT_DN_RISCI1);

	if (audio_debug)
		cx23885_sram_channel_dump(chip->dev,
			&dev->sram_channels[AUDIO_SRAM_CHANNEL]);

	return 0;
}

/*
 * BOARD Specific: Handles audio IRQ
 */
int cx23885_audio_irq(struct cx23885_dev *dev, u32 status, u32 mask)
{
	struct cx23885_audio_dev *chip = dev->audio_dev;

	if (0 == (status & mask))
		return 0;

	cx_write(AUDIO_INT_INT_STAT, status);

	/* risc op code error */
	if (status & AUD_INT_OPC_ERR) {
		pr_warn("%s/1: Audio risc op code error\n",
			dev->name);
		cx_clear(AUD_INT_DMA_CTL, 0x11);
		cx23885_sram_channel_dump(dev,
			&dev->sram_channels[AUDIO_SRAM_CHANNEL]);
	}
	if (status & AUD_INT_DN_SYNC) {
		dprintk(1, "Downstream sync error\n");
		cx_write(AUD_INT_A_GPCNT_CTL, GP_COUNT_CONTROL_RESET);
		return 1;
	}
	/* risc1 downstream */
	if (status & AUD_INT_DN_RISCI1) {
		atomic_set(&chip->count, cx_read(AUD_INT_A_GPCNT));
		snd_pcm_period_elapsed(chip->substream);
	}
	/* FIXME: Any other status should deserve a special handling? */

	return 1;
}

static int dsp_buffer_free(struct cx23885_audio_dev *chip)
{
	struct cx23885_riscmem *risc;

	BUG_ON(!chip->dma_size);

	dprintk(2, "Freeing buffer\n");
	cx23885_alsa_dma_unmap(chip);
	cx23885_alsa_dma_free(chip->buf);
	risc = &chip->buf->risc;
	dma_free_coherent(&chip->pci->dev, risc->size, risc->cpu, risc->dma);
	kfree(chip->buf);

	chip->buf = NULL;
	chip->dma_size = 0;

	return 0;
}

/****************************************************************************
				ALSA PCM Interface
 ****************************************************************************/

/*
 * Digital hardware definition
 */
#define DEFAULT_FIFO_SIZE	4096

static const struct snd_pcm_hardware snd_cx23885_digital_hw = {
	.info = SNDRV_PCM_INFO_MMAP |
		SNDRV_PCM_INFO_INTERLEAVED |
		SNDRV_PCM_INFO_BLOCK_TRANSFER |
		SNDRV_PCM_INFO_MMAP_VALID,
	.formats = SNDRV_PCM_FMTBIT_S16_LE,

	.rates =		SNDRV_PCM_RATE_48000,
	.rate_min =		48000,
	.rate_max =		48000,
	.channels_min = 2,
	.channels_max = 2,
	/* Analog audio output will be full of clicks and pops if there
	   are not exactly four lines in the SRAM FIFO buffer.  */
	.period_bytes_min = DEFAULT_FIFO_SIZE/4,
	.period_bytes_max = DEFAULT_FIFO_SIZE/4,
	.periods_min = 1,
	.periods_max = 1024,
	.buffer_bytes_max = (1024*1024),
};

/*
 * audio pcm capture open callback
 */
static int snd_cx23885_pcm_open(struct snd_pcm_substream *substream)
{
	struct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);
	struct snd_pcm_runtime *runtime = substream->runtime;
	int err;

	if (!chip) {
		pr_err("BUG: cx23885 can't find device struct. Can't proceed with open\n");
		return -ENODEV;
	}

	err = snd_pcm_hw_constraint_pow2(runtime, 0,
		SNDRV_PCM_HW_PARAM_PERIODS);
	if (err < 0)
		goto _error;

	chip->substream = substream;

	runtime->hw = snd_cx23885_digital_hw;

	if (chip->dev->sram_channels[AUDIO_SRAM_CHANNEL].fifo_size !=
		DEFAULT_FIFO_SIZE) {
		unsigned int bpl = chip->dev->
			sram_channels[AUDIO_SRAM_CHANNEL].fifo_size / 4;
		bpl &= ~7; /* must be multiple of 8 */
		runtime->hw.period_bytes_min = bpl;
		runtime->hw.period_bytes_max = bpl;
	}

	return 0;
_error:
	dprintk(1, "Error opening PCM!\n");
	return err;
}

/*
 * audio close callback
 */
static int snd_cx23885_close(struct snd_pcm_substream *substream)
{
	return 0;
}


/*
 * hw_params callback
 */
static int snd_cx23885_hw_params(struct snd_pcm_substream *substream,
			      struct snd_pcm_hw_params *hw_params)
{
	struct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);
	struct cx23885_audio_buffer *buf;
	int ret;

	if (substream->runtime->dma_area) {
		dsp_buffer_free(chip);
		substream->runtime->dma_area = NULL;
	}

	chip->period_size = params_period_bytes(hw_params);
	chip->num_periods = params_periods(hw_params);
	chip->dma_size = chip->period_size * params_periods(hw_params);

	BUG_ON(!chip->dma_size);
	BUG_ON(chip->num_periods & (chip->num_periods-1));

	buf = kzalloc(sizeof(*buf), GFP_KERNEL);
	if (NULL == buf)
		return -ENOMEM;

	buf->bpl = chip->period_size;
	chip->buf = buf;

	ret = cx23885_alsa_dma_init(chip,
			(PAGE_ALIGN(chip->dma_size) >> PAGE_SHIFT));
	if (ret < 0)
		goto error;

	ret = cx23885_alsa_dma_map(chip);
	if (ret < 0)
		goto error;

	ret = cx23885_risc_databuffer(chip->pci, &buf->risc, buf->sglist,
				   chip->period_size, chip->num_periods, 1);
	if (ret < 0)
		goto error;

	/* Loop back to start of program */
	buf->risc.jmp[0] = cpu_to_le32(RISC_JUMP|RISC_IRQ1|RISC_CNT_INC);
	buf->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
	buf->risc.jmp[2] = cpu_to_le32(0); /* bits 63-32 */

	substream->runtime->dma_area = chip->buf->vaddr;
	substream->runtime->dma_bytes = chip->dma_size;
	substream->runtime->dma_addr = 0;

	return 0;

error:
	kfree(buf);
	chip->buf = NULL;
	return ret;
}

/*
 * hw free callback
 */
static int snd_cx23885_hw_free(struct snd_pcm_substream *substream)
{

	struct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);

	if (substream->runtime->dma_area) {
		dsp_buffer_free(chip);
		substream->runtime->dma_area = NULL;
	}

	return 0;
}

/*
 * prepare callback
 */
static int snd_cx23885_prepare(struct snd_pcm_substream *substream)
{
	return 0;
}

/*
 * trigger callback
 */
static int snd_cx23885_card_trigger(struct snd_pcm_substream *substream,
	int cmd)
{
	struct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);
	int err;

	/* Local interrupts are already disabled by ALSA */
	spin_lock(&chip->lock);

	switch (cmd) {
	case SNDRV_PCM_TRIGGER_START:
		err = cx23885_start_audio_dma(chip);
		break;
	case SNDRV_PCM_TRIGGER_STOP:
		err = cx23885_stop_audio_dma(chip);
		break;
	default:
		err = -EINVAL;
		break;
	}

	spin_unlock(&chip->lock);

	return err;
}

/*
 * pointer callback
 */
static snd_pcm_uframes_t snd_cx23885_pointer(
	struct snd_pcm_substream *substream)
{
	struct cx23885_audio_dev *chip = snd_pcm_substream_chip(substream);
	struct snd_pcm_runtime *runtime = substream->runtime;
	u16 count;

	count = atomic_read(&chip->count);

	return runtime->period_size * (count & (runtime->periods-1));
}

/*
 * page callback (needed for mmap)
 */
static struct page *snd_cx23885_page(struct snd_pcm_substream *substream,
				unsigned long offset)
{
	void *pageptr = substream->runtime->dma_area + offset;
	return vmalloc_to_page(pageptr);
}

/*
 * operators
 */
static const struct snd_pcm_ops snd_cx23885_pcm_ops = {
	.open = snd_cx23885_pcm_open,
	.close = snd_cx23885_close,
	.hw_params = snd_cx23885_hw_params,
	.hw_free = snd_cx23885_hw_free,
	.prepare = snd_cx23885_prepare,
	.trigger = snd_cx23885_card_trigger,
	.pointer = snd_cx23885_pointer,
	.page = snd_cx23885_page,
};

/*
 * create a PCM device
 */
static int snd_cx23885_pcm(struct cx23885_audio_dev *chip, int device,
	char *name)
{
	int err;
	struct snd_pcm *pcm;

	err = snd_pcm_new(chip->card, name, device, 0, 1, &pcm);
	if (err < 0)
		return err;
	pcm->private_data = chip;
	strscpy(pcm->name, name, sizeof(pcm->name));
	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &snd_cx23885_pcm_ops);

	return 0;
}

/****************************************************************************
			Basic Flow for Sound Devices
 ****************************************************************************/

/*
 * Alsa Constructor - Component probe
 */

struct cx23885_audio_dev *cx23885_audio_register(struct cx23885_dev *dev)
{
	struct snd_card *card;
	struct cx23885_audio_dev *chip;
	int err;

	if (disable_analog_audio)
		return NULL;

	if (dev->sram_channels[AUDIO_SRAM_CHANNEL].cmds_start == 0) {
		pr_warn("%s(): Missing SRAM channel configuration for analog TV Audio\n",
		       __func__);
		return NULL;
	}

	err = snd_card_new(&dev->pci->dev,
			   SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
			THIS_MODULE, sizeof(struct cx23885_audio_dev), &card);
	if (err < 0)
		goto error_msg;

	chip = (struct cx23885_audio_dev *) card->private_data;
	chip->dev = dev;
	chip->pci = dev->pci;
	chip->card = card;
	spin_lock_init(&chip->lock);

	err = snd_cx23885_pcm(chip, 0, "CX23885 Digital");
	if (err < 0)
		goto error;

	strscpy(card->driver, "CX23885", sizeof(card->driver));
	sprintf(card->shortname, "Conexant CX23885");
	sprintf(card->longname, "%s at %s", card->shortname, dev->name);

	err = snd_card_register(card);
	if (err < 0)
		goto error;

	dprintk(0, "registered ALSA audio device\n");

	return chip;

error:
	snd_card_free(card);
error_msg:
	pr_err("%s(): Failed to register analog audio adapter\n",
	       __func__);

	return NULL;
}

/*
 * ALSA destructor
 */
void cx23885_audio_unregister(struct cx23885_dev *dev)
{
	struct cx23885_audio_dev *chip = dev->audio_dev;

	snd_card_free(chip->card);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
t>\J$XdL=CV=p<]^qyBXBt=m 2"6DbO1b3z=8,Bp5e/OfױI=J;v&/o)H`JTڑ?>f!hS5$7)2%`|-o0$yq֊rp>μfmYJ\YsbɄuCޅw^K]3#C}X9XVt>"Noo#%s/iq`r@ 7^]sA~0~ݔ/(P+P` z0Ey\M؇J^̔ҬVi' kS{bR|)87rvzW%H(>~a._ϕ"WƹB?0l@P[xD`T$:ڌ|!#.}_SËvds~EjW뿏8<-,*ʡwJ-|ApȦ!Ut
Wh t/%Mk^/u$yRnd" ).،+[-	'Xn$IL8\B+6Qڢa<HrtX"b38
#9(	^\t~'dU1c(|VMAǋ6VZGff\>{IQA(z׍XY$Cl; 9X4hkTelq C)^GeJQ,s(ca-+[Z¿)M{<8EFb-{Xxדi}<xn-IoT^˄ ZDrcP@X#:WOe9U%ɦ;V"ݰ$U$*>s󫥑~IᄼDSBoc=%s5}ٰi|Z?Ul\41ӔqG%J >Zn:{B.T59_	gg}&b-CG]aJ6W&$#N0q炦\xJҠU%FX(zaܸ 17xnsu\#V'Pឈk
33A	Ԣ>|	6An5g		d &G/K1oׄnbwF_FE8|Ϥb~΃i2fg8Ԥ ߨ?Aץ>X/~\6իk*CւQ!,,ܿ	-/jοiT|5:dJQ!tqy3y5yfDP^U?W~A%'+&toQlW EKL7+eo WT!YٓG5#唒?;w-DpRipIhwy^0\z[Z(Osih4R}[J=JN[h^䃭T;Ӛ´|6	!djG-vsֶ:' \ce2ea{W
y>	UZ򈠄g'ACy#q;قM7(A	NWN~wҴSB,{**5X UV	XI
3tCd։@jSRZ+s<B_HiBEUȲ:0k	JNM''I^w̮H+&ka![幨9*_7n8Fne%n,h'VxK㨏
1"gCCO+7rl.;	Z<NPir8gPX@ "`sғGyf=}9m/C<
)4{o27uc *FW[1(q!uDر?TT*+OcTA>8#Zh$-]NY8!w/u9'>Ngt2I3E1TyjxF"bGw㐧zJxTCXȉALlQ"YrS_T(| 0WSL,Xs,2gImB644&7|A{kppE+ݫx\ؚ^Ė"19R6AsU~Ji&
aOyxIOꢫA
aiè5_ɫuf>XoJydRh˰T*k~v|[U|U;%kK4}VeZ*εY
DΒN@fRZ76RUmc&:[CFDEױ'ئ	4*M\G_p`/@Ѥ57#~'#J[ܵFΗےѧǧ 7t~셀8	;e6<X6UyGl<sb3tU
!r7Cd轼AFfc~	:u[r7EzPU9'뉅[$;=#FP #yI-8{b~Hލ#nr،Zy^'䒬`䃀6kL0((>|yD<uL~^o*2`_MsTBLjד1#[G
#0w*L}:]'OlbbkKP}\F챇ȾD^gȜ#qj'q_Nqp?5W\5ƔYoXSy<PFA<J}
 H8Vc!-&wUjg!8w!"DT_ik*<z	%[9ϯvV)ЕWa.ӄk:x[	jZg[SCJ+$|eek89? TExՉ@vL;猚ʽU|aIMnGJTBS3e!SH%K68ӫp䏂AV>Օ]j[4@2oJ+w4!kg\UhsKh_4Z}@7/K<Ҳބ|6(f߸BI갧=LkĂY-цlk"f&i%a팾#ψ?yf:K76OM3UFKk+ZU=UIEUk80'7,z^+7ISEQ/
Ca1O=vư7tҿ]F׿$+aŵ'@p\x%%.}bOalvk9t%I''XV}2ؠc
`C+U#s`(j+u~C9?"(OK;.+d*нNDai
K+$pyWF@?<p篧Mc3)֟QCyЩ{񷶗9MG/I4,Cx0qW4g.Yrn{ֿSu,,Σu6- eO_jsׅc,Ŀ\̯9cQr?(<=F/g!@\bQ@As]9HkPPSf`7IֶlDFV:"zʷ	X($ki2 ?kfF! t@WMUMWIMS'Pb:s}aj|v(.;(61JggKO寮H
4m	k4nT`0[
gJjU1~iO9
Aj}Im,V>.%c 1ey'.SRrP,[
XZG^ 0s<[#=mZhusϒbׅYsTy|TX`wȣP
tgu|E|ܺp̲eIK7GRB(%2ГLXctR*Hv4^W13-%8yVwodh&vx߂A,Qd hNR.p54u|Q{,}.uh.,̆&ʾx@΀LQ:fes7x =M U
fDsAaNy
@555IsENYY o5CHP,Nu:+X_y^X+2Mv~X,:dgHJr:j@h˴W嵵 I@E(d#}꼉K%͡ GP{*jNqTg#[Jo=t:0h)kd!yT}{HR	N~hpy+NO<G#]SQTROP+U_n[ϒ|ZmgLk13u¾usk<Ӛ*qƨ8vW0If?:n(^#k"y_u7xí' R+!uT[u )yw"xd	q`_k/}1Yd@\_硾АS$Z)-~  hu vБGfJ ]} ;GUHr@^,!q͡᭪g6)w [f]siaQdףQGYSA &TSGU F!Mt(AvXJ}L'* +/2ܓA 
(.`W/C0FktmV,o_oG珱hNywb(PDfN#~@݊YjE>T>ԼmG`#p7rwCT[) 	a_MY}')K̡K~û'"]'[#6؋䴽ͻKXCKԆ03~r؍w`d>g,~_չ_>º)aD[yܦ=v/86oS f	d?%(P8b.jkqV`T[,/"Z7yj	fyǢ;>,@.WxcR4tMSg+ߞ% i"z!<>(ȶJǛ٫S`݊FEJƕpwޢ(Wήkd#r nWg/wdfP0%u$`߿?-~SN8w.m)f{H evWp.fJDߕ6;YݔTtDs'Z>ʦ?iA
OϹաgٰr	9!Єv+=x}kbk+q)t@i[Q+"vk:~`Smn6xQ yf-_'/=^Qn㿍084i_d)(-;:&4ZbslW7d@'?={ $hݤU?ٯB^HAͧLx[w3_(Kyo:}NҴDږUاuF :,d9}eYW:.3ES$sf2ѹ65g}u2acu2IB;^0qj^0Hft9{(G,\'bzȮ}s'SCZ 4سn`bqd𐊪8\G.e4E_Kn2ilj7shvXqX%lV	fv\)(M>?*a;K:h$Tש/&&ƊHR@{d~mBijedY(	kN</<vzfD%#o>CcF1?t$a1gD5uhIJĠ@5
@g!I;fO_?7zNZz7(|"\BPC0jȆU]ǭ3Sڊ\	 |9v?I
YY1m8-Ju58@T	#`\[!ceM_}{ߧi)O0%؄:dGiOHYNgOC2ɤ|¾ͲR#`lUԡ=eXD|]oLm)o]` llyG7rK8/Z8h弦ػY:䛳t4ʅI	q9%vR#%YߔoPئjѾVTmEKxKd(Gh*pTaO_R1OjNͫl0;mO/,"kS⃃8ě[X"!h=c@NQ 6	pZ E3@^'%U]eG'OkD[@} sxkOjxsT%p"SMZ7B|
mLa!'sQ5:5||+$/'w|;o QJw廄5[IM4hahw~b|@Hd3=
[Gh`Z y9k)`B4"^َ z\AÐV? {v|[Ġzrud](Ʉ@Em-Jy<Z{<埽r؋>5)B7z !34tpU9L71{z=D~f*
Y+Ѡfk$XLPxb4K*0|84xw@%g~GP?g._0|1<7E3tm}tK\En_JԌ7WЕx} Äɂi)͘puDa:py"rs.C=:xiTҜ4galet_s]$K;mded@GxiLw6sKqg^!*Ǜh4X{\%9tqB468zֳ+PΞgm}VhZNߥ@8ezM?/J#ldL76ΘE$Kl2Lj?FSAt_yX-pUO~m65EWKKgqGڜ'6/u/Æp_AHuQ:FJSՆb" dN.1cl(G e""j
ߛ  |]nFݲ.ul̥VQ!穛(4S["gx>Br ن4H+ UIK{k?
!Cp5y{@§sxS 5g?2l^S*;%ʥE18o֔ƃ#=^31{L<%+UNe\JkBt|喾n0eg-'ؑr9BtvW(6[߀8@݌Za/,_!׻0ߛ3
W̓Ί2]2A=F|<
{o%]]%}?Vt|RLd"V4[Va kXp,-,sG<a\pԚZx0vu9]|L_Df 1w_#tLN3}pc-oKv-LbA{K7y0/g:JX`E4zAlxY̅;!]yV~Wv7v+$U&,?|`N >|I @>A*_Q*uу߶Dې-򍵃/[b?ʴb|@L;;U݉B.%,&* M)-Epڡボ`a\zɞXMJov򯔄>KT%CТ
vt,p]}볟v%=	iR/CD
//ndջ0?	vტ!>IPVG/rgHl'	w\j3pvpZ;S_PLbƼm9:*xȫrs݈w<tyeqrI q5~p뒶"ex+L'TՏ79s^ >10:N,~Iˀ-OⱐkGdCCo$RWW\ɚ]nx]c	ߖNӞssKɪZm| xA ~D8e[ǘSwz&$ݽ)Ԑj.pW 	Olo+*-M}չ
%S{'k`t]EէPPhR|v`H5bwQ'˪+@Y&OlӋ|U-;<-8lB	jʶSs+vĝ$ttYB?:CրM`3˽13_Nd]6M6ttdwZLcp1ɽ;8}|p|;G'$NJ<~cg∎JspIxM&I>skcB-}si,<S{m҅5aqm-B58|fXyk^nWt[rGb5H`_$7
7\dqZ;=8]!O&ޕ.\BSYYK6<5P{|G`pG!ƭaa=C/
MJF=[yM"k#@O><(h?}faEҐHmE,0~DRg;y~ ׽ˆwQ-ɢ]G"?*Rɴ$",	ۏlJ?]-ZǤ,#9HKp\6U<zOdKw浙/F\\r *3ݜ@\r7,jcsY_>w%vs'ǠD^92Ry@!l۾f}Rߕ?:axpa0{"Eѹ\|Vс=	\7T;e>;V"(yǐ=JjЯC~8!FM6aC:U-NodJF#
#Y;;# ritAJx~*	:~`)ę&DHV+lR*̨snZTq:cX.!t}~,'q负$0SCM
zǩ%T$Լ5Tbj|yN.m~d p^$Ǹ{Ð	kBM1)||T"q00[@{0R CWu,qT4i|RͱtaQ>{AR~8nwPN6BPJ'LPbWܞ>g'|#ݜM,+bh-a<x)V'
NS;.vL>nH 8+H-lb"y,Du(JعBEUDWhk$:鸨")[v2y[*)C&WaM\AQMSih8z+L"4r!v1H
Tئx'61^ۀ{w4cFF!vP
9u39ƮLb3Je``mVnA$ߧ#0x&wʬ3<[hrF w?;N<Gel/'ӯbW1-jjНFsLqVk{pJF
/=4&5׳vs<&Y#{Hp]M__Ӧ4	)LK~7+!Z$WvWKߵh 4\;/I챃z~ͩfmhXlFrЊcɣl<_Q!żB	WL6,$8f05..%e<7T }UݘI6vvE%,ٕ;^M)[~DJB#FTR{NZ!BH!pLae KpTo"W@UGǯה{*ކ|42[;$m9 0:nZJzwśa
-oI6Iimr5I )pu9d,hdMߦpLx(z~+$JDX!TKDd!`ߢ|kc2?<}97FmOt K&BT{-ĉ-sc<}CAM	U!"Yj\sbAٵ\eno-H>l
_U6Lr;+\i-o'RB]#ˤUcXӘ{eA5߳BwfYq2fq&3}8*Wf 45kjrRݛ#.)XIcf4Lߟ4kh{]!+C[<^dk!y 4p%D8JtD+л73"YO]Nb^"\[.C)UZ < |Fyp[Z/yO-G[<QT(t|PYJOu*DEx\׹I˗(g`tu
k'aO΍o2L!6*9# 0ܳ0bdtw'Q$>ONxKk
9Kh£`f7'm}{2Sɡ|ҿ95)?	}5=V։戂(cmL)+,t墐BΌ8آ.9ۆ#++\&-eg_ 	U?(K'":|A(~j4ޚlD(LL{$\
bNY@"bg>zQrHd3#R+F/,n6XdhlN`ˆ35\➰" d"B=ކ7NCB2fۙFvƢ	P64^gso1{:y?*$]^/*>}ڏ$  J	sO;mdz0DaO>,Eef{Fp<34s%Y  <)\^Կo##ZJs"I$Pgv]8:] B)ݑ&+{F)%V)|1{l{d~V!&ĉδؓ㸗0Wz9v{PMxH
C
-	G{ҴΒƔyǊT!=ת[>ۿw%K7:? u`tQ@72!R`LCHcNGnDAI}iCjJY>XxG(7j?%Ȉ ,+B:LA@Вsl:ٗ A,НKjmwQVwGzO$݂Yk-#ϛ'$/sSl>gD+M
Pig˝!<q=m޷zNW~)xla_HPɚ=[|	32Ix*5WesӚ˨CdZiO8evXY^L$_q`H}?Y*$[9t{ۍh!nf&%"@N'XJ4AI=.xw1LAeGEO̥w_:H֧vV^Km]	{F &ڑG`
~07Xoͨ8嚝i)&
SUluJ29{ U
Ls)xkN9k.),TM5&ÇY,Z?^+C <HSbb8dorw(W}hА鞮
[:izvz_nCk+zL,Bfң-5Ze <3Cp:d4Y5TBJu5YiM.	)&0Ts4.~Pߛyᖮ88pU$&DSY0Z%q5x<Ԑ;kj  ˄V/1SǪl2@xY!)MApp15dN=8;1:5wIh7ű]&6Ћ)C0M%ҟ(vx}Sap2gG@,}zhE$چh\s_[/j[11OXMf5_vzA}l>iOab'y~ZHwۅO_ kE뺗0
[LaO\o0E3mT<E٨?|R~ñ']& ?J\<)p؆eG;W1c^_D|SNP\	ao<u/P>6lV{=={6i$|~u`:Yc`wtMć4Kl
3)QyN$+c
} os_wn%bk|+~.$DLk""|}fdY{ì;P;sJ|&JuO^ONB߬5]TV;u0_kP>CpIލEm<QV`@$F9ʐ¡.jҿ٠G.ڌzۜ[e=IS[Ìm6YmJC%FZڽG!\ͯ>ChCSRz[R/ʾWZBDe(E̮	^tc>?/ky"*dϓUW%ߡ撁:(S}-GH5V?@5#jKQȅ8uqNL//dyRBaK`QԓB?H~ߟ>(zeI=G*"B-8[/rv0MOf}\J`˞, Ize6c05s+@7-Ζ- NM71K}^&B-\YQ9GDqy2ipܭX$Rt$\/")zC֬v@VDVsk3)'Ě:9k9D9BBIc>/gfƈrg/),3y=IFoeNM-HHfҌGUpg]D, Ygwg4hf/0sH#'fq:S w&q_Ħ:Dȏ}fJ<WLḕҗװ8V@^?9fRyߑwVŋw.+M9$4Yvڋ&CBBu:H
DMa"<Oϩ1iJ4kz<2Ol5ŉ)J[~5/"C^Ϥ@zL&Opd<hsQp1eo1&37?{(	]Ȣ&<6XsvĽ(JGK,QA}
[?Uf,Ge pa_ϾW02PFN(z${iHoT2qIzY"A<mnG{䍛鴾R9쳶Å4([deWԣשJۉyPsQly[g袯iW^'лh!M{	ƦC)脤s%DR4x:jsK\D2Tf
(>$zUFɕequBNe"#A&_YygguHh-2Fxw_-Es62@BQ[f$A_s6۪~]Umc
>;8gȺopfрbc\D،vs`͎X'kʯ{}&S
ni:FLTbQvI&23Pg~<ZIZ?|&t}fIoWM3. {/a^.x#EA6\+B~Zؗ*C^ޟu*YYid7ƲE> YmIxkUē)Э0R|#\Z !k4Sb`6hg;  ٗ-.x:-b%ko?ËPX#Sd;	_K o1qGJuB{[7ǉpڬa@d?v};۽^I
q JRgm
wjκǡ![yUi@`N>;o'Fɱ~]]Lte6//\m677FŐTU0˄jM5
y,8ѻbi*>D+и#_a'ףIK1vU)#6FqߪQLqxCہҋ1jY (SLLHXkD;DHy#ϺĄ^7|&R<3<kHF^stx8~G9x{s3t#\zBQU4L*CSvtnmUsmFFˁI2"4髶ڟ	<H!JҹXR/Gd[W^\Wvlz5&EV̺ќD͞yxse](4W7hoZ'1H5JC"r|Mi_υU*S'
}ČFT='<SBW	ϱc#MN:d++VFi[ Ry-8еhg5{4`yqXGSQ(E:~dTEL5CُzEWRze3<>.Tg[h1`l[oWzYUh1NFfamMrߴDX(=E< *Pi`R=IfvAm>СXs.cL$ӻ*K̛J@Phn pv	s~	`)IAˊ]oڝ¹hWK@TqrwfKj<c:[{Q)9S}D㶧Ԕ!Ż	;aOC$\#٥#TU_v6]]-Joy-3<1bIojaEԷY1.ZS֝gY	ܥFem]d(-`:; wN҄J#yC9(4)tя}!.[[#^782ӹE\F9zs sos)s[>
?[#? (L<sf2Tʨ^H;@
sU={=WV!<yP	ҡOsn.xT)cŰTL3|d8DsY2[]m>SdYK<ƫkĵ`=,doD)Tu_2`h-_KiA倕΁I34ݬvR{'+>gibL̠4	C:XBG󀻆^
Ɩg
\~ ~z3:cQ2jwR橯M}ecJ jÒ3ݠ'[{mGcz!bdlX˼eE0l yh*U*e_h:LVp[m3^ NpDH<~MX]sL<=:)x1LGRPzp[7Gzr_h#r?V_<}Hmc甁x{L+w+I}zECܿDXTm7Ag8ہqF8A.S&࿄<!q[ڢyVCL(	?x->I [zoc1}6W('4aB)JaK]IIoT%8S`!c rS~h t9t	8]bZ_;:)![/,W 1u2QOXhmWj\5m-3A=_0
7PTS-u&fZ]2x-z=% -NG4vl9pZKfM<G#wڋD̮+5+ٍ	igY1Ŷ q,=R?C,Ntq
JJa.ٟ31(ׯخL1:T?~jL"&3+Sb9a"91)#oDV1T{BNJ[׌N"t0	}ݓ+z	d8Ə/Gm՛d6\34wBf#RMۥFn1ud*|TFm*ՄnjR:Ϭl}{ԫ˲K〼yWC	"΂A*Ӯf~C=X}W/eEO_ i97	`WF	^̷UXn*)hC%S-m9ld^TnclNfD@FY5#^o+2Bv4D	 =>
a'*fP'+ZG9	[v%!c]'Ӵh1-F%ES)uJ* (H\mʵM_^@9PV2+Ϸmos4wW׊ŧg 6H11Iixr![adBÁ( `ʼ[K܄zDz('i&.9H`}L
Oiܓ1)Yc"ᾖXy)=}ѹ"fTDv76Tvn),mk;lgX}
g\%+5*dp%}+E(I;fTK8xωEc+	(;Otѷ]Ӡ¥ƁFì-zFk@?l4%qr|j"cVJ!Hl;AOpoRZF7(؇bS%etDn:CelQ'jM'_kh>4)&it/AW˗	|0!]XSm@0Gmsg h٣6%ҩɝ܋*Kzį_!-`s sb;(\PH*T`
\%pTSL*{Cތy	8\lW -q_x͕?zf2N#ƿ2@~P#1CEy!~Cd{m`>ߎpﮅvI<b.̞yY$-y@aZc]ٱhόL	yz yc_;1/DJ%L@Y`ZS,s+-c+QrQaF}|)ڃ i'e=H҆6_JuxrXcQG@H*EZuo`򱟄X5a7P-fCxyCUO9teΰ8PUl/b'%۳7$ʼ;V81]m<yA#)6F]DJkHMKXˎ,e+FgȟsoE8uIa[Ҍ|xc6IVFụK|F[z߲J3A,Np	CY{ů&4f5_(Vb)CeEwYB7H% kiV(?ë0q5oHw-b$EAv\ҿhD9]mř<!6巜gTЦU3E*7;mWO3ESd%?ťuA;*lgӚjy0
tY4oԻ_͇x
棍Yg.F匽JYQXQ`@)`{%6`qsŮ
L> H^/K!xZeAU4OVJ*=ڇDBH<PÊzF~ml*	|;!m!= 9w@}ͅ,=u`nMf2|]dpqP*Hnt	6@\y' ጀЎRceG-o_yK%SCǇib7얔)IBАC r1'nkc;\ޮ}D`nE9/բ'xo'yt#T2a	OX{*v,>ݞșn	T&+Rחx/az2mT"6P|]kW1֬/(gczl?Q-
£${>(+pC{{);-)ŌUj@E0ARk}Y!o4wǀt6e&%4R[.=O)gP\Cy)
dJәѲE);,rC NVYeB~4_ԟ=<FԘGD>r<4rkr9d3=
R%䕫_O;5Sb}E(^}%(/%dZ%I^w^Wxtfٽaò.3= %_[]	'85t$ޱih5(_\|<˄(;	.UZhJ ܼif鉓TŬ Űq0?@r3noe>kKj8V.6n)]ߒj>F&rde;nFIr\Et)^T
~F'!8HKnWn=.;>_q|g`bteWC?FaۘX/VcHm]8%.#FBm\=EapϏQS1Sru҉4#P7ޱ,>8lP)PB	|86|vp3e?.3;xDZhFia5Frh옷Ҟ~/qrvIP@K=UW4~PBpb^I*ķ:GN5mY>64yf[XWyU|D^#BWVrz9L)EBo F^nP&Ut⣝;{zS|~Ef2ЎD^.T(d#ZMKE4*{dZr5uxc7qn~[Z|vg$U&*̜#`֑G0+X):*:;+@&JV\)"6m\ fˎ;eďĝKtc; 4C*%7i?B6xm<Irh{ke.et5͵k_/߰4ؼcc;CH-Uèr^qK·k`
fq({4%ʧdo397.n55`c´[nu7dW5̧\ۃ,o0a<LpL	kRӽa|񆗹.Ymbb,O?޼%mo)O~ҼyYb@2}V%5~,ӆ]'й1DSbH/#MU81_qq1AW/xw_gA8(IEB뜍VtN#9p~1d#6ʟ[/Aa}KT09y/|$<m	c\MA-F4߻28
4'ftQ Ҝj|r`pnۧbߊ8ﾼl89`q:0h\ᖡD37]|-Z9Lt9_ki8	$U$v0s/	dHr`?c:pPjHM\Y]F z74>?N	)w.)+w!_GàT4ɚm4k?p7ÍxˑCߟ1- q(#
8kB{[ݲn
r
>wnS>VUeL;vVpA2yG.BXn8k-$Q& 34Ӑcq$m8胑R6$譚G(x[k38R*iįkWCk~h&0A	tp:H{i-
{|I<sy6]' 54vF	ý7)d[;+VniS#(uwPr*ر# c'L0T=kʵ߀"^:o"]?_|hm?uLo~IS!pM#]k8iN} \PT_Vڼ~aٓv!?ʌjr`<%x%.[z{zk<GK!'a;y/Bk4$_avڿdvAI;=[[%f9'[4F+/Aj@^2Vr$HCP(2X;b9nc>yi1咖A=A&b8M}xG2y{dX)Mn2uX83Wq`"Ax[zֵ4<ǟ_.1(1s9WeŎ#n.|c^gҵ	Vka7TDEk~ale+us0D<(*ZY_`=ىTp+ o}le!R՛N۽ƓejA)D0oˈ*/˵df}`6CTMI'>vg?vDQւNdkS	¼<c`dt2M>v$s[Mdh
/J)؋9R/,M,E~4A*\v_.z]"WG5CQ5S;-ۛ
S= :>8J6I͕b7<_$"|ԩ"2c^?d>$`}3	J"ȃG#GH*ɽkY؀P:Z[PmGǴ$bakڵzkzilA~GUlTjr)D(1ns\bAjL`'EWn|~pA<ɏڞ ˈƝ2Yڨ᪏HKl6OV}12mqNy+nΗ)s2 F=짫ҵ|:$K*$vzM<=r@b ]?N,=v'Q"Ǹ)<!n9%u L"ksb^4Kr);(aCkF ud=;sCw|sq|mIأP[Y{^:]Z>B
M_,ibr-y:ֹ;i6$9&c`sK^q}:mt,;HYbhmiQVxLn,(|̊p?04}T-P?Q:7WG㠘2}1p2%B=~&5/jyHԤ^gLaldAz/tDӚɓJm0-.PWMXaVprP**C"
8dbD/H5Ӥi_dC߉-mn_j؃\TIFAqC1qV(>
*rq)O]ǜxѡC3
EquB|<gHJ1=qlf(ݪI,&jd2^_L	qt	d>B
~<ws9Zqb\9y}x#!D5
o+W\~V8UO|%W`M89iL5:1j>lވ.^t8X ot\Į%vL|q<<7y3)啁0	5Zm	[LOdH$Qeh*4&-tjEsozt[v~ѯH)7RxIzGg.PN7
`
o*;&t	$dRd|_8ә4KFOtkgc-R6)=Ъ~n;)w_qs KfGaΗLSȌJnnVtΨ:-dOGB֬DWJWjE	ɾeЇdWѐD=uebE4gkޜʳ}pk-"Sݝ3FcwDTx-%k{n7/'ETkBra lޢԀL*vT8R؝qp]^ϪՂWWe@͕qbb*84Q @iy͙vo0d2;f5Uڙsyy^DC̒_a`"QVuΆ8O gH$է'ߐrhWlZ#G=1%'HFskH:.Ik\ޣ]]l-YU26gZ(x*Xt>X΄>rߋZؕ=2#Rzx;E5vHe^y/E:7gإ)q^ޯHˬ-)ԋW%bOx߿/O@nˇߠڕ\98?yCbp^5.iY|	ur'̿ߒ"TlV&>~0mZ-JXé#挧[N9ðYڞUJn|B^vZ{ܸƑg`IHvf$0uԝ3[k3Nmbz@g`HZGڳp>SWo©d03C?,o7LEyAO lS+ԗG;)ͥ	UnLw"9A/n=/<jP2eתY'j=UlP|2b[
p|l/pΔKi$E#·F)1rV־t>7c]>hĕn.lG*cyHIW9Y+($
$d_ g 0i<voQf`J͙ C21ZUO]ߣb9zyj)& |3S]̀\1 ;)E@)7d+E= Agp`We8.)DMo{^"::rϳiba{d-u@]AEHڣ&s9M#]?S W>;2ұTJ&?y%y@EM<We
mEj!#op'h;EnrCaTQ(zٿRz/t-" JLIcK~haQiHmnp%IHQ~@z۽,Fxs<]1	;K2Nhon6EH.')XYgvj㳿3h!)l,OQvN:Jx9e3~Rq_ncLčm}"?DIAJ[,[NgjAW~@a6J#Mv!htt GL!n;O["[#ŒXt/"ΔC{:{*{>@"7WejWI"qJ޵90c!:٢dFn7ɔFLWճo8_N[g` t2IQwG.?o~ㅿ+Q/)$9-?k;+(um1wEvc!߼bCU,(mR3-98JScC(kJZ|8(b˩G'[F2#E`t\4\xzܕC̻'Tؕ	zXQ%(ûQs5i  p$T?}5	9?煩w.n#{Q/ p*Hu2ZㆦLlf,dԽ%~6xg~~cqO.Lhc@3&#O_{߉ߺߥ{Tgo9V:yp]7@_TTrE#/baL?PFXcYpkȍjU~GD>Jb֡OT@EM;%*<'eMGx-i>sZJ'v΃T=˟U&_G٭E2%፾HK3a:Κy5A `>:RdJ.I˸Vɻ`ÈoKD
|գLHў}ۏ jCk-*"ʔm8yP!C>1U| (e)nVbWhL~EZ_x[1:bmmGt/۵.$֜ܓkԱ#s u|nyq|˜}St8>$2W'
>&]95Z^2%mbuW&MP9PWD7Z࿳7V0sRd*"zXus.^zd%-)8I4**4DDsnY~F&`:8X)ȚZS%Oe	FƜj&M_{8nzpXPv8A
U^vj/7|8c).Vy,loDwnTRG9AhEߠ#It[ؗT#A:7oI>.L$6(hʵ57Bw}J<;1#HEl3[!ɇp1Va6K+R(OLy%P,DzJ7Y"إfzd>'n;w9B&'fyHQ1Q^:O]մ\å+"kQVbW𞣖NRBTkIwW<d~q2΅7H2(EydvPT:CQ` MKTW	#L c/[䩟[=2 YL0/$:^j4&Ei]6US(c3ڿE?J>OEjĄ"$]cxϢExOv٪#YTΘK]C\P+rq.]o2DD ڠ.N@#MuvY!t&C	Nٵ*I#\-YԨ0K[#AڵbKK7F]ǖ(R0L&{S/o\H񓚒Ovw99;
R	n n8^r\Fjje|8n28ܣĶȰr3f%/7";]\o61N#PV4eIt4;`S% oc9|/t"<{7q[`Xq grD z,U&6u$z]:gZ&٤h40wpI3 Fc BÎ5ŜxE
ffgku>ПY}~Щ`V?n\WNF"6^ /tS IT4N8p#?>_Zcer؎kk-6_lK>إoIkgp:S]JcE/+6sao(qGtܢM[!SgvXJ!ᖏ0C+ꬪ9DV
8 -[\؛c
-Z{?C{LBs'EqCK*\x^~GpLaJ;RqsiFힳFȯtI1L+3Xm'3|}|KLHs{O5ʑ{>iXD3}'Yb׺ݺa'*<ݠ).^}7WIN
HNٿ%)LMg1b߾؊&;aaIoy1u8tYzyRu
%#agF%hsO|
I瑯.*ϭ4yꎫN>>KN
t4h-4l}QTS	(_}yG7QƱ28X%.d_%qgVhb~Рy2nD<^t͎f`o$ʹri
l0rZUNγ9ȷSj±_lҗ̧ltzXnuqWڱGōDl [Z6r%2-}6"1p𿹟gt_\>*wlw@u[L>oyzb+T"q ._bS!,-ބ%_Fm*(ÔJҺ|`m	I 71l`w@+XKMNMFΓVJb=rR;5͞]_%"@ߡT5gЛՈψjzP߀W\KEfA($jՁ: 4,J]=iuos
Ћ[]TXwVHK4Bk/v7 ,k`ZWl\Df/Ӆ|HQVfz
+ 9}g#'OW"ɼpzi&8_]WR@t0nhO4~!0yz?Bdtz cr_]=	裍vnS§Z L]EɎ3Fw(8AE8Iapp|jwTj2/QTVUvq]'v~MSE(ܼ	]!  M]a"kh,w1c gv/89<gKx.fAUk'@(FE=wxbK`Hx'9ۿ6LIf2Ao7gN\m N*RKjxQ}\ l)˓UZwC{P웷#qZӕC^g)SL1"2ˤܘ#RDX7(X.Ҳ0
{Lf#Ag2MI5۵vt^˞ksQ]X9傊#g>V$L *J&FmZAmnن2}6ʇ#pЙB92}ו씭~Jhn}4}my*m}xm\/1@y5i7tG	s/!6o	 cHy0-1gJ8wò9fA}2BmqTwt%3&vKsu]xX^(I447{E ְ9qLVX^hJ.6BoTEL8Uu@p4M7ײZYzlFN9=UCp3$@xpʔTYz[5641biY9K/!QP.7(qnlD>+t}k;Yy9#$X|--]\`&ʧQr<7j<BTMvzJ\f<d\ bElmwr
gOyU/H\
J	#)ŀab=9ёGi%B6^YuIw--7[RPɎOmڭ,ПѝQyosftR1|ԙMCg8Y7klFQ,0-t_AOtxuiIUXwpy2ӻdToCa)J{\<oV
6u×mY5<̴s2v[bd9"yt=5̡Ԍ=|vpvʷؗwP(<tڛE(S(:Z$k`qmst`Cy:$>%|ǿ)&ٻ:U [H~`H;
l]	"_K2#	Ao<lG#}>eUoU0KES;1PzBE8ېϬ^O'SMinQCxIDٳv"S&3
4,r%"Y_kpǕ+Xsi_[Z8i=]sYyk4^Z`Ǎ`KYٌ,'v3:m|Rn

aI
6jQ(#)T\	{}ҐѰ?~kLIi@iaq?MVN-"\ړ<BYlC pN7MXlOME.-Ft%6m΀wX:.kįJNoh08$z^ Q]wbr~J=mF0L@*S- k-Z.ԭqe^x,^Bepx0Wa$X`f<@6W§Bq$	-ѳ&"5WEs j~Ą_;5dI9Y
P8]"R$*o'mH`/?XS~pKҴt.?&mvx.<yᮓVݍBm"e21@v4Hbwt[LöUO89.fcKSeፏwuavMqԍ<
@<#By!1<A2BD\$NQ䆩<B2 r.$BEićFn$/ڣzA+&šCkz;sm#Q-w	F\&~}$-}
AR7O+hUW֚>{5[hvHOYx9Sƨ)ŜqhO5 mz2 §Pߣ筸'!$m|gIUKZJQۆ4@MN: G]w\Ȩ%):gmLCauLK<)0io{|oj-3i-Ku&l+%r\˔=#E!o8{Ɛ]w9~֯4=ӓlJ 8x1Le)#> SVHo p+cLt_!vv
+*l]M8.A[223[r3Ì/|<llaP߂ߢQXZ$4쫩轏kVp-?gMAx?=F>bъ#='o^vg*Yʀ'ĀO!\l6B$0JX	;~~ǭ^Ssa(.qB,Q5OD;T6Z;O""[0Sስ]Y15(E7I 'ɝ>}.R\Yn[dF602+t#I;[`pqf!k<(ϯ%/~:D63	ʨ6oqd7|_m~IkLrѳgB3oA^ $?R0fZ.x`mfl@.Y=\-v6ge
N}RZ7j w>\5ŽRhKXeH|4;"BIEFGdwkHtVSNݍ;6<3czCJ$ufL:|Z#W^y;VDf<7lxl$(мOsavb^1grIlޤ#Օ0D*~6;UZZyM?4.Ha"g/O@MhD-	kdme]L7j'5s}_  Pn7dw>%+@HpQ5C]vo+<C<FBB	?c9%a7"X#t$b*VxUscYH=YS84$H;h.LW5F/aT˾5-\OtDk.&ұw<ЅĉleYي@.Ӆ4b+K/ډT5e3GM@bk}At.P>Ͽ+1?!lPzw8Vtaj߾hߢ47oc:Ziٷp	Zũ"|Y}t1A@!R՘1 CV}Xҙ!fE@^,K$Bɬ{w^Etbr'sG5(]2[4\F
ֻ`^߄ʽh%(͎vOVfl ?4*2:5M9x!L(	H7lu3WrJX'XKo	œ	9JLTL[>scӡqUC$$MwndWuǰsq.cŔ涥?D{Ay_>BΈ{~2Z1s-yqL]W\ch
*CԢW%,q#6o{UXXV_tSٵ`1s-*^
óykg76ݓă]9X̮Y$.*_[-EY3"kʰ:4ujSҒ 4=̬MNx'E2,.yY~eu>=L?*,\E&КD NR0'^{*\\ ti-ErW6ZV"a|q:7dCKeu%%
ț1\e#<Sv/5yBKo-,)N?0JzBi!M<T fܙ@J=Dun]'⽉bm#n,iaB*0Q`ݛfv@]pIC:I=RS8L/j <6gTz}tG+%RfbĥCpUg&rٻ6DOw"AheXN%R1u$6tBܫ̷fMBAس7)|RڮH E:A1a}WֈV/?##MeV;
^*T&dYWFd	7o
#sJ{!mtEinc!dj:dYzA42s=ds+vZjhO#EŜF}WW`{// SPDX-License-Identifier: GPL-2.0-or-later
/*
 *  Driver for the Conexant CX23885 PCIe bridge
 *
 *  Copyright (c) 2006 Steven Toth <stoth@linuxtv.org>
 */

#include "cx23885.h"

#include <linux/init.h>
#include <linux/module.h>
#include <linux/pci.h>
#include <linux/delay.h>
#include <media/drv-intf/cx25840.h>
#include <linux/firmware.h>
#include <misc/altera.h>

#include "xc2028.h"
#include "netup-eeprom.h"
#include "netup-init.h"
#include "altera-ci.h"
#include "xc4000.h"
#include "xc5000.h"
#include "cx23888-ir.h"

static unsigned int netup_card_rev = 4;
module_param(netup_card_rev, int, 0644);
MODULE_PARM_DESC(netup_card_rev,
		"NetUP Dual DVB-T/C CI card revision");
static unsigned int enable_885_ir;
module_param(enable_885_ir, int, 0644);
MODULE_PARM_DESC(enable_885_ir,
		 "Enable integrated IR controller for supported\n"
		 "\t\t    CX2388[57] boards that are wired for it:\n"
		 "\t\t\tHVR-1250 (reported safe)\n"
		 "\t\t\tTerraTec Cinergy T PCIe Dual (not well tested, appears to be safe)\n"
		 "\t\t\tTeVii S470 (reported unsafe)\n"
		 "\t\t    This can cause an interrupt storm with some cards.\n"
		 "\t\t    Default: 0 [Disabled]");

/* ------------------------------------------------------------------ */
/* board config info                                                  */

struct cx23885_board cx23885_boards[] = {
	[CX23885_BOARD_UNKNOWN] = {
		.name		= "UNKNOWN/GENERIC",
		/* Ensure safe default for unknown boards */
		.clk_freq       = 0,
		.input          = {{
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   = 0,
		}, {
			.type   = CX23885_VMUX_COMPOSITE2,
			.vmux   = 1,
		}, {
			.type   = CX23885_VMUX_COMPOSITE3,
			.vmux   = 2,
		}, {
			.type   = CX23885_VMUX_COMPOSITE4,
			.vmux   = 3,
		} },
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1800lp] = {
		.name		= "Hauppauge WinTV-HVR1800lp",
		.portc		= CX23885_MPEG_DVB,
		.input          = {{
			.type   = CX23885_VMUX_TELEVISION,
			.vmux   = 0,
			.gpio0  = 0xff00,
		}, {
			.type   = CX23885_VMUX_DEBUG,
			.vmux   = 0,
			.gpio0  = 0xff01,
		}, {
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   = 1,
			.gpio0  = 0xff02,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   = 2,
			.gpio0  = 0xff02,
		} },
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1800] = {
		.name		= "Hauppauge WinTV-HVR1800",
		.porta		= CX23885_ANALOG_VIDEO,
		.portb		= CX23885_MPEG_ENCODER,
		.portc		= CX23885_MPEG_DVB,
		.tuner_type	= TUNER_PHILIPS_TDA8290,
		.tuner_addr	= 0x42, /* 0x84 >> 1 */
		.tuner_bus	= 1,
		.input          = {{
			.type   = CX23885_VMUX_TELEVISION,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN5_CH2 |
					CX25840_VIN2_CH1,
			.amux   = CX25840_AUDIO8,
			.gpio0  = 0,
		}, {
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN6_CH1,
			.amux   = CX25840_AUDIO7,
			.gpio0  = 0,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN8_CH1 |
					CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
			.gpio0  = 0,
		} },
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1250] = {
		.name		= "Hauppauge WinTV-HVR1250",
		.porta		= CX23885_ANALOG_VIDEO,
		.portc		= CX23885_MPEG_DVB,
#ifdef MT2131_NO_ANALOG_SUPPORT_YET
		.tuner_type	= TUNER_PHILIPS_TDA8290,
		.tuner_addr	= 0x42, /* 0x84 >> 1 */
		.tuner_bus	= 1,
#endif
		.force_bff	= 1,
		.input          = {{
#ifdef MT2131_NO_ANALOG_SUPPORT_YET
			.type   = CX23885_VMUX_TELEVISION,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN5_CH2 |
					CX25840_VIN2_CH1,
			.amux   = CX25840_AUDIO8,
			.gpio0  = 0xff00,
		}, {
#endif
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN6_CH1,
			.amux   = CX25840_AUDIO7,
			.gpio0  = 0xff02,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN8_CH1 |
					CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
			.gpio0  = 0xff02,
		} },
	},
	[CX23885_BOARD_DVICO_FUSIONHDTV_5_EXP] = {
		.name		= "DViCO FusionHDTV5 Express",
		.portb		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1500Q] = {
		.name		= "Hauppauge WinTV-HVR1500Q",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1500] = {
		.name		= "Hauppauge WinTV-HVR1500",
		.porta		= CX23885_ANALOG_VIDEO,
		.portc		= CX23885_MPEG_DVB,
		.tuner_type	= TUNER_XC2028,
		.tuner_addr	= 0x61, /* 0xc2 >> 1 */
		.input          = {{
			.type   = CX23885_VMUX_TELEVISION,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN5_CH2 |
					CX25840_VIN2_CH1,
			.gpio0  = 0,
		}, {
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN6_CH1,
			.gpio0  = 0,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN8_CH1 |
					CX25840_SVIDEO_ON,
			.gpio0  = 0,
		} },
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1200] = {
		.name		= "Hauppauge WinTV-HVR1200",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1700] = {
		.name		= "Hauppauge WinTV-HVR1700",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1400] = {
		.name		= "Hauppauge WinTV-HVR1400",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_DVICO_FUSIONHDTV_7_DUAL_EXP] = {
		.name		= "DViCO FusionHDTV7 Dual Express",
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP] = {
		.name		= "DViCO FusionHDTV DVB-T Dual Express",
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H] = {
		.name		= "Leadtek Winfast PxDVR3200 H",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_LEADTEK_WINFAST_PXPVR2200] = {
		.name		= "Leadtek Winfast PxPVR2200",
		.porta		= CX23885_ANALOG_VIDEO,
		.tuner_type	= TUNER_XC2028,
		.tuner_addr	= 0x61,
		.tuner_bus	= 1,
		.input		= {{
			.type	= CX23885_VMUX_TELEVISION,
			.vmux	= CX25840_VIN2_CH1 |
				  CX25840_VIN5_CH2,
			.amux	= CX25840_AUDIO8,
			.gpio0	= 0x704040,
		}, {
			.type	= CX23885_VMUX_COMPOSITE1,
			.vmux	= CX25840_COMPOSITE1,
			.amux	= CX25840_AUDIO7,
			.gpio0	= 0x704040,
		}, {
			.type	= CX23885_VMUX_SVIDEO,
			.vmux	= CX25840_SVIDEO_LUMA3 |
				  CX25840_SVIDEO_CHROMA4,
			.amux	= CX25840_AUDIO7,
			.gpio0	= 0x704040,
		}, {
			.type	= CX23885_VMUX_COMPONENT,
			.vmux	= CX25840_VIN7_CH1 |
				  CX25840_VIN6_CH2 |
				  CX25840_VIN8_CH3 |
				  CX25840_COMPONENT_ON,
			.amux	= CX25840_AUDIO7,
			.gpio0	= 0x704040,
		} },
	},
	[CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H_XC4000] = {
		.name		= "Leadtek Winfast PxDVR3200 H XC4000",
		.porta		= CX23885_ANALOG_VIDEO,
		.portc		= CX23885_MPEG_DVB,
		.tuner_type	= TUNER_XC4000,
		.tuner_addr	= 0x61,
		.radio_type	= UNSET,
		.radio_addr	= ADDR_UNSET,
		.input		= {{
			.type	= CX23885_VMUX_TELEVISION,
			.vmux	= CX25840_VIN2_CH1 |
				  CX25840_VIN5_CH2 |
				  CX25840_NONE0_CH3,
		}, {
			.type	= CX23885_VMUX_COMPOSITE1,
			.vmux	= CX25840_COMPOSITE1,
		}, {
			.type	= CX23885_VMUX_SVIDEO,
			.vmux	= CX25840_SVIDEO_LUMA3 |
				  CX25840_SVIDEO_CHROMA4,
		}, {
			.type	= CX23885_VMUX_COMPONENT,
			.vmux	= CX25840_VIN7_CH1 |
				  CX25840_VIN6_CH2 |
				  CX25840_VIN8_CH3 |
				  CX25840_COMPONENT_ON,
		} },
	},
	[CX23885_BOARD_COMPRO_VIDEOMATE_E650F] = {
		.name		= "Compro VideoMate E650F",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_TBS_6920] = {
		.name		= "TurboSight TBS 6920",
		.portb		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_TBS_6980] = {
		.name		= "TurboSight TBS 6980",
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_TBS_6981] = {
		.name		= "TurboSight TBS 6981",
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_TEVII_S470] = {
		.name		= "TeVii S470",
		.portb		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_DVBWORLD_2005] = {
		.name		= "DVBWorld DVB-S2 2005",
		.portb		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_NETUP_DUAL_DVBS2_CI] = {
		.ci_type	= 1,
		.name		= "NetUP Dual DVB-S2 CI",
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1270] = {
		.name		= "Hauppauge WinTV-HVR1270",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1275] = {
		.name		= "Hauppauge WinTV-HVR1275",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1255] = {
		.name		= "Hauppauge WinTV-HVR1255",
		.porta		= CX23885_ANALOG_VIDEO,
		.portc		= CX23885_MPEG_DVB,
		.tuner_type	= TUNER_ABSENT,
		.tuner_addr	= 0x42, /* 0x84 >> 1 */
		.force_bff	= 1,
		.input          = {{
			.type   = CX23885_VMUX_TELEVISION,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN5_CH2 |
					CX25840_VIN2_CH1 |
					CX25840_DIF_ON,
			.amux   = CX25840_AUDIO8,
		}, {
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN6_CH1,
			.amux   = CX25840_AUDIO7,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN8_CH1 |
					CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
		} },
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1255_22111] = {
		.name		= "Hauppauge WinTV-HVR1255",
		.porta		= CX23885_ANALOG_VIDEO,
		.portc		= CX23885_MPEG_DVB,
		.tuner_type	= TUNER_ABSENT,
		.tuner_addr	= 0x42, /* 0x84 >> 1 */
		.force_bff	= 1,
		.input          = {{
			.type   = CX23885_VMUX_TELEVISION,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN5_CH2 |
					CX25840_VIN2_CH1 |
					CX25840_DIF_ON,
			.amux   = CX25840_AUDIO8,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN8_CH1 |
					CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
		} },
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1210] = {
		.name		= "Hauppauge WinTV-HVR1210",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_MYGICA_X8506] = {
		.name		= "Mygica X8506 DMB-TH",
		.tuner_type = TUNER_XC5000,
		.tuner_addr = 0x61,
		.tuner_bus	= 1,
		.porta		= CX23885_ANALOG_VIDEO,
		.portb		= CX23885_MPEG_DVB,
		.input		= {
			{
				.type   = CX23885_VMUX_TELEVISION,
				.vmux   = CX25840_COMPOSITE2,
			},
			{
				.type   = CX23885_VMUX_COMPOSITE1,
				.vmux   = CX25840_COMPOSITE8,
			},
			{
				.type   = CX23885_VMUX_SVIDEO,
				.vmux   = CX25840_SVIDEO_LUMA3 |
						CX25840_SVIDEO_CHROMA4,
			},
			{
				.type   = CX23885_VMUX_COMPONENT,
				.vmux   = CX25840_COMPONENT_ON |
					CX25840_VIN1_CH1 |
					CX25840_VIN6_CH2 |
					CX25840_VIN7_CH3,
			},
		},
	},
	[CX23885_BOARD_MAGICPRO_PROHDTVE2] = {
		.name		= "Magic-Pro ProHDTV Extreme 2",
		.tuner_type = TUNER_XC5000,
		.tuner_addr = 0x61,
		.tuner_bus	= 1,
		.porta		= CX23885_ANALOG_VIDEO,
		.portb		= CX23885_MPEG_DVB,
		.input		= {
			{
				.type   = CX23885_VMUX_TELEVISION,
				.vmux   = CX25840_COMPOSITE2,
			},
			{
				.type   = CX23885_VMUX_COMPOSITE1,
				.vmux   = CX25840_COMPOSITE8,
			},
			{
				.type   = CX23885_VMUX_SVIDEO,
				.vmux   = CX25840_SVIDEO_LUMA3 |
						CX25840_SVIDEO_CHROMA4,
			},
			{
				.type   = CX23885_VMUX_COMPONENT,
				.vmux   = CX25840_COMPONENT_ON |
					CX25840_VIN1_CH1 |
					CX25840_VIN6_CH2 |
					CX25840_VIN7_CH3,
			},
		},
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1850] = {
		.name		= "Hauppauge WinTV-HVR1850",
		.porta		= CX23885_ANALOG_VIDEO,
		.portb		= CX23885_MPEG_ENCODER,
		.portc		= CX23885_MPEG_DVB,
		.tuner_type	= TUNER_ABSENT,
		.tuner_addr	= 0x42, /* 0x84 >> 1 */
		.force_bff	= 1,
		.input          = {{
			.type   = CX23885_VMUX_TELEVISION,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN5_CH2 |
					CX25840_VIN2_CH1 |
					CX25840_DIF_ON,
			.amux   = CX25840_AUDIO8,
		}, {
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN6_CH1,
			.amux   = CX25840_AUDIO7,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN4_CH2 |
					CX25840_VIN8_CH1 |
					CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
		} },
	},
	[CX23885_BOARD_COMPRO_VIDEOMATE_E800] = {
		.name		= "Compro VideoMate E800",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1290] = {
		.name		= "Hauppauge WinTV-HVR1290",
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_MYGICA_X8558PRO] = {
		.name		= "Mygica X8558 PRO DMB-TH",
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_LEADTEK_WINFAST_PXTV1200] = {
		.name           = "LEADly
bcP;
9Է˟ʷ4'7k]E&ϖa2He?%ƁUVd>!meY[
bRC;n@	DrOsX{)FOlOԲ\v4rP܉ۘeONĀHm=pDK&}'X˕%cՈB6=pWy&dPa@֛^ٍc~yMwoҌ >n՚MOv4rŝ[~-BK!S7(硦$Yާnzakg=^+{&?.!;@|~1#Yniه_l_8 f5Ŕ`
uQn~Hw&fMAс;gk4yB
*DpAr0a<ܓk5ͤXf+[Ҧg@L-ݤb%ifY;㫙Da7NwMo:cc d\Ϣ/nkR2C++<$
ߨ4߅y*cr?/:$TBW's #rtKv)k0,B)&
R)ITm5	>'bkrxib6Me=U.	0A&qlWK]5o%>31vy

F^qZvԕ (jkj2C<8%1U:2A҅А0 66~jz.m"5zfg$=PI]Ě)t+21T~^Kƒ3]&.ֲuݾ@_eNˮdW Do^:6"Hߣa!I,}:>eQw81xgAӓQf-jIuxk6cbQq{P͍p|$Jx!]@vC\F;TLQ[ga"a^cRTwKї{GH'lԞEpTS)(l*(Pnd@LXN J{Փ9Rf8W[oX,SY,J2"n>M:eA<#>R|``蔌"hH{3K54XܳsVm:eC4L=A<~_p}WmRc45:nLv!BRDÝ,bJ$`BfR3k*2옦oZ6	v"4)LtYǏ6*~y$,0ɭN,خPbb>KE/AVOf t06 lpXSO6@afKXpe8%)/b[d`c=Qvϻ#}6dtOֵ+	ssNߧ0.3cl"Gf`
$ѿ:g)!dşoh3nAl!k_V?aTd_(1jaG,fٲC-izʺ޹Yys,!n쮜"#qW1vlK7,ꍙezr:eߌq9Q-+٤uf`.D r$Bִz%i۸p\͂Z|a'\Dt'~*>6&ɠ[C&-s*V}+Y{<{Wu欽FTڤӂbX؋p"+ư8#=ze>cN.qaey007r[$1'hpv@Lr@wNc$ 19hYf`_sC:所}Fe&4L݀gEN:;AS&L'z$7ISְnxUkvR'R+N}0C)o,Cq'r|69CɠӰ۟t#0LFQ/Κtizc_/ao5i^ӵpإZ`'"YtX8:$RcEi:-[ـrn0g<@l+!|%h#}:K=]52+jF+(vsU:ԷV_Z9PvaBk)h6p T/J)J<KBmzcU$hid)",X|I֢KL,&ֹ.#yx*sșDh2Yf6B
[e-q%{^+usA_-=\d}; <89%HQЁZ:pZ04z`E!~)>jMőtH
2I6;某ӺZCrh(y	%)?1QLt}` /*XK2{L00[sf醎trw0^\<N,
B։Υ->?PSrTmkFE"G吰ov0iNy0O1ڧkY̗U=J=E I,ۇ#N[Z8^}+"/g$ ~>_nw-<C]Q 8iw4tH=r]akW|>7_T,r_JPG2Cޫd=p	I8~K&QLۊݝqsI)̩6[e.6gK%iz AOvTL 2U5eZ:(|Bj(U>76־1E,:_݉mLr!bs@+ hy&_V>0;.·'B`}NQ@0$P)9)NJ<=]|v2x٘h~toV`ى|Ul̜͓\oe+Ž ?D
j)}v 1*FkĠR`ƉET$e0&xmZfP6a'f0&HXFS4'خUDHfo(A_NpksCɱL0_9[6t}*r1vdM/-88#oiV2kSXs;z+R$La4$F+݌(!%TPÌe`kTEqM$_l}%%y:[!\QL[c.c ko?{k?ՇF;+m/Fmbo=)U`9M]Bl }e<bu
iI	g{}JAֺ)=u4ؔMwJ`bZ? (g1(ES\o,6$bX1_u	2X|cB.02ԡV}SʧYZnC^8Y`?	^HF-k=.^vgE/,A@,KOwoow}p1$ZeW'ɑ>Z[ED[$-pEMvVO'9^p{`do%\ܰ;ѲɂC@⌄$笟ZcINTrv]"xuX&P6m$$ )?_l4)w9ZsI	C<O/uP `Rnp\yeU~/ւ,ҊkҁtP#ʾbrI.
Wp~|ih1ڐAt6*KL"/$q+E_#׈)])	jfbK>'R:!j S5suJB2amux   = CX25840_AUDIO8,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   = CX25840_VIN8_CH1 |
				  CX25840_NONE_CH2 |
				  CX25840_VIN7_CH3 |
				  CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO6,
		}, {
			.type   = CX23885_VMUX_COMPONENT,
			.vmux   = CX25840_VIN1_CH1 |
				  CX25840_NONE_CH2 |
				  CX25840_NONE0_CH3 |
				  CX25840_NONE1_CH3,
			.amux   = CX25840_AUDIO6,
		} },
	},
	[CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP2] = {
		.name		= "DViCO FusionHDTV DVB-T Dual Express2",
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_HAUPPAUGE_IMPACTVCBE] = {
		.name		= "Hauppauge ImpactVCB-e",
		.tuner_type	= TUNER_ABSENT,
		.porta		= CX23885_ANALOG_VIDEO,
		.input          = {{
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   = CX25840_VIN6_CH1,
			.amux   = CX25840_AUDIO7,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   = CX25840_VIN4_CH2 |
				  CX25840_VIN8_CH1 |
				  CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
		} },
	},
	[CX23885_BOARD_DVBSKY_T9580] = {
		.name		= "DVBSky T9580",
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_DVBSKY_T980C] = {
		.name		= "DVBSky T980C",
		.portb		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_DVBSKY_S950C] = {
		.name		= "DVBSky S950C",
		.portb		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_TT_CT2_4500_CI] = {
		.name		= "Technotrend TT-budget CT2-4500 CI",
		.portb		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_DVBSKY_S950] = {
		.name		= "DVBSky S950",
		.portb		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_DVBSKY_S952] = {
		.name		= "DVBSky S952",
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_DVBSKY_T982] = {
		.name		= "DVBSky T982",
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_HAUPPAUGE_HVR5525] = {
		.name		= "Hauppauge WinTV-HVR5525",
		.porta		= CX23885_ANALOG_VIDEO,
		.portb		= CX23885_MPEG_DVB,
		.portc		= CX23885_MPEG_DVB,
		.tuner_type	= TUNER_ABSENT,
		.force_bff	= 1,
		.input		= {{
			.type	= CX23885_VMUX_TELEVISION,
			.vmux	=	CX25840_VIN7_CH3 |
					CX25840_VIN5_CH2 |
					CX25840_VIN2_CH1 |
					CX25840_DIF_ON,
			.amux   = CX25840_AUDIO8,
		}, {
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   = CX25840_VIN6_CH1,
			.amux   = CX25840_AUDIO7,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   = CX25840_VIN7_CH3 |
				  CX25840_VIN8_CH1 |
				  CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
		} },
	},
	[CX23885_BOARD_VIEWCAST_260E] = {
		.name		= "ViewCast 260e",
		.porta		= CX23885_ANALOG_VIDEO,
		.force_bff	= 1,
		.input          = {{
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   = CX25840_VIN6_CH1,
			.amux   = CX25840_AUDIO7,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   = CX25840_VIN7_CH3 |
					CX25840_VIN5_CH1 |
					CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
		}, {
			.type   = CX23885_VMUX_COMPONENT,
			.vmux   = CX25840_VIN7_CH3 |
					CX25840_VIN6_CH2 |
					CX25840_VIN5_CH1 |
					CX25840_COMPONENT_ON,
			.amux   = CX25840_AUDIO7,
		} },
	},
	[CX23885_BOARD_VIEWCAST_460E] = {
		.name		= "ViewCast 460e",
		.porta		= CX23885_ANALOG_VIDEO,
		.force_bff	= 1,
		.input          = {{
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   = CX25840_VIN4_CH1,
			.amux   = CX25840_AUDIO7,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   = CX25840_VIN7_CH3 |
					CX25840_VIN6_CH1 |
					CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
		}, {
			.type   = CX23885_VMUX_COMPONENT,
			.vmux   = CX25840_VIN7_CH3 |
					CX25840_VIN6_CH1 |
					CX25840_VIN5_CH2 |
					CX25840_COMPONENT_ON,
			.amux   = CX25840_AUDIO7,
		}, {
			.type   = CX23885_VMUX_COMPOSITE2,
			.vmux   = CX25840_VIN6_CH1,
			.amux   = CX25840_AUDIO7,
		} },
	},
	[CX23885_BOARD_HAUPPAUGE_QUADHD_DVB] = {
		.name         = "Hauppauge WinTV-QuadHD-DVB",
		.porta        = CX23885_ANALOG_VIDEO,
		.portb        = CX23885_MPEG_DVB,
		.portc        = CX23885_MPEG_DVB,
		.tuner_type	= TUNER_ABSENT,
		.force_bff	= 1,
		.input          = {{
			.type   = CX23885_VMUX_TELEVISION,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN5_CH2 |
					CX25840_VIN2_CH1 |
					CX25840_DIF_ON,
			.amux   = CX25840_AUDIO8,
		} },
	},
	[CX23885_BOARD_HAUPPAUGE_QUADHD_DVB_885] = {
		.name         = "Hauppauge WinTV-QuadHD-DVB(885)",
		.portb        = CX23885_MPEG_DVB,
		.portc        = CX23885_MPEG_DVB,
		.tuner_type   = TUNER_ABSENT,
	},
	[CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC] = {
		.name         = "Hauppauge WinTV-QuadHD-ATSC",
		.porta        = CX23885_ANALOG_VIDEO,
		.portb        = CX23885_MPEG_DVB,
		.portc        = CX23885_MPEG_DVB,
		.tuner_type	= TUNER_ABSENT,
		.input          = {{
			.type   = CX23885_VMUX_TELEVISION,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN5_CH2 |
					CX25840_VIN2_CH1 |
					CX25840_DIF_ON,
			.amux   = CX25840_AUDIO8,
		} },
	},
	[CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC_885] = {
		.name         = "Hauppauge WinTV-QuadHD-ATSC(885)",
		.portb        = CX23885_MPEG_DVB,
		.portc        = CX23885_MPEG_DVB,
		.tuner_type   = TUNER_ABSENT,
	},
	[CX23885_BOARD_HAUPPAUGE_HVR1265_K4] = {
		.name		= "Hauppauge WinTV-HVR-1265(161111)",
		.porta          = CX23885_ANALOG_VIDEO,
		.portc		= CX23885_MPEG_DVB,
		.tuner_type     = TUNER_ABSENT,
		.input          = {{
			.type   = CX23885_VMUX_TELEVISION,
			.vmux   =	CX25840_VIN7_CH3 |
					CX25840_VIN5_CH2 |
					CX25840_VIN2_CH1 |
					CX25840_DIF_ON,
			.amux   = CX25840_AUDIO8,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   =	CX25840_VIN4_CH2 |
					CX25840_VIN6_CH1 |
					CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
		} },
	},
	[CX23885_BOARD_HAUPPAUGE_STARBURST2] = {
		.name		= "Hauppauge WinTV-Starburst2",
		.portb		= CX23885_MPEG_DVB,
	},
	[CX23885_BOARD_AVERMEDIA_CE310B] = {
		.name		= "AVerMedia CE310B",
		.porta		= CX23885_ANALOG_VIDEO,
		.force_bff	= 1,
		.input          = {{
			.type   = CX23885_VMUX_COMPOSITE1,
			.vmux   = CX25840_VIN1_CH1 |
				  CX25840_NONE_CH2 |
				  CX25840_NONE0_CH3,
			.amux   = CX25840_AUDIO7,
		}, {
			.type   = CX23885_VMUX_SVIDEO,
			.vmux   = CX25840_VIN8_CH1 |
				  CX25840_NONE_CH2 |
				  CX25840_VIN7_CH3 |
				  CX25840_SVIDEO_ON,
			.amux   = CX25840_AUDIO7,
		} },
	},
};
const unsigned int cx23885_bcount = ARRAY_SIZE(cx23885_boards);

/* ------------------------------------------------------------------ */
/* PCI subsystem IDs                                                  */

struct cx23885_subid cx23885_subids[] = {
	{
		.subvendor = 0x0070,
		.subdevice = 0x3400,
		.card      = CX23885_BOARD_UNKNOWN,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7600,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1800lp,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7800,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1800,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7801,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1800,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7809,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1800,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7911,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1250,
	}, {
		.subvendor = 0x18ac,
		.subdevice = 0xd500,
		.card      = CX23885_BOARD_DVICO_FUSIONHDTV_5_EXP,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7790,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1500Q,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7797,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1500Q,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7710,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1500,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7717,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1500,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x71d1,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1200,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x71d3,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1200,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x8101,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1700,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x8010,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1400,
	}, {
		.subvendor = 0x18ac,
		.subdevice = 0xd618,
		.card      = CX23885_BOARD_DVICO_FUSIONHDTV_7_DUAL_EXP,
	}, {
		.subvendor = 0x18ac,
		.subdevice = 0xdb78,
		.card      = CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP,
	}, {
		.subvendor = 0x107d,
		.subdevice = 0x6681,
		.card      = CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H,
	}, {
		.subvendor = 0x107d,
		.subdevice = 0x6f21,
		.card      = CX23885_BOARD_LEADTEK_WINFAST_PXPVR2200,
	}, {
		.subvendor = 0x107d,
		.subdevice = 0x6f39,
		.card	   = CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H_XC4000,
	}, {
		.subvendor = 0x185b,
		.subdevice = 0xe800,
		.card      = CX23885_BOARD_COMPRO_VIDEOMATE_E650F,
	}, {
		.subvendor = 0x6920,
		.subdevice = 0x8888,
		.card      = CX23885_BOARD_TBS_6920,
	}, {
		.subvendor = 0x6980,
		.subdevice = 0x8888,
		.card      = CX23885_BOARD_TBS_6980,
	}, {
		.subvendor = 0x6981,
		.subdevice = 0x8888,
		.card      = CX23885_BOARD_TBS_6981,
	}, {
		.subvendor = 0xd470,
		.subdevice = 0x9022,
		.card      = CX23885_BOARD_TEVII_S470,
	}, {
		.subvendor = 0x0001,
		.subdevice = 0x2005,
		.card      = CX23885_BOARD_DVBWORLD_2005,
	}, {
		.subvendor = 0x1b55,
		.subdevice = 0x2a2c,
		.card      = CX23885_BOARD_NETUP_DUAL_DVBS2_CI,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x2211,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1270,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x2215,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1275,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x221d,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1275,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x2251,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1255,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x2259,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1255_22111,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x2291,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1210,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x2295,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1210,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x2299,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1210,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x229d,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1210, /* HVR1215 */
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x22f0,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1210,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x22f1,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1255,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x22f2,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1275,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x22f3,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1210, /* HVR1215 */
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x22f4,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1210,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x22f5,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1210, /* HVR1215 */
	}, {
		.subvendor = 0x14f1,
		.subdevice = 0x8651,
		.card      = CX23885_BOARD_MYGICA_X8506,
	}, {
		.subvendor = 0x14f1,
		.subdevice = 0x8657,
		.card      = CX23885_BOARD_MAGICPRO_PROHDTVE2,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x8541,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1850,
	}, {
		.subvendor = 0x1858,
		.subdevice = 0xe800,
		.card      = CX23885_BOARD_COMPRO_VIDEOMATE_E800,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x8551,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1290,
	}, {
		.subvendor = 0x14f1,
		.subdevice = 0x8578,
		.card      = CX23885_BOARD_MYGICA_X8558PRO,
	}, {
		.subvendor = 0x107d,
		.subdevice = 0x6f22,
		.card      = CX23885_BOARD_LEADTEK_WINFAST_PXTV1200,
	}, {
		.subvendor = 0x5654,
		.subdevice = 0x2390,
		.card      = CX23885_BOARD_GOTVIEW_X5_3D_HYBRID,
	}, {
		.subvendor = 0x1b55,
		.subdevice = 0xe2e4,
		.card      = CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF,
	}, {
		.subvendor = 0x14f1,
		.subdevice = 0x8502,
		.card      = CX23885_BOARD_MYGICA_X8507,
	}, {
		.subvendor = 0x153b,
		.subdevice = 0x117e,
		.card      = CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL,
	}, {
		.subvendor = 0xd471,
		.subdevice = 0x9022,
		.card      = CX23885_BOARD_TEVII_S471,
	}, {
		.subvendor = 0x8000,
		.subdevice = 0x3034,
		.card      = CX23885_BOARD_PROF_8000,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0xc108,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR4400, /* Hauppauge WinTV HVR-4400 (Model 121xxx, Hybrid DVB-T/S2, IR) */
	}, {
		.subvendor = 0x0070,
		.subdevice = 0xc138,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR4400, /* Hauppauge WinTV HVR-5500 (Model 121xxx, Hybrid DVB-T/C/S2, IR) */
	}, {
		.subvendor = 0x0070,
		.subdevice = 0xc12a,
		.card      = CX23885_BOARD_HAUPPAUGE_STARBURST, /* Hauppauge WinTV Starburst (Model 121x00, DVB-S2, IR) */
	}, {
		.subvendor = 0x0070,
		.subdevice = 0xc1f8,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR4400, /* Hauppauge WinTV HVR-5500 (Model 121xxx, Hybrid DVB-T/C/S2, IR) */
	}, {
		.subvendor = 0x1461,
		.subdevice = 0xd939,
		.card      = CX23885_BOARD_AVERMEDIA_HC81R,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7133,
		.card      = CX23885_BOARD_HAUPPAUGE_IMPACTVCBE,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x7137,
		.card      = CX23885_BOARD_HAUPPAUGE_IMPACTVCBE,
	}, {
		.subvendor = 0x18ac,
		.subdevice = 0xdb98,
		.card      = CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP2,
	}, {
		.subvendor = 0x4254,
		.subdevice = 0x9580,
		.card      = CX23885_BOARD_DVBSKY_T9580,
	}, {
		.subvendor = 0x4254,
		.subdevice = 0x980c,
		.card      = CX23885_BOARD_DVBSKY_T980C,
	}, {
		.subvendor = 0x4254,
		.subdevice = 0x950c,
		.card      = CX23885_BOARD_DVBSKY_S950C,
	}, {
		.subvendor = 0x13c2,
		.subdevice = 0x3013,
		.card      = CX23885_BOARD_TT_CT2_4500_CI,
	}, {
		.subvendor = 0x4254,
		.subdevice = 0x0950,
		.card      = CX23885_BOARD_DVBSKY_S950,
	}, {
		.subvendor = 0x4254,
		.subdevice = 0x0952,
		.card      = CX23885_BOARD_DVBSKY_S952,
	}, {
		.subvendor = 0x4254,
		.subdevice = 0x0982,
		.card      = CX23885_BOARD_DVBSKY_T982,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0xf038,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR5525,
	}, {
		.subvendor = 0x1576,
		.subdevice = 0x0260,
		.card      = CX23885_BOARD_VIEWCAST_260E,
	}, {
		.subvendor = 0x1576,
		.subdevice = 0x0460,
		.card      = CX23885_BOARD_VIEWCAST_460E,
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x6a28,
		.card      = CX23885_BOARD_HAUPPAUGE_QUADHD_DVB, /* Tuner Pair 1 */
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x6b28,
		.card      = CX23885_BOARD_HAUPPAUGE_QUADHD_DVB, /* Tuner Pair 2 */
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x6a18,
		.card      = CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC, /* Tuner Pair 1 */
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x6b18,
		.card      = CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC, /* Tuner Pair 2 */
	}, {
		.subvendor = 0x0070,
		.subdevice = 0x2a18,
		.card      = CX23885_BOARD_HAUPPAUGE_HVR1265_K4, /* Hauppauge WinTV HVR-1265 (Model 161xx1, Hybrid ATSC/QAM-B) */
	}, {
		.subvendor = 0x0070,
		.subdevice = 0xf02a,
		.card      = CX23885_BOARD_HAUPPAUGE_STARBURST2,
	}, {
		.subvendor = 0x1461,
		.subdevice = 0x3100,
		.card      = CX23885_BOARD_AVERMEDIA_CE310B,
	},
};
const unsigned int cx23885_idcount = ARRAY_SIZE(cx23885_subids);

void cx23885_card_list(struct cx23885_dev *dev)
{
	int i;

	if (0 == dev->pci->subsystem_vendor &&
	    0 == dev->pci->subsystem_device) {
		pr_info("%s: Board has no valid PCIe Subsystem ID and can't\n"
			"%s: be autodetected. Pass card=<n> insmod option\n"
			"%s: to workaround that. Redirect complaints to the\n"
			"%s: vendor of the TV card.  Best regards,\n"
			"%s:         -- tux\n",
			dev->name, dev->name, dev->name, dev->name, dev->name);
	} else {
		pr_info("%s: Your board isn't known (yet) to the driver.\n"
			"%s: Try to pick one of the existing card configs via\n"
			"%s: card=<n> insmod option.  Updating to the latest\n"
			"%s: version might help as well.\n",
			dev->name, dev->name, dev->name, dev->name);
	}
	pr_info("%s: Here is a list of valid choices for the card=<n> insmod option:\n",
	       dev->name);
	for (i = 0; i < cx23885_bcount; i++)
		pr_info("%s:    card=%d -> %s\n",
			dev->name, i, cx23885_boards[i].name);
}

static void viewcast_eeprom(struct cx23885_dev *dev, u8 *eeprom_data)
{
	u32 sn;

	/* The serial number record begins with tag 0x59 */
	if (*(eeprom_data + 0x00) != 0x59) {
		pr_info("%s() eeprom records are undefined, no serial number\n",
			__func__);
		return;
	}

	sn =	(*(eeprom_data + 0x06) << 24) |
		(*(eeprom_data + 0x05) << 16) |
		(*(eeprom_data + 0x04) << 8) |
		(*(eeprom_data + 0x03));

	pr_info("%s: card '%s' sn# MM%d\n",
		dev->name,
		cx23885_boards[dev->board].name,
		sn);
}

static void hauppauge_eeprom(struct cx23885_dev *dev, u8 *eeprom_data)
{
	struct tveeprom tv;

	tveeprom_hauppauge_analog(&tv, eeprom_data);

	/* Make sure we support the board model */
	switch (tv.model) {
	case 22001:
		/* WinTV-HVR1270 (PCIe, Retail, half height)
		 * ATSC/QAM and basic analog, IR Blast */
	case 22009:
		/* WinTV-HVR1210 (PCIe, Retail, half height)
		 * DVB-T and basic analog, IR Blast */
	case 22011:
		/* WinTV-HVR1270 (PCIe, Retail, half height)
		 * ATSC/QAM and basic analog, IR Recv */
	case 22019:
		/* WinTV-HVR1210 (PCIe, Retail, half height)
		 * DVB-T and basic analog, IR Recv */
	case 22021:
		/* WinTV-HVR1275 (PCIe, Retail, half height)
		 * ATSC/QAM and basic analog, IR Recv */
	case 22029:
		/* WinTV-HVR1210 (PCIe, Retail, half height)
		 * DVB-T and basic analog, IR Recv */
	case 22101:
		/* WinTV-HVR1270 (PCIe, Retail, full height)
		 * ATSC/QAM and basic analog, IR Blast */
	case 22109:
		/* WinTV-HVR1210 (PCIe, Retail, full height)
		 * DVB-T and basic analog, IR Blast */
	case 22111:
		/* WinTV-HVR1270 (PCIe, Retail, full height)
		 * ATSC/QAM and basic analog, IR Recv */
	case 22119:
		/* WinTV-HVR1210 (PCIe, Retail, full height)
		 * DVB-T and basic analog, IR Recv */
	case 22121:
		/* WinTV-HVR1275 (PCIe, Retail, full height)
		 * ATSC/QAM and basic analog, IR Recv */
	case 22129:
		/* WinTV-HVR1210 (PCIe, Retail, full height)
		 * DVB-T and basic analog, IR Recv */
	case 71009:
		/* WinTV-HVR1200 (PCIe, Retail, full height)
		 * DVB-T and basic analog */
	case 71100:
		/* WinTV-ImpactVCB-e (PCIe, Retail, half height)
		 * Basic analog */
	case 71359:
		/* WinTV-HVR1200 (PCIe, OEM, half height)
		 * DVB-T and basic analog */
	case 71439:
		/* WinTV-HVR1200 (PCIe, OEM, half height)
		 * DVB-T and basic analog */
	case 71449:
		/* WinTV-HVR1200 (PCIe, OEM, full height)
		 * DVB-T and basic analog */
	case 71939:
		/* WinTV-HVR1200 (PCIe, OEM, half height)
		 * DVB-T and basic analog */
	case 71949:
		/* WinTV-HVR1200 (PCIe, OEM, full height)
		 * DVB-T and basic analog */
	case 71959:
		/* WinTV-HVR1200 (PCIe, OEM, full height)
		 * DVB-T and basic analog */
	case 71979:
		/* WinTV-HVR1200 (PCIe, OEM, half height)
		 * DVB-T and basic analog */
	case 71999:
		/* WinTV-HVR1200 (PCIe, OEM, full height)
		 * DVB-T and basic analog */
	case 76601:
		/* WinTV-HVR1800lp (PCIe, Retail, No IR, Dual
			channel ATSC and MPEG2 HW Encoder */
	case 77001:
		/* WinTV-HVR1500 (Express Card, OEM, No IR, ATSC
			and Basic analog */
	case 77011:
		/* WinTV-HVR1500 (Express Card, Retail, No IR, ATSC
			and Basic analog */
	case 77041:
		/* WinTV-HVR1500Q (Express Card, OEM, No IR, ATSC/QAM
			and Basic analog */
	case 77051:
		/* WinTV-HVR1500Q (Express Card, Retail, No IR, ATSC/QAM
			and Basic analog */
	case 78011:
		/* WinTV-HVR1800 (PCIe, Retail, 3.5mm in, IR, No FM,
			Dual channel ATSC and MPEG2 HW Encoder */
	case 78501:
		/* WinTV-HVR1800 (PCIe, OEM, RCA in, No IR, FM,
			Dual channel ATSC and MPEG2 HW Encoder */
	case 78521:
		/* WinTV-HVR1800 (PCIe, OEM, RCA in, No IR, FM,
			Dual channel ATSC and MPEG2 HW Encoder */
	case 78531:
		/* WinTV-HVR1800 (PCIe, OEM, RCA in, No IR, No FM,
			Dual channel ATSC and MPEG2 HW Encoder */
	case 78631:
		/* WinTV-HVR1800 (PCIe, OEM, No IR, No FM,
			Dual channel ATSC and MPEG2 HW Encoder */
	case 79001:
		/* WinTV-HVR1250 (PCIe, Retail, IR, full height,
			ATSC and Basic analog */
	case 79101:
		/* WinTV-HVR1250 (PCIe, Retail, IR, half height,
			ATSC and Basic analog */
	case 79501:
		/* WinTV-HVR1250 (PCIe, No IR, half height,
			ATSC [at least] and Basic analog) */
	case 79561:
		/* WinTV-HVR1250 (PCIe, OEM, No IR, half height,
			ATSC and Basic analog */
	case 79571:
		/* WinTV-HVR1250 (PCIe, OEM, No IR, full height,
		 ATSC and Basic analog */
	case 79671:
		/* WinTV-HVR1250 (PCIe, OEM, No IR, half height,
			ATSC and Basic analog */
	case 80019:
		/* WinTV-HVR1400 (Express Card, Retail, IR,
		 * DVB-T and Basic analog */
	case 81509:
		/* WinTV-HVR1700 (PCIe, OEM, No IR, half height)
		 * DVB-T and MPEG2 HW Encoder */
	case 81519:
		/* WinTV-HVR1700 (PCIe, OEM, No IR, full height)
		 * DVB-T and MPEG2 HW Encoder */
		break;
	case 85021:
		/* WinTV-HVR1850 (PCIe, Retail, 3.5mm in, IR, FM,
			Dual channel ATSC and MPEG2 HW Encoder */
		break;
	case 85721:
		/* WinTV-HVR1290 (PCIe, OEM, RCA in, IR,
			Dual channel ATSC and Basic analog */
	case 121019:
		/* WinTV-HVR4400 (PCIe, DVB-S2, DVB-C/T) */
		break;
	case 121029:
		/* WinTV-HVR5500 (PCIe, DVB-S2, DVB-C/T) */
		break;
	case 150329:
		/* WinTV-HVR5525 (PCIe, DVB-S/S2, DVB-T/T2/C) */
		break;
	case 161111:
		/* WinTV-HVR-1265 K4 (PCIe, Analog/ATSC/QAM-B) */
		break;
	case 166100: /* 888 version, hybrid */
	case 166200: /* 885 version, DVB only */
		/* WinTV-QuadHD (DVB) Tuner Pair 1 (PCIe, IR, half height,
		   DVB-T/T2/C, DVB-T/T2/C */
		break;
	case 166101: /* 888 version, hybrid */
	case 166201: /* 885 version, DVB only */
		/* WinTV-QuadHD (DVB) Tuner Pair 2 (PCIe, IR, half height,
		   DVB-T/T2/C, DVB-T/T2/C */
		break;
	case 165100: /* 888 version, hybrid */
	case 165200: /* 885 version, digital only */
		/* WinTV-QuadHD (ATSC) Tuner Pair 1 (PCIe, IR, half height,
		 * ATSC/QAM-B, ATSC/QAM-B */
		break;
	case 165101: /* 888 version, hybrid */
	case 165201: /* 885 version, digital only */
		/* WinTV-QuadHD (ATSC) Tuner Pair 2 (PCIe, IR, half height,
		 * ATSC/QAM-B, ATSC/QAM-B */
		break;
	default:
		pr_warn("%s: warning: unknown hauppauge model #%d\n",
			dev->name, tv.model);
		break;
	}

	pr_info("%s: hauppauge eeprom: model=%d\n",
		dev->name, tv.model);
}

/* Some TBS cards require initing a chip using a bitbanged SPI attached
   to the cx23885 gpio's. If this chip doesn't get init'ed the demod
   doesn't respond to any command. */
static void tbs_card_init(struct cx23885_dev *dev)
{
	int i;
	static const u8 buf[] = {
		0xe0, 0x06, 0x66, 0x33, 0x65,
		0x01, 0x17, 0x06, 0xde};

	switch (dev->board) {
	case CX23885_BOARD_TBS_6980:
	case CX23885_BOARD_TBS_6981:
		cx_set(GP0_IO, 0x00070007);
		usleep_range(1000, 10000);
		cx_clear(GP0_IO, 2);
		usleep_range(1000, 10000);
		for (i = 0; i < 9 * 8; i++) {
			cx_clear(GP0_IO, 7);
			usleep_range(1000, 10000);
			cx_set(GP0_IO,
				((buf[i >> 3] >> (7 - (i & 7))) & 1) | 4);
			usleep_range(1000, 10000);
		}
		cx_set(GP0_IO, 7);
		break;
	}
}

int cx23885_tuner_callback(void *priv, int component, int command, int arg)
{
	struct cx23885_tsport *port = priv;
	struct cx23885_dev *dev = port->dev;
	u32 bitmask = 0;

	if ((command == XC2028_RESET_CLK) || (command == XC2028_I2C_FLUSH))
		return 0;

	if (command != 0) {
		pr_err("%s(): Unknown command 0x%x.\n",
		       __func__, command);
		return -EINVAL;
	}

	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1400:
	case CX23885_BOARD_HAUPPAUGE_HVR1500:
	case CX23885_BOARD_HAUPPAUGE_HVR1500Q:
	case CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H:
	case CX23885_BOARD_LEADTEK_WINFAST_PXPVR2200:
	case CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H_XC4000:
	case CX23885_BOARD_COMPRO_VIDEOMATE_E650F:
	case CX23885_BOARD_COMPRO_VIDEOMATE_E800:
	case CX23885_BOARD_LEADTEK_WINFAST_PXTV1200:
		/* Tuner Reset Command */
		bitmask = 0x04;
		break;
	case CX23885_BOARD_DVICO_FUSIONHDTV_7_DUAL_EXP:
	case CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP:
	case CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP2:
		/* Two identical tuners on two different i2c buses,
		 * we need to reset the correct gpio. */
		if (port->nr == 1)
			bitmask = 0x01;
		else if (port->nr == 2)
			bitmask = 0x04;
		break;
	case CX23885_BOARD_GOTVIEW_X5_3D_HYBRID:
		/* Tuner Reset Command */
		bitmask = 0x02;
		break;
	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:
		altera_ci_tuner_reset(dev, port->nr);
		break;
	case CX23885_BOARD_AVERMEDIA_HC81R:
		/* XC3028L Reset Command */
		bitmask = 1 << 2;
		break;
	}

	if (bitmask) {
		/* Drive the tuner into reset and back out */
		cx_clear(GP0_IO, bitmask);
		mdelay(200);
		cx_set(GP0_IO, bitmask);
	}

	return 0;
}

void cx23885_gpio_setup(struct cx23885_dev *dev)
{
	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
		/* GPIO-0 cx24227 demodulator reset */
		cx_set(GP0_IO, 0x00010001); /* Bring the part out of reset */
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1500:
		/* GPIO-0 cx24227 demodulator */
		/* GPIO-2 xc3028 tuner */

		/* Put the parts into reset */
		cx_set(GP0_IO, 0x00050000);
		cx_clear(GP0_IO, 0x00000005);
		msleep(5);

		/* Bring the parts out of reset */
		cx_set(GP0_IO, 0x00050005);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1500Q:
		/* GPIO-0 cx24227 demodulator reset */
		/* GPIO-2 xc5000 tuner reset */
		cx_set(GP0_IO, 0x00050005); /* Bring the part out of reset */
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1800:
		/* GPIO-0 656_CLK */
		/* GPIO-1 656_D0 */
		/* GPIO-2 8295A Reset */
		/* GPIO-3-10 cx23417 data0-7 */
		/* GPIO-11-14 cx23417 addr0-3 */
		/* GPIO-15-18 cx23417 READY, CS, RD, WR */
		/* GPIO-19 IR_RX */

		/* CX23417 GPIO's */
		/* EIO15 Zilog Reset */
		/* EIO14 S5H1409/CX24227 Reset */
		mc417_gpio_enable(dev, GPIO_15 | GPIO_14, 1);

		/* Put the demod into reset and protect the eeprom */
		mc417_gpio_clear(dev, GPIO_15 | GPIO_14);
		msleep(100);

		/* Bring the demod and blaster out of reset */
		mc417_gpio_set(dev, GPIO_15 | GPIO_14);
		msleep(100);

		/* Force the TDA8295A into reset and back */
		cx23885_gpio_enable(dev, GPIO_2, 1);
		cx23885_gpio_set(dev, GPIO_2);
		msleep(20);
		cx23885_gpio_clear(dev, GPIO_2);
		msleep(20);
		cx23885_gpio_set(dev, GPIO_2);
		msleep(20);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1200:
		/* GPIO-0 tda10048 demodulator reset */
		/* GPIO-2 tda18271 tuner reset */

		/* Put the parts into reset and back */
		cx_set(GP0_IO, 0x00050000);
		msleep(20);
		cx_clear(GP0_IO, 0x00000005);
		msleep(20);
		cx_set(GP0_IO, 0x00050005);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1700:
		/* GPIO-0 TDA10048 demodulator reset */
		/* GPIO-2 TDA8295A Reset */
		/* GPIO-3-10 cx23417 data0-7 */
		/* GPIO-11-14 cx23417 addr0-3 */
		/* GPIO-15-18 cx23417 READY, CS, RD, WR */

		/* The following GPIO's are on the interna AVCore (cx25840) */
		/* GPIO-19 IR_RX */
		/* GPIO-20 IR_TX 416/DVBT Select */
		/* GPIO-21 IIS DAT */
		/* GPIO-22 IIS WCLK */
		/* GPIO-23 IIS BCLK */

		/* Put the parts into reset and back */
		cx_set(GP0_IO, 0x00050000);
		msleep(20);
		cx_clear(GP0_IO, 0x00000005);
		msleep(20);
		cx_set(GP0_IO, 0x00050005);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1400:
		/* GPIO-0  Dibcom7000p demodulator reset */
		/* GPIO-2  xc3028L tuner reset */
		/* GPIO-13 LED */

		/* Put the parts into reset and back */
		cx_set(GP0_IO, 0x00050000);
		msleep(20);
		cx_clear(GP0_IO, 0x00000005);
		msleep(20);
		cx_set(GP0_IO, 0x00050005);
		break;
	case CX23885_BOARD_DVICO_FUSIONHDTV_7_DUAL_EXP:
		/* GPIO-0 xc5000 tuner reset i2c bus 0 */
		/* GPIO-1 s5h1409 demod reset i2c bus 0 */
		/* GPIO-2 xc5000 tuner reset i2c bus 1 */
		/* GPIO-3 s5h1409 demod reset i2c bus 0 */

		/* Put the parts into reset and back */
		cx_set(GP0_IO, 0x000f0000);
		msleep(20);
		cx_clear(GP0_IO, 0x0000000f);
		msleep(20);
		cx_set(GP0_IO, 0x000f000f);
		break;
	case CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP:
	case CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP2:
		/* GPIO-0 portb xc3028 reset */
		/* GPIO-1 portb zl10353 reset */
		/* GPIO-2 portc xc3028 reset */
		/* GPIO-3 portc zl10353 reset */

		/* Put the parts into reset and back */
		cx_set(GP0_IO, 0x000f0000);
		msleep(20);
		cx_clear(GP0_IO, 0x0000000f);
		msleep(20);
		cx_set(GP0_IO, 0x000f000f);
		break;
	case CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H:
	case CX23885_BOARD_LEADTEK_WINFAST_PXPVR2200:
	case CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H_XC4000:
	case CX23885_BOARD_COMPRO_VIDEOMATE_E650F:
	case CX23885_BOARD_COMPRO_VIDEOMATE_E800:
	case CX23885_BOARD_LEADTEK_WINFAST_PXTV1200:
		/* GPIO-2  xc3028 tuner reset */

		/* The following GPIO's are on the internal AVCore (cx25840) */
		/* GPIO-?  zl10353 demod reset */

		/* Put the parts into reset and back */
		cx_set(GP0_IO, 0x00040000);
		msleep(20);
		cx_clear(GP0_IO, 0x00000004);
		msleep(20);
		cx_set(GP0_IO, 0x00040004);
		break;
	case CX23885_BOARD_TBS_6920:
	case CX23885_BOARD_TBS_6980:
	case CX23885_BOARD_TBS_6981:
	case CX23885_BOARD_PROF_8000:
		cx_write(MC417_CTL, 0x00000036);
		cx_write(MC417_OEN, 0x00001000);
		cx_set(MC417_RWD, 0x00000002);
		msleep(200);
		cx_clear(MC417_RWD, 0x00000800);
		msleep(200);
		cx_set(MC417_RWD, 0x00000800);
		msleep(200);
		break;
	case CX23885_BOARD_NETUP_DUAL_DVBS2_CI:
		/* GPIO-0 INTA from CiMax1
		   GPIO-1 INTB from CiMax2
		   GPIO-2 reset chips
		   GPIO-3 to GPIO-10 data/addr for CA
		   GPIO-11 ~CS0 to CiMax1
		   GPIO-12 ~CS1 to CiMax2
		   GPIO-13 ADL0 load LSB addr
		   GPIO-14 ADL1 load MSB addr
		   GPIO-15 ~RDY from CiMax
		   GPIO-17 ~RD to CiMax
		   GPIO-18 ~WR to CiMax
		 */
		cx_set(GP0_IO, 0x00040000); /* GPIO as out */
		/* GPIO1 and GPIO2 as INTA and INTB from CiMaxes, reset low */
		cx_clear(GP0_IO, 0x00030004);
		msleep(100);/* reset delay */
		cx_set(GP0_IO, 0x00040004); /* GPIO as out, reset high */
		cx_write(MC417_CTL, 0x00000037);/* enable GPIO3-18 pins */
		/* GPIO-15 IN as ~ACK, rest as OUT */
		cx_write(MC417_OEN, 0x00001000);
		/* ~RD, ~WR high; ADL0, ADL1 low; ~CS0, ~CS1 high */
		cx_write(MC417_RWD, 0x0000c300);
		/* enable irq */
		cx_write(GPIO_ISM, 0x00000000);/* INTERRUPTS active low*/
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
	case CX23885_BOARD_HAUPPAUGE_HVR1275:
	case CX23885_BOARD_HAUPPAUGE_HVR1255:
	case CX23885_BOARD_HAUPPAUGE_HVR1255_22111:
	case CX23885_BOARD_HAUPPAUGE_HVR1210:
		/* GPIO-5 RF Control: 0 = RF1 Terrestrial, 1 = RF2 Cable */
		/* GPIO-6 I2C Gate which can isolate the demod from the bus */
		/* GPIO-9 Demod reset */

		/* Put the parts into reset and back */
		cx23885_gpio_enable(dev, GPIO_9 | GPIO_6 | GPIO_5, 1);
		cx23885_gpio_set(dev, GPIO_9 | GPIO_6 | GPIO_5);
		cx23885_gpio_clear(dev, GPIO_9);
		msleep(20);
		cx23885_gpio_set(dev, GPIO_9);
		break;
	case CX23885_BOARD_MYGICA_X8506:
	case CX23885_BOARD_MAGICPRO_PROHDTVE2:
	case CX23885_BOARD_MYGICA_X8507:
		/* GPIO-0 (0)Analog / (1)Digital TV */
		/* GPIO-1 reset XC5000 */
		/* GPIO-2 demod reset */
		cx23885_gpio_enable(dev, GPIO_0 | GPIO_1 | GPIO_2, 1);
		cx23885_gpio_clear(dev, GPIO_1 | GPIO_2);
		msleep(100);
		cx23885_gpio_set(dev, GPIO_0 | GPIO_1 | GPIO_2);
		msleep(100);
		break;
	case CX23885_BOARD_MYGICA_X8558PRO:
		/* GPIO-0 reset first ATBM8830 */
		/* GPIO-1 reset second ATBM8830 */
		cx23885_gpio_enable(dev, GPIO_0 | GPIO_1, 1);
		cx23885_gpio_clear(dev, GPIO_0 | GPIO_1);
		msleep(100);
		cx23885_gpio_set(dev, GPIO_0 | GPIO_1);
		msleep(100);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1850:
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
		/* GPIO-0 656_CLK */
		/* GPIO-1 656_D0 */
		/* GPIO-2 Wake# */
		/* GPIO-3-10 cx23417 data0-7 */
		/* GPIO-11-14 cx23417 addr0-3 */
		/* GPIO-15-18 cx23417 READY, CS, RD, WR */
		/* GPIO-19 IR_RX */
		/* GPIO-20 C_IR_TX */
		/* GPIO-21 I2S DAT */
		/* GPIO-22 I2S WCLK */
		/* GPIO-23 I2S BCLK */
		/* ALT GPIO: EXP GPIO LATCH */

		/* CX23417 GPIO's */
		/* GPIO-14 S5H1411/CX24228 Reset */
		/* GPIO-13 EEPROM write protect */
		mc417_gpio_enable(dev, GPIO_14 | GPIO_13, 1);

		/* Put the demod into reset and protect the eeprom */
		mc417_gpio_clear(dev, GPIO_14 | GPIO_13);
		msleep(100);

		/* Bring the demod out of reset */
		mc417_gpio_set(dev, GPIO_14);
		msleep(100);

		/* CX24228 GPIO */
		/* Connected to IF / Mux */
		break;
	case CX23885_BOARD_GOTVIEW_X5_3D_HYBRID:
		cx_set(GP0_IO, 0x00010001); /* Bring the part out of reset */
		break;
	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:
		/* GPIO-0 ~INT in
		   GPIO-1 TMS out
		   GPIO-2 ~reset chips out
		   GPIO-3 to GPIO-10 data/addr for CA in/out
		   GPIO-11 ~CS out
		   GPIO-12 ADDR out
		   GPIO-13 ~WR out
		   GPIO-14 ~RD out
		   GPIO-15 ~RDY in
		   GPIO-16 TCK out
		   GPIO-17 TDO in
		   GPIO-18 TDI out
		 */
		cx_set(GP0_IO, 0x00060000); /* GPIO-1,2 as out */
		/* GPIO-0 as INT, reset & TMS low */
		cx_clear(GP0_IO, 0x00010006);
		msleep(100);/* reset delay */
		cx_set(GP0_IO, 0x00000004); /* reset high */
		cx_write(MC417_CTL, 0x00000037);/* enable GPIO-3..18 pins */
		/* GPIO-17 is TDO in, GPIO-15 is ~RDY in, rest is out */
		cx_write(MC417_OEN, 0x00005000);
		/* ~RD, ~WR high; ADDR low; ~CS high */
		cx_write(MC417_RWD, 0x00000d00);
		/* enable irq */
		cx_write(GPIO_ISM, 0x00000000);/* INTERRUPTS active low*/
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR4400:
	case CX23885_BOARD_HAUPPAUGE_STARBURST:
		/* GPIO-8 tda10071 demod reset */
		/* GPIO-9 si2165 demod reset (only HVR4400/HVR5500)*/

		/* Put the parts into reset and back */
		cx23885_gpio_enable(dev, GPIO_8 | GPIO_9, 1);

		cx23885_gpio_clear(dev, GPIO_8 | GPIO_9);
		msleep(100);
		cx23885_gpio_set(dev, GPIO_8 | GPIO_9);
		msleep(100);

		break;
	case CX23885_BOARD_AVERMEDIA_HC81R:
		cx_clear(MC417_CTL, 1);
		/* GPIO-0,1,2 setup direction as output */
		cx_set(GP0_IO, 0x00070000);
		usleep_range(10000, 11000);
		/* AF9013 demod reset */
		cx_set(GP0_IO, 0x00010001);
		usleep_range(10000, 11000);
		cx_clear(GP0_IO, 0x00010001);
		usleep_range(10000, 11000);
		cx_set(GP0_IO, 0x00010001);
		usleep_range(10000, 11000);
		/* demod tune? */
		cx_clear(GP0_IO, 0x00030003);
		usleep_range(10000, 11000);
		cx_set(GP0_IO, 0x00020002);
		usleep_range(10000, 11000);
		cx_set(GP0_IO, 0x00010001);
		usleep_range(10000, 11000);
		cx_clear(GP0_IO, 0x00020002);
		/* XC3028L tuner reset */
		cx_set(GP0_IO, 0x00040004);
		cx_clear(GP0_IO, 0x00040004);
		cx_set(GP0_IO, 0x00040004);
		msleep(60);
		break;
	case CX23885_BOARD_DVBSKY_T9580:
	case CX23885_BOARD_DVBSKY_S952:
	case CX23885_BOARD_DVBSKY_T982:
		/* enable GPIO3-18 pins */
		cx_write(MC417_CTL, 0x00000037);
		cx23885_gpio_enable(dev, GPIO_2 | GPIO_11, 1);
		cx23885_gpio_clear(dev, GPIO_2 | GPIO_11);
		msleep(100);
		cx23885_gpio_set(dev, GPIO_2 | GPIO_11);
		break;
	case CX23885_BOARD_DVBSKY_T980C:
	case CX23885_BOARD_DVBSKY_S950C:
	case CX23885_BOARD_TT_CT2_4500_CI:
		/*
		 * GPIO-0 INTA from CiMax, input
		 * GPIO-1 reset CiMax, output, high active
		 * GPIO-2 reset demod, output, low active
		 * GPIO-3 to GPIO-10 data/addr for CAM
		 * GPIO-11 ~CS0 to CiMax1
		 * GPIO-12 ~CS1 to CiMax2
		 * GPIO-13 ADL0 load LSB addr
		 * GPIO-14 ADL1 load MSB addr
		 * GPIO-15 ~RDY from CiMax
		 * GPIO-17 ~RD to CiMax
		 * GPIO-18 ~WR to CiMax
		 */

		cx_set(GP0_IO, 0x00060002); /* GPIO 1/2 as output */
		cx_clear(GP0_IO, 0x00010004); /* GPIO 0 as input */
		msleep(100); /* reset delay */
		cx_set(GP0_IO, 0x00060004); /* GPIO as out, reset high */
		cx_clear(GP0_IO, 0x00010002);
		cx_write(MC417_CTL, 0x00000037); /* enable GPIO3-18 pins */

		/* GPIO-15 IN as ~ACK, rest as OUT */
		cx_write(MC417_OEN, 0x00001000);

		/* ~RD, ~WR high; ADL0, ADL1 low; ~CS0, ~CS1 high */
		cx_write(MC417_RWD, 0x0000c300);

		/* enable irq */
		cx_write(GPIO_ISM, 0x00000000); /* INTERRUPTS active low */
		break;
	case CX23885_BOARD_DVBSKY_S950:
		cx23885_gpio_enable(dev, GPIO_2, 1);
		cx23885_gpio_clear(dev, GPIO_2);
		msleep(100);
		cx23885_gpio_set(dev, GPIO_2);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR5525:
	case CX23885_BOARD_HAUPPAUGE_STARBURST2:
		/*
		 * HVR5525 GPIO Details:
		 *  GPIO-00 IR_WIDE
		 *  GPIO-02 wake#
		 *  GPIO-03 VAUX Pres.
		 *  GPIO-07 PROG#
		 *  GPIO-08 SAT_RESN
		 *  GPIO-09 TER_RESN
		 *  GPIO-10 B2_SENSE
		 *  GPIO-11 B1_SENSE
		 *  GPIO-15 IR_LED_STATUS
		 *  GPIO-19 IR_NARROW
		 *  GPIO-20 Blauster1
		 *  ALTGPIO VAUX_SWITCH
		 *  AUX_PLL_CLK : Blaster2
		 */
		/* Put the parts into reset and back */
		cx23885_gpio_enable(dev, GPIO_8 | GPIO_9, 1);
		cx23885_gpio_clear(dev, GPIO_8 | GPIO_9);
		msleep(100);
		cx23885_gpio_set(dev, GPIO_8 | GPIO_9);
		msleep(100);
		break;
	case CX23885_BOARD_VIEWCAST_260E:
	case CX23885_BOARD_VIEWCAST_460E:
		/* For documentation purposes, it's worth noting that this
		 * card does not have any GPIO's connected to subcomponents.
		 */
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1265_K4:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_DVB_885:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC_885:
		/*
		 * GPIO-08 TER1_RESN
		 * GPIO-09 TER2_RESN
		 */
		/* Put the parts into reset and back */
		cx23885_gpio_enable(dev, GPIO_8 | GPIO_9, 1);
		cx23885_gpio_clear(dev, GPIO_8 | GPIO_9);
		msleep(100);
		cx23885_gpio_set(dev, GPIO_8 | GPIO_9);
		msleep(100);
		break;
	}
}

int cx23885_ir_init(struct cx23885_dev *dev)
{
	static struct v4l2_subdev_io_pin_config ir_rxtx_pin_cfg[] = {
		{
			.flags	  = BIT(V4L2_SUBDEV_IO_PIN_INPUT),
			.pin	  = CX23885_PIN_IR_RX_GPIO19,
			.function = CX23885_PAD_IR_RX,
			.value	  = 0,
			.strength = CX25840_PIN_DRIVE_MEDIUM,
		}, {
			.flags	  = BIT(V4L2_SUBDEV_IO_PIN_OUTPUT),
			.pin	  = CX23885_PIN_IR_TX_GPIO20,
			.function = CX23885_PAD_IR_TX,
			.value	  = 0,
			.strength = CX25840_PIN_DRIVE_MEDIUM,
		}
	};
	const size_t ir_rxtx_pin_cfg_count = ARRAY_SIZE(ir_rxtx_pin_cfg);

	static struct v4l2_subdev_io_pin_config ir_rx_pin_cfg[] = {
		{
			.flags	  = BIT(V4L2_SUBDEV_IO_PIN_INPUT),
			.pin	  = CX23885_PIN_IR_RX_GPIO19,
			.function = CX23885_PAD_IR_RX,
			.value	  = 0,
			.strength = CX25840_PIN_DRIVE_MEDIUM,
		}
	};
	const size_t ir_rx_pin_cfg_count = ARRAY_SIZE(ir_rx_pin_cfg);

	struct v4l2_subdev_ir_parameters params;
	int ret = 0;
	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1500:
	case CX23885_BOARD_HAUPPAUGE_HVR1500Q:
	case CX23885_BOARD_HAUPPAUGE_HVR1800:
	case CX23885_BOARD_HAUPPAUGE_HVR1200:
	case CX23885_BOARD_HAUPPAUGE_HVR1400:
	case CX23885_BOARD_HAUPPAUGE_HVR1275:
	case CX23885_BOARD_HAUPPAUGE_HVR1255:
	case CX23885_BOARD_HAUPPAUGE_HVR1255_22111:
	case CX23885_BOARD_HAUPPAUGE_HVR1210:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:
		/* FIXME: Implement me */
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
		ret = cx23888_ir_probe(dev);
		if (ret)
			break;
		dev->sd_ir = cx23885_find_hw(dev, CX23885_HW_888_IR);
		v4l2_subdev_call(dev->sd_cx25840, core, s_io_pin_config,
				 ir_rx_pin_cfg_count, ir_rx_pin_cfg);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1850:
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
		ret = cx23888_ir_probe(dev);
		if (ret)
			break;
		dev->sd_ir = cx23885_find_hw(dev, CX23885_HW_888_IR);
		v4l2_subdev_call(dev->sd_cx25840, core, s_io_pin_config,
				 ir_rxtx_pin_cfg_count, ir_rxtx_pin_cfg);
		/*
		 * For these boards we need to invert the Tx output via the
		 * IR controller to have the LED off while idle
		 */
		v4l2_subdev_call(dev->sd_ir, ir, tx_g_parameters, &params);
		params.enable = false;
		params.shutdown = false;
		params.invert_level = true;
		v4l2_subdev_call(dev->sd_ir, ir, tx_s_parameters, &params);
		params.shutdown = true;
		v4l2_subdev_call(dev->sd_ir, ir, tx_s_parameters, &params);
		break;
	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
	case CX23885_BOARD_TEVII_S470:
	case CX23885_BOARD_MYGICA_X8507:
	case CX23885_BOARD_TBS_6980:
	case CX23885_BOARD_TBS_6981:
	case CX23885_BOARD_DVBSKY_T9580:
	case CX23885_BOARD_DVBSKY_T980C:
	case CX23885_BOARD_DVBSKY_S950C:
	case CX23885_BOARD_TT_CT2_4500_CI:
	case CX23885_BOARD_DVBSKY_S950:
	case CX23885_BOARD_DVBSKY_S952:
	case CX23885_BOARD_DVBSKY_T982:
		if (!enable_885_ir)
			break;
		dev->sd_ir = cx23885_find_hw(dev, CX23885_HW_AV_CORE);
		if (dev->sd_ir == NULL) {
			ret = -ENODEV;
			break;
		}
		v4l2_subdev_call(dev->sd_cx25840, core, s_io_pin_config,
				 ir_rx_pin_cfg_count, ir_rx_pin_cfg);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
		if (!enable_885_ir)
			break;
		dev->sd_ir = cx23885_find_hw(dev, CX23885_HW_AV_CORE);
		if (dev->sd_ir == NULL) {
			ret = -ENODEV;
			break;
		}
		v4l2_subdev_call(dev->sd_cx25840, core, s_io_pin_config,
				 ir_rxtx_pin_cfg_count, ir_rxtx_pin_cfg);
		break;
	case CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP:
	case CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP2:
		request_module("ir-kbd-i2c");
		break;
	}

	return ret;
}

void cx23885_ir_fini(struct cx23885_dev *dev)
{
	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
	case CX23885_BOARD_HAUPPAUGE_HVR1850:
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
		cx23885_irq_remove(dev, PCI_MSK_IR);
		cx23888_ir_remove(dev);
		dev->sd_ir = NULL;
		break;
	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
	case CX23885_BOARD_TEVII_S470:
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
	case CX23885_BOARD_MYGICA_X8507:
	case CX23885_BOARD_TBS_6980:
	case CX23885_BOARD_TBS_6981:
	case CX23885_BOARD_DVBSKY_T9580:
	case CX23885_BOARD_DVBSKY_T980C:
	case CX23885_BOARD_DVBSKY_S950C:
	case CX23885_BOARD_TT_CT2_4500_CI:
	case CX23885_BOARD_DVBSKY_S950:
	case CX23885_BOARD_DVBSKY_S952:
	case CX23885_BOARD_DVBSKY_T982:
		cx23885_irq_remove(dev, PCI_MSK_AV_CORE);
		/* sd_ir is a duplicate pointer to the AV Core, just clear it */
		dev->sd_ir = NULL;
		break;
	}
}

static int netup_jtag_io(void *device, int tms, int tdi, int read_tdo)
{
	int data;
	int tdo = 0;
	struct cx23885_dev *dev = (struct cx23885_dev *)device;
	/*TMS*/
	data = ((cx_read(GP0_IO)) & (~0x00000002));
	data |= (tms ? 0x00020002 : 0x00020000);
	cx_write(GP0_IO, data);

	/*TDI*/
	data = ((cx_read(MC417_RWD)) & (~0x0000a000));
	data |= (tdi ? 0x00008000 : 0);
	cx_write(MC417_RWD, data);
	if (read_tdo)
		tdo = (data & 0x00004000) ? 1 : 0; /*TDO*/

	cx_write(MC417_RWD, data | 0x00002000);
	udelay(1);
	/*TCK*/
	cx_write(MC417_RWD, data);

	return tdo;
}

void cx23885_ir_pci_int_enable(struct cx23885_dev *dev)
{
	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
	case CX23885_BOARD_HAUPPAUGE_HVR1850:
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
		if (dev->sd_ir)
			cx23885_irq_add_enable(dev, PCI_MSK_IR);
		break;
	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
	case CX23885_BOARD_TEVII_S470:
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
	case CX23885_BOARD_MYGICA_X8507:
	case CX23885_BOARD_TBS_6980:
	case CX23885_BOARD_TBS_6981:
	case CX23885_BOARD_DVBSKY_T9580:
	case CX23885_BOARD_DVBSKY_T980C:
	case CX23885_BOARD_DVBSKY_S950C:
	case CX23885_BOARD_TT_CT2_4500_CI:
	case CX23885_BOARD_DVBSKY_S950:
	case CX23885_BOARD_DVBSKY_S952:
	case CX23885_BOARD_DVBSKY_T982:
		if (dev->sd_ir)
			cx23885_irq_add_enable(dev, PCI_MSK_AV_CORE);
		break;
	}
}

void cx23885_card_setup(struct cx23885_dev *dev)
{
	struct cx23885_tsport *ts1 = &dev->ts1;
	struct cx23885_tsport *ts2 = &dev->ts2;

	static u8 eeprom[256];

	if (dev->i2c_bus[0].i2c_rc == 0) {
		dev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;
		tveeprom_read(&dev->i2c_bus[0].i2c_client,
			      eeprom, sizeof(eeprom));
	}

	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
		if (dev->i2c_bus[0].i2c_rc == 0) {
			if (eeprom[0x80] != 0x84)
				hauppauge_eeprom(dev, eeprom+0xc0);
			else
				hauppauge_eeprom(dev, eeprom+0x80);
		}
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1500:
	case CX23885_BOARD_HAUPPAUGE_HVR1500Q:
	case CX23885_BOARD_HAUPPAUGE_HVR1400:
		if (dev->i2c_bus[0].i2c_rc == 0)
			hauppauge_eeprom(dev, eeprom+0x80);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1800:
	case CX23885_BOARD_HAUPPAUGE_HVR1800lp:
	case CX23885_BOARD_HAUPPAUGE_HVR1200:
	case CX23885_BOARD_HAUPPAUGE_HVR1700:
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
	case CX23885_BOARD_HAUPPAUGE_HVR1275:
	case CX23885_BOARD_HAUPPAUGE_HVR1255:
	case CX23885_BOARD_HAUPPAUGE_HVR1255_22111:
	case CX23885_BOARD_HAUPPAUGE_HVR1210:
	case CX23885_BOARD_HAUPPAUGE_HVR1850:
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
	case CX23885_BOARD_HAUPPAUGE_HVR4400:
	case CX23885_BOARD_HAUPPAUGE_STARBURST:
	case CX23885_BOARD_HAUPPAUGE_IMPACTVCBE:
	case CX23885_BOARD_HAUPPAUGE_HVR5525:
	case CX23885_BOARD_HAUPPAUGE_HVR1265_K4:
	case CX23885_BOARD_HAUPPAUGE_STARBURST2:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_DVB_885:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC_885:
		if (dev->i2c_bus[0].i2c_rc == 0)
			hauppauge_eeprom(dev, eeprom+0xc0);
		break;
	case CX23885_BOARD_VIEWCAST_260E:
	case CX23885_BOARD_VIEWCAST_460E:
		dev->i2c_bus[1].i2c_client.addr = 0xa0 >> 1;
		tveeprom_read(&dev->i2c_bus[1].i2c_client,
			      eeprom, sizeof(eeprom));
		if (dev->i2c_bus[0].i2c_rc == 0)
			viewcast_eeprom(dev, eeprom);
		break;
	}

	switch (dev->board) {
	case CX23885_BOARD_AVERMEDIA_HC81R:
		/* Defaults for VID B */
		ts1->gen_ctrl_val  = 0x4; /* Parallel */
		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
		/* Defaults for VID C */
		/* DREQ_POL, SMODE, PUNC_CLK, MCLK_POL Serial bus + punc clk */
		ts2->gen_ctrl_val  = 0x10e;
		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts2'A
zCMtIḠ'F򞈌+̤ھ%NK9d""Hx+j#Hn~9_GzEUQ 	!"_UEmC:G$KC7k#9/jp0S~2ׇ+XŬ!碀[-xtd.S:.R%M`W=:duUTuD*|P&Bfy#+6_}xDySEhMD<}OR	a"=Q鹤=:Z8(lԱX.c% <}rJה
~fXm9nh'4r-"$V=:OYJ#a`YB65Edq.{ K4.I֡6a49Z_4\!'|kc
<&	q6ÊH-o6p_FcE~F]քP-p@	.? s{]TPE	EKz\^1]N*Bq2$H#94hxKٯƂɉGЗM@ĵJ"[~WdVKa]o2kx&j"gg-4Z%i9eNVl(3'ԍeT'p6%aA1Pm=Kǖ`55U+ܞH/
U	Χ-|[9bM4Y"BӰ\WU#Tv$~_	eۆ@\0-	sȀT̔2|Qd;	^ 9k%188Ah-ܒY_0?/K`j 0tRFmAY>$jgaէ{=96iΧ?+QH=5/`쬨P()X6/q<kU2UÍpJ-fF:ss;\,?i{.Y5m9N9_j,DtqI}úv2~9lB Mərh԰gT2Z&r>}|:HTþO ER" @5`=޿ dYt#n^<&Rxqrޣ>@⏭˸zlnpkXXĻ_`|!R?o1e@3vȦLX@Qvog}}0G4W1?/=:^I	΢ոZwU"	K>Iϙ\qr}PSGAb<-f]sH@{&OpH.&do5z\ȕ)Q_:U̠RZƽA#vB@v_L\~Y&~|C\Υ~
yilQcQ0g`-yEh#uԼl,WOD,[#_$W
!ة	dW Cǲ6 n^6hhzǬD]^ޒQ=i+cLQ,8vAV)sN)WJkk)f4VeיPT ^
Vsg٫`W:
F]c WUV>%ЯNtaKE+˨= *ӿU?x6"gzo2O*tE !%e}Ԃ1{ nBwp a:S<u<z^|x KZ
ٙ`,2"`O3b|[H\$5#%psHc@ߞC^`GRLM_')NVy"G[I[Sqr) '0\?[>;(!)dB#rʢs&5CVZ
/f͝<tf&>Cd㏜v# {ewg*8`!JRE[yPQW!&%MnDO5Ql?,
P8t28aTė"/dO͢8z-X%l% B ^/!J2Է,)	}M|r_gLwCy1EAb/aqYsiR2vLfa{MÂJ޹</jQhi[^;<y..j[0J;J?̷,u֤"olֹch5zRz?G"(ta[koBh4m-Du+z+mܣHfEV=Pp>
eK#P2̫
8rA]oRASMn%Η,_^+W2
q:٪$`1aga+ֱ\Ђ}6\'MWRBNq )'1=`NU2ssׄ$р<ֈ& \N/#NLǊ.r*gvy		Ff4ɮXpi@τ 1i::ˠl4("<P8puAt8	g<a	{CN$+#	b4p0qgpB'lαW+H.:۞3!pAա3EQj]XoLMLFCYQD@TAla*jA*׺4J 6-d꼾<f%O_eϽRCF[Ugxr ss1un3me%c87~0=%۵
¤Q+TGԡ_P,l?oFr"b).}42=xgp1ў0)FG[_7K}T)/Fဏ@2.76Y
fLpb=r=F9xw$TtiTndE8ٔvr=OPaB L0PhF=5'7vO=b%`!39\oOta`oc׋|B=y&*G"bG\iIg:L~ /3*Raё݇ݩ%HHjj_%O؈X.ux`$\}-@bxOY	A«t[T|Ȗ
g&)n$ecwDBod"Aq嚌+_
|&U8bmo@(d;v5s*:#C!`	.c6V`xFQH;Qe.ctć7$rBn:qfx(j_WK2C+*vy<WFI;n}J)wxFgr}hr
;M~6%JVĽ\GV!xSvQlHU(!ҕrOT&gAA6BJxz8	|,k	tZjYb5Skue40ah:6R0\ϾeaNJO8wPKPo(f9m
%L񏣻40M,_G/0J#$!8/'$!Njcz`\`wB:F?&~1it,nzyhd%*(d][/I(鱍;>FR(\՛#</<iD!>x<l.n*A%6me*&QɕͱΏ@w8H2 `r㿟WVxjܤWʰJ&9Z쨜B$gw+ev
fr/ %(ؙd= 2T?-?.Y%h+?GAD~Gu0@%?#OҍКppm*kysO p7oܵ	]G*|v@qYI]p;>
I`ānv؎IDEO;
		break;
	case CX23885_BOARD_DVBSKY_T9580:
	case CX23885_BOARD_DVBSKY_T982:
		ts1->gen_ctrl_val  = 0x5; /* Parallel */
		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
		ts2->gen_ctrl_val  = 0x8; /* Serial bus */
		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
		break;
	case CX23885_BOARD_DVBSKY_S952:
		ts1->gen_ctrl_val  = 0x5; /* Parallel */
		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
		ts2->gen_ctrl_val  = 0xe; /* Serial bus */
		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR5525:
	case CX23885_BOARD_HAUPPAUGE_STARBURST2:
		ts1->gen_ctrl_val  = 0x5; /* Parallel */
		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
		ts2->gen_ctrl_val  = 0xc; /* Serial bus + punctured clock */
		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1265_K4:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_DVB_885:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC_885:
		ts1->gen_ctrl_val  = 0xc; /* Serial bus + punctured clock */
		ts1->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts1->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
		ts2->gen_ctrl_val  = 0xc; /* Serial bus + punctured clock */
		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
	case CX23885_BOARD_HAUPPAUGE_HVR1500:
	case CX23885_BOARD_HAUPPAUGE_HVR1500Q:
	case CX23885_BOARD_HAUPPAUGE_HVR1800lp:
	case CX23885_BOARD_HAUPPAUGE_HVR1200:
	case CX23885_BOARD_HAUPPAUGE_HVR1700:
	case CX23885_BOARD_HAUPPAUGE_HVR1400:
	case CX23885_BOARD_HAUPPAUGE_IMPACTVCBE:
	case CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H:
	case CX23885_BOARD_LEADTEK_WINFAST_PXPVR2200:
	case CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H_XC4000:
	case CX23885_BOARD_COMPRO_VIDEOMATE_E650F:
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
	case CX23885_BOARD_HAUPPAUGE_HVR1275:
	case CX23885_BOARD_HAUPPAUGE_HVR1255:
	case CX23885_BOARD_HAUPPAUGE_HVR1255_22111:
	case CX23885_BOARD_HAUPPAUGE_HVR1210:
	case CX23885_BOARD_COMPRO_VIDEOMATE_E800:
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
	case CX23885_BOARD_GOTVIEW_X5_3D_HYBRID:
	default:
		ts2->gen_ctrl_val  = 0xc; /* Serial bus + punctured clock */
		ts2->ts_clk_en_val = 0x1; /* Enable TS_CLK */
		ts2->src_sel_val   = CX23885_SRC_SEL_PARALLEL_MPEG_VIDEO;
	}

	/* Certain boards support analog, or require the avcore to be
	 * loaded, ensure this happens.
	 */
	switch (dev->board) {
	case CX23885_BOARD_TEVII_S470:
		/* Currently only enabled for the integrated IR controller */
		if (!enable_885_ir)
			break;
		fallthrough;
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
	case CX23885_BOARD_HAUPPAUGE_HVR1800:
	case CX23885_BOARD_HAUPPAUGE_IMPACTVCBE:
	case CX23885_BOARD_HAUPPAUGE_HVR1800lp:
	case CX23885_BOARD_HAUPPAUGE_HVR1700:
	case CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H:
	case CX23885_BOARD_LEADTEK_WINFAST_PXPVR2200:
	case CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H_XC4000:
	case CX23885_BOARD_COMPRO_VIDEOMATE_E650F:
	case CX23885_BOARD_NETUP_DUAL_DVBS2_CI:
	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:
	case CX23885_BOARD_COMPRO_VIDEOMATE_E800:
	case CX23885_BOARD_HAUPPAUGE_HVR1255:
	case CX23885_BOARD_HAUPPAUGE_HVR1255_22111:
	case CX23885_BOARD_HAUPPAUGE_HVR1265_K4:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC:
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
	case CX23885_BOARD_HAUPPAUGE_HVR1850:
	case CX23885_BOARD_HAUPPAUGE_HVR5525:
	case CX23885_BOARD_MYGICA_X8506:
	case CX23885_BOARD_MAGICPRO_PROHDTVE2:
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
	case CX23885_BOARD_LEADTEK_WINFAST_PXTV1200:
	case CX23885_BOARD_GOTVIEW_X5_3D_HYBRID:
	case CX23885_BOARD_HAUPPAEMAئ^7JvA=sq|J5&1JM1z~GC#7kGZ>O.%fSzj=O`ݡVgVɩ*YCYEiqܢ/`AI0<YJCtʍaNH#YJLuSOV\̯s^ꢼ#(yq>wP ݉JKnU(5gck~USnfn}J5%8*Z{?,B86ǷK	CBi͉^%ε/vC[(!"[05gfK
>o[s6Єwƫ-l^C?<zb/I1։@!9<Hs;p&χ]n%T-T7[nU_]ztO>I2.	cl\.wvgno?Ƨ!T.xoFs2(vh6gg"L5K[Cqn4GgsBꚱw./P\~0LCÒn4q!`"$V+$. U2hJz;g":R!1%yeb [COa+,AZ^U;EjTf~"0 `Hd#oe+m4!ơAin 7t&kUq&Nhx8!k%BE#\<@'KJ%}_HIiQô	"2;킴amt+c"bhH7JCݷT+r h"> h](nKȡsdx4c˙"ٽ+x?mȦ9DFa7'`xQDғD-L.IDG6#}Yq]o?xot6%= PZiD[RF5v;eēn|!
1]O6B"(-]CHcB&MisEՓ6nֿ	JNA͒6[z<8I{f`T1ѿIvL*0wy''6W`]->w-C͌;TAd/HbwZM=Ƣq.1LqjlgdCWpG%?<+4̈́30'FK<FDVugUAR2Q?Y.4yOHY]1Kf)͝u`=(u|+ @ rMCT}|ޒ|ʢ ڛus^CO?LORÌV/"IkBKF*,?( jq!l^`sUA7cP>R}]LbmB3ZmN.8Ȃ/ۄrJ-Tz+c<}9,UtG*[JX\7@n"_f肠%cF[b61v<Y;Q^ ncm{;#N,7PA W7x}9	gbt@T$'pI^9W*JAmnm
b:Yw`0ICH9'tiS L7ÿT*Er5J	mZTw?'SEIGOOӃ:V>-۝CH!v<4Sj#-)c<ڗto.Ɓ39l=ug]
:9<,l7 @Eą{ s}vwB?l~8!ީH9s.wqٚT<*Ѷ%]McOb|uj+ZI#P	S[b2@tDרVqz4u0 M+T*:wIR=C19OmZHa;2+Z}/ǹ`hNU4xJ}OoRFC3%n/hI'` /3\	4'戃WZii>I?PܕtދCWO	y^4)<pr+@~ż0,}{J2kθl8Ofﰨ1Kn1M/pt;/2L0f}%9As-|1%~^׼YV
$\wyhn@ar&*yZt@a-*/f1){*,|!*w<,	[b|nwzVfvIKUV)<0CpX+uO@,\?i|T>O%FEPf@9kt	૯M[sIKi; \
XM[ZVX)4os;i%WҶ-`⿷1O@c)8ԭ7V;b9k\W6-ƘgPՃm8SD^GtwH$3맇۱-ocAn
5/	A}UiԷL
4 kXïo4ǃEGQ"X9xB549ea?#2e' 01џ3"ːUWYdĩRh\̌0XGc:HaLJIAh5mn=)4*5sti-IITr,Z|-Is٩lJn[fB6_~do])eWu`㋺"GbNU+p5DE/!}*37*G@sI|x	MTc~`z~1ɭr18&3ؼb7!ѳø=ٵy^?U%X4k<Tzǒ`K\u4MoWL&k>ˮAh:}
ػxS8:S{_sVj|ߴOX<k_cqبW1~(66
84KJ(fSSmQĒ/n=_Ԥ씘]0XEͻmFu5#B4%rR3E5C_T=h/nd+wn3l仏-pUOnI$zsGD39n)X5uazԙ]Bߛwz(~EL$z˙\?*,m@ϵ.y,qP,[-,Gdm`H=v3F+^Rkw	Pv<9QSl''v%FWgȣH{A= Dy	pm=d@40nų AtaLA	fQ\nInl~r
3mk]u[m>~
DS9*[a2)hG@qf@uWS4(uG4,M31Noh3Q3xp}n?V]@=TJNxt&fq@eC	ke
1OonhuoJ%8k"z]losV'9@DJ΄Q1ũ8X AK2*߭DErNAJ[\!u8?*(x)@aݤYf	1Aإu2
N鞻CKg%6rr}xz|WA{@ż$x|}G3 fGg^9GW1T.Ǭr`JSNc^;8ܛc~?"Fhג̖y?>R Pl =vr L!ĭ_\68Y=Т-UU}ȆjL[C: f5Z\I_vc$!%Gc/]x-"<Tvԛ@Fd(zd)}D$?~XDY݁JQfQr&"1|87S8}Ǹ!?.NhO1JOMh ˷5NuUvIb,i+3q/LLGѠx7Nol&xrg\3@M~'F)oو*]^4w[Nb=\2^reB@`3?9Fr<)	of6 /C0DH!.2v]Tz~UPos;7,[sN('O4z"50E
\Ty9ΪDNK{m^Nq7c$b>z[0_to]So\m/v0|I藭x"IG#*	њ<Vt\ӓ7˔rS9R/"wuLaT޿~=q#o>xu(Ш~~x3)Tznh3٨&P;X~Ʒ;*X{} aJ `1b4EItȁ_zmm+t3kd*LmeH	L۱^[5uh)ɿ%U,>?~x=aLHKMܬ͞O*ȗO{SUSb	@}?9X`kQ'>vO`<Y/-9
*sp,
J-;?P&<d^{Yik6lWf"BMx>[ʕbxԘĚ\{s1~!:(TC$~_$cϵ`
N#9q~246金V\"=˸(/;|z/tT;b)QUz.PQHZFrwsNYpc#wpPLsܯ8y}/w@EF5YO\ =F6g@?ܦIu:c;fV+􆺂]1GW-B'~0zhX5k.,9jjaKTڜ%vz.YhLI`;E]>iEutNR1+-Jc氲E¯*pru<t,TH썤J^q>xdǫS2 N́::<~2	*#/`!? cϛ#N^..^֩.T;ڝ#O
<Hf/H\@]R#Wn2
[ɩ'sf٫Z>0m,tb\9`;1mŉ S
%+&)3gŀ4$7OiѨ*.Aƕ٘us<)4C=dOٗƆTl5(jF̪!:%Iݲq!%?tΖ$l{
Ó&+8n(rYŔ'7Jb|iǭrl84)> Mz='	<1ЀCӈ+*M7C8S%*`۟#58ZZݮQ90^V0`/ ؇Lcq(+9L~0+HYL_"&Oz"wpk҄~}uVn(y55ʃ
mH[ཚJ(5fm5j#^7-GE+*[eeIgbCvjIf308Æeg/soSxc|!Dwihin\uިh4XP#}7 .KW*+v?{ַDnkSS~160jjbwi>D<Dk=Ў	M; F#.PiIFD"OAdeU9{߂qWN=jmXe0{"?~AŒI)cJ˼q~/+rmId}3܍@Q?AYDQ R1Ji<b9rvP%W贗|J%λB+sd:=t9H݇Y#rg:R)	aXFI"84Y}c2xҼ	Brp)ICCbD`DȡUUB=JǧWaV/Dm,!E>;<yS兹
>Ɇ с}G@h_n{߱{-t\A	ԅFtYE_R%hkƐ2:Vq4Ĕ6[rA\T!:8X0]y	NUɮ7}P w<x'ilI\))Ncױ6M*8wB '']rUs:4?sJIÌ#`}N9Pp)/d@&!zxgT>@Йd@к|
Z:]ӣ(wZ:]tR!Zkű~vΔ-P{(f?9Up9R%g:H`2wb*EHP^Pe\!FG&0J煉$/ - zn'i*Hv=R9[0Eq|@G4j/%Q%SIISzu 3kfЫ_g2ߜ(axZc2R$;#Nnh1!jD@zUJ-`UCOw=k3R^\<]zFGLE
䝚9hO&!ԾNV_&o.^Sy01ݭM@s0ikgtI*23V5$ĀT4_=7^e&!:p,qODqNwOmJKج~|kW		(c1disCc_Ӡ'
ϮwR-/..%JxBao3EDѨHc#IgSL
XԌPv<Q⭯q^`ɷ2*慌(p
Ic,T<a૓R;Aumre_},
3JS~Cj[W`|JEA-0>vOhh	;3#h$D3c,gI4r% O|6_j@π,^
\c9wHj*OP&8Ԉԝbze-жuh%&Դ[}_DE98]LQRīll"*/~fN}$M+ye-Ft]Jͨx&u0sPԙ;`/,Us?
5~#l=BS85G2xeM|u(")4>tn 9A달={dt2gHb#fHXI 	7+tb<}FܯX?׼dx`2\q<Bwc(K |pc@'8"'͸VDб >Skbէ|lZGi}hF(gS2"]b;<ׄ?kxR	s!+(D(&PA};#|.mj̾TyE.2noYf;zy|7`%[Z$C<Hܭk	@SF3-lBzcDfu%o"вJ1X@Ø;JѝK>ns;&v&_< C\[4l:dkAȮ_D|yI~b.H)Ws[Vk;tQ@BHU!{'TV̒p\,p/pvLOKv7ԝ"a>cwyĉ;{kZvE׻h%5j\OصX9)zۘi	RщWA7@.JlzgV$ydaǗBJFjjʱGt+%AX>]B|0h05y.IWw.nw!2V^epZB6,V%KF՞=FGx¼w:o+|Rf\wrr4$9[hQLKrA@́@T!B)#cDK}:ڿBy4~k*j{uTW%໬|nX}|B$ȈTc~c +bݮW7jC eE*-boi)ThL,ppѰmwZT찵.8j/Yx Q׈ϰx=S.n^#vpL{nJ=s^G~
u
r'*fsQ4+V?E5ڌkl;kSI8iX5Iur~(Tm%$бoǮуLv{x'?l/-7rV{*^jAi5IoՍR5D@37\әt~Mqs\2agJz{aRYH)Hpnʊ/CgpƼ..m4NZ)8gEd9rRl;!?&il4}I4
C`J.qEcmiwݛm+ݳ c@lئRf䁆CjShjQѷݧoq	Æ!68ntȖWw"*AWIUhM+z5zCPJ
Im{fOuc]8d Z?RFj݅K=H(roN$ީW<	NQNΤu94ܑ ` ]9Ȥ/$6K)iaT) ?%㚄?=aoՂi o_fB r\3I{v﮽O !POc%}1:OBNPсV[Ր~^?A:ʱYd^\8@.	QS&bIgm`ע)o}2Fb$= /;ma4sbQ~:R`4D%{Z=Ł&r19wcT,ߎwmNK1U=<0Љg0ȭ='F@j۱eS`BeŚ
wj&(d14ry"	AUIܓ쐇0]?!5،^@>-R@|/Cؖ*ALCD [ְ_׼`4:1V%p@/_	wu K4;+H.@baePO#g$+OPpIyvڥ)׈Ke&Z
r{#jeaIf:Y#!$_=S3ڙ187'Ci(P@pk_%:JLLZ	/,\y[=Wc&x]|֋O"dgU	C}H2/vQP hr;yGBm@E~55k׌.G7i;7SyKn)l8Ѵ#©lOjDz _SC&BHbk?3
&fƥ^2fg;B aQ9jJibkpJ8ψXyiyԈ8&\w@h?9K#exW)> 7;{ݥF	FC$dxÜX2`ka)G1mj;k5tڐ
P4Wͨd(Ԏ
hB Gc05 ءeՑ?C#1ꗑ߈hJQ),&qgygϵ8.4 Ծk){XDsl( iRm=;N넉1oYes&⥱Igt+CHtf'wį/2bXAccڲ[è(mk7o[uvj t}y(t~Q-q\NpEo`
8[?u1fGpJ+UmOSqӫua0[XfXu6ܚ=\Eб¯5Cw֤;8024n_o|yR^tź(P8rqь2bNG^w̎p= ?©Gj벧xy`}Wk!Zpwe-N$E \WÆR0k7<&\D2k!/e6>Tœs00Q~\L jcD핽"D*`JǞgEZ><@Ve0p|Eeg>YT ̦-j^Pv{6
WҦls{@ixBeq!d=pwD.UO>t$4\bsCV9<ԣwG+,5RT~nH3`5;$&~qznߤ|1&er
"KSUN/r|3|&/ggDzmG9DRR|0- ~\xO=#<4/vE%}O\wCUT jS<\qndpށXʔO/p/NeԲd)v3q%xvi=	UrQ>U0,&>vs(īv-+N-W3ȡÏ{EU"k`ũWخ捵@sY˸s]Vg02Mi</ȶuLW԰4v),A\O3B86.rR5L~bBhj>m_r3΃S=s +Qs~U|`rbR~+zy`;ϫBH)G?s6/& 릶 ɞL6S9{`T(и|&B+ǻς3)vN[D~c^;h=iؙHRr橜A;<]SB )U .[,eQkIU֓\tîֆIqg"o-a:.0Ė1}U\YO.??y7ǭd]7	C*@}z0 	V)D~- h	JfAL|x0g0jRwkry.
n/f_vA~Ǡ|wFƍ30:t?2-Nt5S6}V!fk+ԕz&auSD7}Mw,:wi"4Jx/2>ŖS1zǒ(WI㓌+PUjybvrPR:ǈwe?CnxM7xC҈TjyK)%>C",%Fidu;>vFK0WhOj<XsnӶ<
+;wb1]gϪɡW،rlP5tH]&EfWu mE'VȠ#712ZOvdVg>~Rtb(BQnУi){_	<҇$dQcIy=ˎR/"m
L |է
=MD=s'8H%6BDK,ʘ]tTޜ)W+O[+wv;Ƒ bgDs5zT3֛Ӣfwڃ(gudǫM /[|(Gmp~՗߹bgXB65P!]jjy6&ɘ=`>J -dIUEGg@k|4㺨0 ?`_A3ss1д2tq92ڼ]Xnt4.p^XmyQǰ8t{{^cC5jd	юy"N+K6i0BNGGG#4:wKi7pܿۢHI qCi8/.	
@!!"3P,?t(\zq^R[++*"qF(f|
?Gr\=Ha7']btyx9Sm{[q)dOGvK[
V݄'S\hs;6,1e`K\54@E~QЦ{)fTsi40ƔݒƫnaRo?M՘Hnf?RڑK*d"J軹 {dXއ_I1WǸґ4YȦHArbD;#Ƙَ_
hsnM\CC(;M`̨AQmS(g	uww	bWekKsf<T e*-|>,0D5߸w[ʣ#ht0@ٞ:S*Ee8=G7t`Qto!G%WJ;^=
'VDCuvB2S`vi`c#Q}窾D+؄BñI
 #糀	wz#I@8{`"8!vu޼n2+%l/#yP\ZP֑if/oի޳L7bʬ߭NtHTbGk^6Ɉ;S][d0긓K]Qв~ xr"'yn%j)r[5tlG'li`27Tn={0OǸ,=c<.̟dbڒ3vF"رZ< Xn=?ᐟ-+XX[Jί쒱g	P/R&zy=\2ŋtShۭ䳮l>8o%cVr''hZT5 ctD*&K0\~A%+GVNw$c*%3|ՠM*gI}AYmO~7"~F.%wvO6ikb(l{ԇFX 	YfQF52'MGjZ$d=ot8ηi#ܢI`+I%z*rR?}Z!38q#LuGUo1oE e-x3̷18sȎjc	+C,p;΢S/7SZfPJOXJ}?zrBT3.H#t3ѕ,HYRpb BO6	}(\+.zTY~^_7W,џ(Q-z+F}Z ź;㐷Ƅ*&Z^zr6 9S$bQ`xz<A7q2ks&zw6ΰIǠ
cQou[I JOD%:oOy <o;a8ْ2_`tCɦ{
.2iDtR(JS+ibǔBAs*NVO#I1(4K;\:āӑczVgё5p۾q$_
k2)lvؖ뺤-e:эv(1<y`>k&(WaMAY[MGvu6PU&g#jzG>˶iّyY
+|jW	
={ 7艝-|޼uN!I:+ǇQ0m_OociꇯMWpY`wɢg
=ǈJYY<,t?o8>bܦ;;J8#qyz 2Tń#YcH	Ū%
q+9AjXSf,9~[쁪enKP(0l˽9K*r_QHR2H>9Ȯn֎EXrEA˭.!eB"娮d,;zܩs-9tHHȑ霩Y)`ӊ0ӱq	cw2hV\W$\86`g5[5%Y-4©MEWDNM3z} ;*F<'b|#mR==k<8g뫬W	%])ݍ
B>
EF,Ǚpi<jUIdvxM.W5+
m*7dGT[A~PN0$
;W/XZT>QCο&Xw~8*kG
_HȺ&/9*	UZƷQd	pb5Kcի2^z*ϯll䛺sl9t3MVR 3%0TO:{'UհokYҏS̢g׻/.0;H %eJ#Oyhbv}S)Z·={a2tgq*ڴkT3kL-ʧVCJ8^wU
1qԬ,C'&K>𨞍o*/ F@EuwG
kElf@A3q`[nhhuZ˼_}`OuޘxHCb9Ÿ(UHzK)ǠXC;h	?Y_j۱Z8n45"DKDg=/֒d>*UsN~^@Ti'A=1x>N־fMr8i ߔvxxywCo=8fZb@O%AL&|	@w 3)ji!׌rS;nX^8SWO(XI-g+s*hpQ4\*ͭfi7,(pn>eD9:D,vv9s|3_?s01>+-LxY*nDt'*WtּM@򯴗C_`?V^xw݁Řm$P:!yM証Jv	zgBВ큦im?	iIyg]%Γ7 3g"ax|#B~k?	cn\0(ZU:C<$ͨ>{r2&Iv\>":*劄vf?hEA5d'!1}66"b_KTIV$!%
g.Nmy-3.[U!%ʩܓ$Zz'}9`f}*Ri<L:$N ־~I\wS[I$".iX{3Qs!Ro_
a`MԞAT&]Bru'=ÊSuqeuiK k[kW
qDfh+`&|%#q=Q*b4iO{{Ec(~:9ERƛ6Ђ9O{rmmMOBEZ>K#Wu$Ni 2nَ7 ?Ө4h	ƅG,Crț|0lKBve%&$!; Ww<#v4	` `L]vJ,5zc`;~DsHkR)t0_pmfAsIf)ʕlQЫZx3$>tbN~VNk'Z\\5
kVBEJɊ72	Wٶ.Vf :#x,Nֿ2YG7PߘEpߤkL[,t2赵N~mGT`EWڪig_-a夓$i˴׾ҦZjٛ@;Q˪vEPzM;OD{AW/Za$w3_HaڡV,
BgGMN "Zhr*dUTޢnTiĥ>gBD wf/-A! _!rʤuW[,LCq"t+wЄح
[| bROwȗ\vkCoMW築l=1mPDzF#HF8{@(zzL'~e42yY?Bwmˢy	X>u8!v>:Q-|՟S3_E*	?JZc14W7*y*/Iˌ7"&3lXw0,8	7_-Cr5)RuM2U8rq~FߐΚ%ufǀ͑7&E}`ۃxq,e]Bߡ<ߔBSH鉰4׮#e6w&&6lm+[$Yh _H- R:i'MB[*as:]EQ'quSgwx3&4;=ȋQz^P1:q
 q{]f]P7$@cF71ȶN{+)̞3ZzSڵt@/(BTB7:)ձ(W|ïR!ITTgay|*1ݡxT,f
rTVc*'lKB]C(>FByD:1B-(dy=!AT*6'E}cnH#v{s
Bj`{}C6wʗj;C){#RL9GϧR Om]=38:k3	6aOzI4<?ZiH?IJv)*>>CB&CP9cp|Uf
|BS!1Y:O$3<?+tM*(݆?|V0L!|O>BӶ liCi$>k-\rڍ,A?n1&́>B	03EU0|VmtcNH	*LBo)t[!
-Ss\1hl⏯w
Y(41<5DMo{%+ߖF\qb0oN-+K΢V%uiq]IޔH(fbdoꜗFU 	%&T}{ @1q["&>״^aS:
Z}z7/Bpv
M bvχѡS|k顆zn,sY 0/߮-^**nrmQkH$%i^Ly
?or=?ldXJ,Մ0٫d$yZQ lLzRkNg	Q,j("ȷ1mj|v`|A2vk=JKw8Td4z[>mڬDVnrTtBP`Go? [W<⏥HOn!e)D(z
;'鿏0r;,F!+MD8Cj\V䪖*VE:Cb7!:wÀ+ɾ.ws'mƶ2o!j~-!jl4PJߦ旂װ
gUDfGTYƯH|
ޒTrבIJ]phG(W0(p"yPN+^a.zQobF>'j<F$$1qV?uDe@̲QZA}/{%^ ec=<yϗX!^HP.8WD!{t/3?û
"ڌ lѯ<9!p2нe "փ5z{wL~glnMPԀ90"Ei*8Bdx-)U>%muv5aHvߨDvjvfm a+FtJCoLdA-CiA[N :I1O9]{PrU)mL< bqLUs9Gqۘ5hoYaҪ7VOx*{{N~TˀnºLukL/3:qp8;uF/فig|ؑG,}ai=*B-Y$y3,IӿۦܓޕĨ<ӵLQ	ゾoY		+Uf!O4뱇>AW[j7v'UWKwl-ƎFv&8,=Pֳׄ:;TJmRoMj'!Lm˯\9_tX*t9*pLtʨ}Ƅ'R+҉fXt0(liZCtCYR[F	y
ѦVW~ÚYwYnPFу^X(0a79} mvSMN$^_1(4DzJJlcڕ}ᰉ	Æ0An92KE˺>4l)_jb2+gKP&ih[.Ha\-;6&<xZ2D#Bu7i#lcz}]0LWJh>3g6YyzWV%~k(HI_62/Y^!ڦ̲[X|rlP9UDj#qBք 3 T|<p7㪼/~'?6X.Ej>i>4]M땅Ocis:j,t 2A*ޓf]׎vK3>21irԸbN/s8yX~ah8t!}I&2^Lj%nމTNGEԛ@s:6RbAe܎D+i!e['ZB/t=G{qb]ґбwU[ǑҐMEkW{y	Mlk,O-ajZZyOjrOQ?8/5׶0ґO	;`	*pY*mNvTҞp%L˻^'̗<	mߜ(]e`D:+7![麞>*X7~^r?hΘ~VR\q6Ty~q9C*8ԧQ,DX
3
GX7gL+FRkuȶ	7+W|>oD{  R	i[6r("` #7gNkq퓴/f mLRC
ohhwb`m(%ᇓ3l{b#YE0vۃڏȄQVڅn߭MeQG5sw6ޗғ̲ϳA+.+N( 퀇++p+:f(U9F}݂vn z~mo0גPTݔF-ҲIE9L{%ԧZL{X:=Wy~mbhrje\`wȧTx']T"ǖFy#ݬA*5
0В"xw=Ρ=ߊV}=_}Y8o$33pr#!l=iŸCƭ=j*[-W*	(. 7_ώr	:oWd#W=S-GΉ(j;r9cޱA.D^f (should_resched(0)) {
		preempt_schedule_common();
		return 1;
	}
	/*
	 * In preemptible kernels, ->rcu_read_lock_nesting tells the tick
	 * whether the current CPU is in an RCU read-side critical section,
	 * so the tick can report quiescent states even for CPUs looping
	 * in kernel context.  In contrast, in non-preemptible kernels,
	 * RCU readers leave no in-memory hints, which means that CPU-bound
	 * processes executing in kernel context might never report an
	 * RCU quiescent state.  Therefore, the following code causes
	 * cond_resched() to report a quiescent state, but only when RCU
	 * is in urgent need of one.
	 */
#ifndef CONFIG_PREEMPT_RCU
	rcu_all_qs();
#endif
	return 0;
}
EXPORT_SYMBOL(__cond_resched);
#endif

#ifdef CONFIG_PREEMPT_DYNAMIC
#if defined(CONFIG_HAVE_PREEMPT_DYNAMIC_CALL)
#define cond_resched_dynamic_enabled	__cond_resched
#define cond_resched_dynamic_disabled	((void *)&__static_call_return0)
DEFINE_STATIC_CALL_RET0(cond_resched, __cond_resched);
EXPORT_STATIC_CALL_TRAMP(cond_resched);

#define might_resched_dynamic_enabled	__cond_resched
#define might_resched_dynamic_disabled	((void *)&__static_call_return0)
DEFINE_STATIC_CALL_RET0(might_resched, __cond_resched);
EXPORT_STATIC_CALL_TRAMP(might_resched);
#elif defined(CONFIG_HAVE_PREEMPT_DYNAMIC_KEY)
static DEFINE_STATIC_KEY_FALSE(sk_dynamic_cond_resched);
int __sched dynamic_cond_resched(void)
{
	if (!static_branch_unlikely(&sk_dynamic_cond_resched))
		return 0;
	return __cond_resched();
}
EXPORT_SYMBOL(dynamic_cond_resched);

static DEFINE_STATIC_KEY_FALSE(sk_dynamic_might_resched);
int __sched dynamic_might_resched(void)
{
	if (!static_branch_unlikely(&sk_dynamic_might_resched))
		return 0;
	return __cond_resched();
}
EXPORT_SYMBOL(dynamic_might_resched);
#endif
#endif

/*
 * __cond_resched_lock() - if a reschedule is pending, drop the given lock,
 * call schedule, and on return reacquire the lock.
 *
 * This works OK both with and without CONFIG_PREEMPTION. We do strange low-level
 * operations here to prevent schedule() from being called twice (once via
 * spin_unlock(), once by hand).
 */
int __cond_resched_lock(spinlock_t *lock)
{
	int resched = should_resched(PREEMPT_LOCK_OFFSET);
	int ret = 0;

	lockdep_assert_held(lock);

	if (spin_needbreak(lock) || resched) {
		spin_unlock(lock);
		if (!_cond_resched())
			cpu_relax();
		ret = 1;
		spin_lock(lock);
	}
	return ret;
}
EXPORT_SYMBOL(__cond_resched_lock);

int __cond_resched_rwlock_read(rwlock_t *lock)
{
	int resched = should_resched(PREEMPT_LOCK_OFFSET);
	int ret = 0;

	lockdep_assert_held_read(lock);

	if (rwlock_needbreak(lock) || resched) {
		read_unlock(lock);
		if (!_cond_resched())
			cpu_relax();
		ret = 1;
		read_lock(lock);
	}
	return ret;
}
EXPORT_SYMBOL(__cond_resched_rwlock_read);

int __cond_resched_rwlock_write(rwlock_t *lock)
{
	int resched = should_resched(PREEMPT_LOCK_OFFSET);
	int ret = 0;

	lockdep_assert_held_write(lock);

	if (rwlock_needbreak(lock) || resched) {
		write_unlock(lock);
		if (!_cond_resched())
			cpu_relax();
		ret = 1;
		write_lock(lock);
	}
	return ret;
}
EXPORT_SYMBOL(__cond_resched_rwlock_write);

#ifdef CONFIG_PREEMPT_DYNAMIC

#ifdef CONFIG_GENERIC_ENTRY
#include <linux/entry-common.h>
#endif

/*
 * SC:cond_resched
 * SC:might_resched
 * SC:preempt_schedule
 * SC:preempt_schedule_notrace
 * SC:irqentry_exit_cond_resched
 *
 *
 * NONE:
 *   cond_resched               <- __cond_resched
 *   might_resched              <- RET0
 *   preempt_schedule           <- NOP
 *   preempt_schedule_notrace   <- NOP
 *   irqentry_exit_cond_resched <- NOP
 *
 * VOLUNTARY:
 *   cond_resched               <- __cond_resched
 *   might_resched              <- __cond_resched
 *   preempt_schedule           <- NOP
 *   preempt_schedule_notrace   <- NOP
 *   irqentry_exit_cond_resched <- NOP
 *
 * FULL:
 *   cond_resched               <- RET0
 *   might_resched              <- RET0
 *   preempt_schedule           <- preempt_schedule
 *   preempt_schedule_notrace   <- preempt_schedule_notrace
 *   irqentry_exit_cond_resched <- irqentry_exit_cond_resched
 */

enum {
	preempt_dynamic_undefined = -1,
	preempt_dynamic_none,
	preempt_dynamic_voluntary,
	preempt_dynamic_full,
};

int preempt_dynamic_mode = preempt_dynamic_undefined;

int sched_dynamic_mode(const char *str)
{
	if (!strcmp(str, "none"))
		return preempt_dynamic_none;

	if (!strcmp(str, "voluntary"))
		return preempt_dynamic_voluntary;

	if (!strcmp(str, "full"))
		return preempt_dynamic_full;

	return -EINVAL;
}

#if defined(CONFIG_HAVE_PREEMPT_DYNAMIC_CALL)
#define preempt_dynamic_enable(f)	static_call_update(f, f##_dynamic_enabled)
#define preempt_dynamic_disable(f)	static_call_update(f, f##_dynamic_disabled)
#elif defined(CONFIG_HAVE_PREEMPT_DYNAMIC_KEY)
#define preempt_dynamic_enable(f)	static_key_enable(&sk_dynamic_##f.key)
#define preempt_dynamic_disable(f)	static_key_disable(&sk_dynamic_##f.key)
#else
#error "Unsupported PREEMPT_DYNAMIC mechanism"
#endif

void sched_dynamic_update(int mode)
{
	/*
	 * Avoid {NONE,VOLUNTARY} -> FULL transitions from ever ending up in
	 * the ZERO state, which is invalid.
	 */
	preempt_dynamic_enable(cond_resched);
	preempt_dynamic_enable(might_resched);
	preempt_dynamic_enable(preempt_schedule);
	preempt_dynamic_enable(preempt_schedule_notrace);
	preempt_dynamic_enable(irqentry_exit_cond_resched);

	switch (mode) {
	case preempt_dynamic_none:
		preempt_dynamic_enable(cond_resched);
		preempt_dynamic_disable(might_resched);
		preempt_dynamic_disable(preempt_schedule);
		preempt_dynamic_disable(preempt_schedule_notrace);
		preempt_dynamic_disable(irqentry_exit_cond_resched);
		pr_info("Dynamic Preempt: none\n");
		break;

	case preempt_dynamic_voluntary:
		preempt_dynamic_enable(cond_resched);
		preempt_dynamic_enable(might_resched);
		preempt_dynamic_disable(preempt_schedule);
		preempt_dynamic_disable(preempt_schedule_notrace);
		preempt_dynamic_disable(irqentry_exit_cond_resched);
		pr_info("Dynamic Preempt: voluntary\n");
		break;

	case preempt_dynamic_full:
		preempt_dynamic_disable(cond_resched);
		preempt_dynamic_disable(might_resched);
		preempt_dynamic_enable(preempt_schedule);
		preempt_dynamic_enable(preempt_schedule_notrace);
		preempt_dynamic_enable(irqentry_exit_cond_resched);
		pr_info("Dynamic Preempt: full\n");
		break;
	}

	preempt_dynamic_mode = mode;
}

static int __init setup_preempt_mode(char *str)
{
	int mode = sched_dynamic_mode(str);
	if (mode < 0) {
		pr_warn("Dynamic Preempt: unsupported mode: %s\n", str);
		return 0;
	}

	sched_dynamic_update(mode);
	return 1;
}
__setup("preempt=", setup_preempt_mode);

static void __init preempt_dynamic_init(void)
{
	if (preempt_dynamic_mode == preempt_dynamic_undefined) {
		if (IS_ENABLED(CONFIG_PREEMPT_NONE)) {
			sched_dynamic_update(preempt_dynamic_none);
		} else if (IS_ENABLED(CONFIG_PREEMPT_VOLUNTARY)) {
			sched_dynamic_update(preempt_dynamic_voluntary);
		} else {
			/* Default static call setting, nothing to do */
			WARN_ON_ONCE(!IS_ENABLED(CONFIG_PREEMPT));
			preempt_dynamic_mode = preempt_dynamic_full;
			pr_info("Dynamic Preempt: full\n");
		}
	}
}

#else /* !CONFIG_PREEMPT_DYNAMIC */

static inline void preempt_dynamic_init(void) { }

#endif /* #ifdef CONFIG_PREEMPT_DYNAMIC */

/**
 * yield - yield the current processor to other threads.
 *
 * Do not ever use this function, there's a 99% chance you're doing it wrong.
 *
 * The scheduler is at all times free to pick the calling task as the most
 * eligible task to run, if removing the yield() call from your code breaks
 * it, it's already broken.
 *
 * Typical broken usage is:
 *
 * while (!event)
 *	yield();
 *
 * where one assumes that yield() will let 'the other' process run that will
 * make event true. If the current task is a SCHED_FIFO task that will never
 * happen. Never use yield() as a progress guarantee!!
 *
 * If you want to use yield() to wait for something, use wait_event().
 * If you want to use yield() to be 'nice' for others, use cond_resched().
 * If you still want to use yield(), do not!
 */
void __sched yield(void)
{
	set_current_state(TASK_RUNNING);
	do_sched_yield();
}
EXPORT_SYMBOL(yield);

/**
 * yield_to - yield the current processor to another thread in
 * your thread group, or accelerate that thread toward the
 * processor it's on.
 * @p: target task
 * @preempt: whether task preemption is allowed or not
 *
 * It's the caller's job to ensure that the target task struct
 * can't go away on us before we can do any checks.
 *
 * Return:
 *	true (>0) if we indeed boosted the target task.
 *	false (0) if we failed to boost the target.
 *	-ESRCH if there's no task to yield to.
 */
int __sched yield_to(struct task_struct *p, bool preempt)
{
	struct task_struct *curr = current;
	struct rq *rq, *p_rq;
	unsigned long flags;
	int yielded = 0;

	local_irq_save(flags);
	rq = this_rq();

again:
	p_rq = task_rq(p);
	/*
	 * If we're the only runnable task on the rq and target rq also
	 * has only one task, there's absolutely no point in yielding.
	 */
	if (rq->nr_running == 1 && p_rq->nr_running == 1) {
		yielded = -ESRCH;
		goto out_irq;
	}

	double_rq_lock(rq, p_rq);
	if (task_rq(p) != p_rq) {
		double_rq_unlock(rq, p_rq);
		goto again;
	}

	if (!curr->sched_class->yield_to_task)
		goto out_unlock;

	if (curr->sched_class != p->sched_class)
		goto out_unlock;

	if (task_running(p_rq, p) || !task_is_running(p))
		goto out_unlock;

	yielded = curr->sched_class->yield_to_task(rq, p);
	if (yielded) {
		schedstat_inc(rq->yld_count);
		/*
		 * Make p's CPU reschedule; pick_next_entity takes care of
		 * fairness.
		 */
		if (preempt && rq != p_rq)
			resched_curr(p_rq);
	}

out_unlock:
	double_rq_unlock(rq, p_rq);
out_irq:
	local_irq_restore(flags);

	if (yielded > 0)
		schedule();

	return yielded;
}
EXPORT_SYMBOL_GPL(yield_to);

int io_schedule_prepare(void)
{
	int old_iowait = current->in_iowait;

	current->in_iowait = 1;
	blk_flush_plug(current->plug, true);
	return old_iowait;
}

void io_schedule_finish(int token)
{
	current->in_iowait = token;
}

/*
 * This task is about to go to sleep on IO. Increment rq->nr_iowait so
 * that process accounting knows that this is a task in IO wait state.
 */
long __sched io_schedule_timeout(long timeout)
{
	int token;
	long ret;

	token = io_schedule_prepare();
	ret = schedule_timeout(timeout);
	io_schedule_finish(token);

	return ret;
}
EXPORT_SYMBOL(io_schedule_timeout);

void __sched io_schedule(void)
{
	int token;

	token = io_schedule_prepare();
	schedule();
	io_schedule_finish(token);
}
EXPORT_SYMBOL(io_schedule);

/**
 * sys_sched_get_priority_max - return maximum RT priority.
 * @policy: scheduling class.
 *
 * Return: On success, this syscall returns the maximum
 * rt_priority that can be used by a given scheduling class.
 * On failure, a negative error code is returned.
 */
SYSCALL_DEFINE1(sched_get_priority_max, int, policy)
{
	int ret = -EINVAL;

	switch (policy) {
	case SCHED_FIFO:
	case SCHED_RR:
		ret = MAX_RT_PRIO-1;
		break;
	case SCHED_DEADLINE:
	case SCHED_NORMAL:
	case SCHED_BATCH:
	case SCHED_IDLE:
		ret = 0;
		break;
	}
	return ret;
}

/**
 * sys_sched_get_priority_min - return minimum RT priority.
 * @policy: scheduling class.
 *
 * Return: On success, this syscall returns the minimum
 * rt_priority that can be used by a given scheduling class.
 * On failure, a negative error code is returned.
 */
SYSCALL_DEFINE1(sched_get_priority_min, int, policy)
{
	int ret = -EINVAL;

	switch (policy) {
	case SCHED_FIFO:
	case SCHED_RR:
		ret = 1;
		break;
	case SCHED_DEADLINE:
	case SCHED_NORMAL:
	case SCHED_BATCH:
	case SCHED_IDLE:
		ret = 0;
	}
	return ret;
}

static int sched_rr_get_interval(pid_t pid, struct timespec64 *t)
{
	struct task_struct *p;
	unsigned int time_slice;
	struct rq_flags rf;
	struct rq *rq;
	int retval;

	if (pid < 0)
		return -EINVAL;

	retval = -ESRCH;
	rcu_read_lock();
	p = find_process_by_pid(pid);
	if (!p)
		goto out_unlock;

	retval = security_task_getscheduler(p);
	if (retval)
		goto out_unlock;

	rq = task_rq_lock(p, &rf);
	time_slice = 0;
	if (p->sched_class->get_rr_interval)
		time_slice = p->sched_class->get_rr_interval(rq, p);
	task_rq_unlock(rq, p, &rf);

	rcu_read_unlock();
	jiffies_to_timespec64(time_slice, t);
	return 0;

out_unlock:
	rcu_read_unlock();
	return retval;
}

/**
 * sys_sched_rr_get_interval - return the default timeslice of a process.
 * @pid: pid of the process.
 * @interval: userspace pointer to the timeslice value.
 *
 * this syscall writes the default timeslice value of a given process
 * into the user-space timespec buffer. A value of '0' means infinity.
 *
 * Return: On success, 0 and the timeslice is in @interval. Otherwise,
 * an error code.
 */
SYSCALL_DEFINE2(sched_rr_get_interval, pid_t, pid,
		struct __kernel_timespec __user *, interval)
{
	struct timespec64 t;
	int retval = sched_rr_get_interval(pid, &t);

	if (retval == 0)
		retval = put_timespec64(&t, interval);

	return retval;
}

#ifdef CONFIG_COMPAT_32BIT_TIME
SYSCALL_DEFINE2(sched_rr_get_interval_time32, pid_t, pid,
		struct old_timespec32 __user *, interval)
{
	struct timespec64 t;
	int retval = sched_rr_get_interval(pid, &t);

	if (retval == 0)
		retval = put_old_timespec32(&t, interval);
	return retval;
}
#endif

void sched_show_task(struct task_struct *p)
{
	unsigned long free = 0;
	int ppid;

	if (!try_get_task_stack(p))
		return;

	pr_info("task:%-15.15s state:%c", p->comm, task_state_to_char(p));

	if (task_is_running(p))
		pr_cont("  running task    ");
#ifdef CONFIG_DEBUG_STACK_USAGE
	free = stack_not_used(p);
#endif
	ppid = 0;
	rcu_read_lock();
	if (pid_alive(p))
		ppid = task_pid_nr(rcu_dereference(p->real_parent));
	rcu_read_unlock();
	pr_cont(" stack:%5lu pid:%5d ppid:%6d flags:0x%08lx\n",
		free, task_pid_nr(p), ppid,
		read_task_thread_flags(p));

	print_worker_info(KERN_INFO, p);
	print_stop_info(KERN_INFO, p);
	show_stack(p, NULL, KERN_INFO);
	put_task_stack(p);
}
EXPORT_SYMBOL_GPL(sched_show_task);

static inline bool
state_filter_match(unsigned long state_filter, struct task_struct *p)
{
	unsigned int state = READ_ONCE(p->__state);

	/* no filter, everything matches */
	if (!state_filter)
		return true;

	/* filter, but doesn't match */
	if (!(state & state_filter))
		return false;

	/*
	 * When looking for TASK_UNINTERRUPTIBLE skip TASK_IDLE (allows
	 * TASK_KILLABLE).
	 */
	if (state_filter == TASK_UNINTERRUPTIBLE && state == TASK_IDLE)
		return false;

	return true;
}


void show_state_filter(unsigned int state_filter)
{
	struct task_struct *g, *p;

	rcu_read_lock();
	for_each_process_thread(g, p) {
		/*
		 * reset the NMI-timeout, listing all files on a slow
		 * console might take a lot of time:
		 * Also, reset softlockup watchdogs on all CPUs, because
		 * another CPU might be blocked waiting for us to process
		 * an IPI.
		 */
		touch_nmi_watchdog();
		touch_all_softlockup_watchdogs();
		if (state_filter_match(state_filter, p))
			sched_show_task(p);
	}

#ifdef CONFIG_SCHED_DEBUG
	if (!state_filter)
		sysrq_sched_debug_show();
#endif
	rcu_read_unlock();
	/*
	 * Only show locks if all tasks are dumped:
	 */
	if (!state_filter)
		debug_show_all_locks();
}

/**
 * init_idle - set up an idle thread for a given CPU
 * @idle: task in question
 * @cpu: CPU the idle task belongs to
 *
 * NOTE: this function does not set the idle thread's NEED_RESCHED
 * flag, to make booting more robust.
 */
void __init init_idle(struct task_struct *idle, int cpu)
{
	struct rq *rq = cpu_rq(cpu);
	unsigned long flags;

	__sched_fork(0, idle);

	raw_spin_lock_irqsave(&idle->pi_lock, flags);
	raw_spin_rq_lock(rq);

	idle->__state = TASK_RUNNING;
	idle->se.exec_start = sched_clock();
	/*
	 * PF_KTHREAD should already be set at this point; regardless, make it
	 * look like a proper per-CPU kthread.
	 */
	idle->flags |= PF_IDLE | PF_KTHREAD | PF_NO_SETAFFINITY;
	kthread_set_per_cpu(idle, cpu);

#ifdef CONFIG_SMP
	/*
	 * It's possible that init_idle() gets called multiple times on a task,
	 * in that case do_set_cpus_allowed() will not do the right thing.
	 *
	 * And since this is boot we can forgo the serialization.
	 */
	set_cpus_allowed_common(idle, cpumask_of(cpu), 0);
#endif
	/*
	 * We're having a chicken and egg problem, even though we are
	 * holding rq->lock, the CPU isn't yet set to this CPU so the
	 * lockdep check in task_group() will fail.
	 *
	 * Similar case to sched_fork(). / Alternatively we could
	 * use task_rq_lock() here and obtain the other rq->lock.
	 *
	 * Silence PROVE_RCU
	 */
	rcu_read_lock();
	__set_task_cpu(idle, cpu);
	rcu_read_unlock();

	rq->idle = idle;
	rcu_assign_pointer(rq->curr, idle);
	idle->on_rq = TASK_ON_RQ_QUEUED;
#ifdef CONFIG_SMP
	idle->on_cpu = 1;
#endif
	raw_spin_rq_unlock(rq);
	raw_spin_unlock_irqrestore(&idle->pi_lock, flags);

	/* Set the preempt count _outside_ the spinlocks! */
	init_idle_preempt_count(idle, cpu);

	/*
	 * The idle tasks have their own, simple scheduling class:
	 */
	idle->sched_class = &idle_sched_class;
	ftrace_graph_init_idle_task(idle, cpu);
	vtime_init_idle(idle, cpu);
#ifdef CONFIG_SMP
	sprintf(idle->comm, "%s/%d", INIT_TASK_COMM, cpu);
#endif
}

#ifdef CONFIG_SMP

int cpuset_cpumask_can_shrink(const struct cpumask *cur,
			      const struct cpumask *trial)
{
	int ret = 1;

	if (cpumask_empty(cur))
		return ret;

	ret = dl_cpuset_cpumask_can_shrink(cur, trial);

	return ret;
}

int task_can_attach(struct task_struct *p,
		    const struct cpumask *cs_cpus_allowed)
{
	int ret = 0;

	/*
	 * Kthreads which disallow setaffinity shouldn't be moved
	 * to a new cpuset; we don't want to change their CPU
	 * affinity and isolating such threads by their set of
	 * allowed nodes is unnecessary.  Thus, cpusets are not
	 * applicable for such threads.  This prevents checking for
	 * success of set_cpus_allowed_ptr() on all attached tasks
	 * before cpus_mask may be changed.
	 */
	if (p->flags & PF_NO_SETAFFINITY) {
		ret = -EINVAL;
		goto out;
	}

	if (dl_task(p) && !cpumask_intersects(task_rq(p)->rd->span,
					      cs_cpus_allowed)) {
		int cpu = cpumask_any_and(cpu_active_mask, cs_cpus_allowed);

		ret = dl_cpu_busy(cpu, p);
	}

out:
	return ret;
}

bool sched_smp_initialized __read_mostly;

#ifdef CONFIG_NUMA_BALANCING
/* Migrate current task p to target_cpu */
int migrate_task_to(struct task_struct *p, int target_cpu)
{
	struct migration_arg arg = { p, target_cpu };
	int curr_cpu = task_cpu(p);

	if (curr_cpu == target_cpu)
		return 0;

	if (!cpumask_test_cpu(target_cpu, p->cpus_ptr))
		return -EINVAL;

	/* TODO: This is not properly updating schedstats */

	trace_sched_move_numa(p, curr_cpu, target_cpu);
	return stop_one_cpu(curr_cpu, migration_cpu_stop, &arg);
}

/*
 * Requeue a task on a given node and accurately track the number of NUMA
 * tasks on the runqueues
 */
void sched_setnuma(struct task_struct *p, int nid)
{
	bool queued, running;
	struct rq_flags rf;
	struct rq *rq;

	rq = task_rq_lock(p, &rf);
	queued = task_on_rq_queued(p);
	running = task_current(rq, p);

	if (queued)
		dequeue_task(rq, p, DEQUEUE_SAVE);
	if (running)
		put_prev_task(rq, p);

	p->numa_preferred_nid = nid;

	if (queued)
		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);
	if (running)
		set_next_task(rq, p);
	task_rq_unlock(rq, p, &rf);
}
#endif /* CONFIG_NUMA_BALANCING */

#ifdef CONFIG_HOTPLUG_CPU
/*
 * Ensure that the idle task is using init_mm right before its CPU goes
 * offline.
 */
void idle_task_exit(void)
{
	struct mm_struct *mm = current->active_mm;

	BUG_ON(cpu_online(smp_processor_id()));
	BUG_ON(current != this_rq()->idle);

	if (mm != &init_mm) {
		switch_mm(mm, &init_mm, current);
		finish_arch_post_lock_switch();
	}

	/* finish_cpu(), as ran on the BP, will clean up the active_mm state */
}

static int __balance_push_cpu_stop(void *arg)
{
	struct task_struct *p = arg;
	struct rq *rq = this_rq();
	struct rq_flags rf;
	int cpu;

	raw_spin_lock_irq(&p->pi_lock);
	rq_lock(rq, &rf);

	update_rq_clock(rq);

	if (task_rq(p) == rq && task_on_rq_queued(p)) {
		cpu = select_fallback_rq(rq->cpu, p);
		rq = __migrate_task(rq, &rf, p, cpu);
	}

	rq_unlock(rq, &rf);
	raw_spin_unlock_irq(&p->pi_lock);

	put_task_struct(p);

	return 0;
}

static DEFINE_PER_CPU(struct cpu_stop_work, push_work);

/*
 * Ensure we only run per-cpu kthreads once the CPU goes !active.
 *
 * This is enabled below SCHED_AP_ACTIVE; when !cpu_active(), but only
 * effective when the hotplug motion is down.
 */
static void balance_push(struct rq *rq)
{
	struct task_struct *push_task = rq->curr;

	lockdep_assert_rq_held(rq);

	/*
	 * Ensure the thing is persistent until balance_push_set(.on = false);
	 */
	rq->balance_callback = &balance_push_callback;

	/*
	 * Only active while going offline and when invoked on the outgoing
	 * CPU.
	 */
	if (!cpu_dying(rq->cpu) || rq != this_rq())
		return;

	/*
	 * Both the cpu-hotplug and stop task are in this case and are
	 * required to complete the hotplug process.
	 */
	if (kthread_is_per_cpu(push_task) ||
	    is_migration_disabled(push_task)) {

		/*
		 * If this is the idle task on the outgoing CPU try to wake
		 * up the hotplug control thread which might wait for the
		 * last task to vanish. The rcuwait_active() check is
		 * accurate here because the waiter is pinned on this CPU
		 * and can't obviously be running in parallel.
		 *
		 * On RT kernels this also has to check whether there are
		 * pinned and scheduled out tasks on the runqueue. They
		 * need to leave the migrate disabled section first.
		 */
		if (!rq->nr_running && !rq_has_pinned_tasks(rq) &&
		    rcuwait_active(&rq->hotplug_wait)) {
			raw_spin_rq_unlock(rq);
			rcuwait_wake_up(&rq->hotplug_wait);
			raw_spin_rq_lock(rq);
		}
		return;
	}

	get_task_struct(push_task);
	/*
	 * Temporarily drop rq->lock such that we can wake-up the stop task.
	 * Both preemption and IRQs are still disabled.
	 */
	raw_spin_rq_unlock(rq);
	stop_one_cpu_nowait(rq->cpu, __balance_push_cpu_stop, push_task,
			    this_cpu_ptr(&push_work));
	/*
	 * At this point need_resched() is true and we'll take the loop in
	 * schedule(). The next pick is obviously going to be the stop task
	 * which kthread_is_per_cpu() and will push this task away.
	 */
	raw_spin_rq_lock(rq);
}

static void balance_push_set(int cpu, bool on)
{
	struct rq *rq = cpu_rq(cpu);
	struct rq_flags rf;

	rq_lock_irqsave(rq, &rf);
	if (on) {
		WARN_ON_ONCE(rq->balance_callback);
		rq->balance_callback = &balance_push_callback;
	} else if (rq->balance_callback == &balance_push_callback) {
		rq->balance_callback = NULL;
	}
	rq_unlock_irqrestore(rq, &rf);
}

/*
 * Invoked from a CPUs hotplug control thread after the CPU has been marked
 * inactive. All tasks which are not per CPU kernel threads are either
 * pushed off this CPU now via balance_push() or placed on a different CPU
 * during wakeup. Wait until the CPU is quiescent.
 */
static void balance_hotplug_wait(void)
{
	struct rq *rq = this_rq();

	rcuwait_wait_event(&rq->hotplug_wait,
			   rq->nr_running == 1 && !rq_has_pinned_tasks(rq),
			   TASK_UNINTERRUPTIBLE);
}

#else

static inline void balance_push(struct rq *rq)
{
}

static inline void balance_push_set(int cpu, bool on)
{
}

static inline void balance_hotplug_wait(void)
{
}

#endif /* CONFIG_HOTPLUG_CPU */

void set_rq_online(struct rq *rq)
{
	if (!rq->online) {
		const struct sched_class *class;

		cpumask_set_cpu(rq->cpu, rq->rd->online);
		rq->online = 1;

		for_each_class(class) {
			if (class->rq_online)
				class->rq_online(rq);
		}
	}
}

void set_rq_offline(struct rq *rq)
{
	if (rq->online) {
		const struct sched_class *class;

		for_each_class(class) {
			if (class->rq_offline)
				class->rq_offline(rq);
		}

		cpumask_clear_cpu(rq->cpu, rq->rd->online);
		rq->online = 0;
	}
}

/*
 * used to mark begin/end of suspend/resume:
 */
static int num_cpus_frozen;

/*
 * Update cpusets according to cpu_active mask.  If cpusets are
 * disabled, cpuset_update_active_cpus() becomes a simple wrapper
 * around partition_sched_domains().
 *
 * If we come here as part of a suspend/resume, don't touch cpusets because we
 * want to restore it back to its original state upon resume anyway.
 */
static void cpuset_cpu_active(void)
{
	if (cpuhp_tasks_frozen) {
		/*
		 * num_cpus_frozen tracks how many CPUs are involved in suspend
		 * resume sequence. As long as this is not the last online
		 * operation in the resume sequence, just build a single sched
		 * domain, ignoring cpusets.
		 */
		partition_sched_domains(1, NULL, NULL);
		if (--num_cpus_frozen)
			return;
		/*
		 * This is the last CPU online operation. So fall through and
		 * restore the original sched domains by considering the
		 * cpuset configurations.
		 */
		cpuset_force_rebuild();
	}
	cpuset_update_active_cpus();
}

static int cpuset_cpu_inactive(unsigned int cpu)
{
	if (!cpuhp_tasks_frozen) {
		int ret = dl_cpu_busy(cpu, NULL);

		if (ret)
			return ret;
		cpuset_update_active_cpus();
	} else {
		num_cpus_frozen++;
		partition_sched_domains(1, NULL, NULL);
	}
	return 0;
}

int sched_cpu_activate(unsigned int cpu)
{
	struct rq *rq = cpu_rq(cpu);
	struct rq_flags rf;

	/*
	 * Clear the balance_push callback and prepare to schedule
	 * regular tasks.
	 */
	balance_push_set(cpu, false);

#ifdef CONFIG_SCHED_SMT
	/*
	 * When going up, increment the number of cores with SMT present.
	 */
	if (cpumask_weight(cpu_smt_mask(cpu)) == 2)
		static_branch_inc_cpuslocked(&sched_smt_present);
#endif
	set_cpu_active(cpu, true);

	if (sched_smp_initialized) {
		sched_update_numa(cpu, true);
		sched_domains_numa_masks_set(cpu);
		cpuset_cpu_active();
	}

	/*
	 * Put the rq online, if not already. This happens:
	 *
	 * 1) In the early boot process, because we build the real domains
	 *    after all CPUs have been brought up.
	 *
	 * 2) At runtime, if cpuset_cpu_active() fails to rebuild the
	 *    domains.
	 */
	rq_lock_irqsave(rq, &rf);
	if (rq->rd) {
		BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));
		set_rq_online(rq);
	}
	rq_unlock_irqrestore(rq, &rf);

	return 0;
}

int sched_cpu_deactivate(unsigned int cpu)
{
	struct rq *rq = cpu_rq(cpu);
	struct rq_flags rf;
	int ret;

	/*
	 * Remove CPU from nohz.idle_cpus_mask to prevent participating in
	 * load balancing when not active
	 */
	nohz_balance_exit_idle(rq);

	set_cpu_active(cpu, false);

	/*
	 * From this point forward, this CPU will refuse to run any task that
	 * is not: migrate_disable() or KTHREAD_IS_PER_CPU, and will actively
	 * push those tasks away until this gets cleared, see
	 * sched_cpu_dying().
	 */
	balance_push_set(cpu, true);

	/*
	 * We've cleared cpu_active_mask / set balance_push, wait for all
	 * preempt-disabled and RCU users of this state to go away such that
	 * all new such users will observe it.
	 *
	 * Specifically, we rely on ttwu to no longer target this CPU, see
	 * ttwu_queue_cond() and is_cpu_allowed().
	 *
	 * Do sync before park smpboot threads to take care the rcu boost case.
	 */
	synchronize_rcu();

	rq_lock_irqsave(rq, &rf);
	if (rq->rd) {
		update_rq_clock(rq);
		BUG_ON(!cpumask_test_cpu(cpu, rq->rd->span));
		set_rq_offline(rq);
	}
	rq_unlock_irqrestore(rq, &rf);

#ifdef CONFIG_SCHED_SMT
	/*
	 * When going down, decrement the number of cores with SMT present.
	 */
	if (cpumask_weight(cpu_smt_mask(cpu)) == 2)
		static_branch_dec_cpuslocked(&sched_smt_present);

	sched_core_cpu_deactivate(cpu);
#endif

	if (!sched_smp_initialized)
		return 0;

	sched_update_numa(cpu, false);
	ret = cpuset_cpu_inactive(cpu);
	if (ret) {
		balance_push_set(cpu, false);
		set_cpu_active(cpu, true);
		sched_update_numa(cpu, true);
		return ret;
	}
	sched_domains_numa_masks_clear(cpu);
	return 0;
}

static void sched_rq_cpu_starting(unsigned int cpu)
{
	struct rq *rq = cpu_rq(cpu);

	rq->calc_load_update = calc_load_update;
	update_max_interval();
}

int sched_cpu_starting(unsigned int cpu)
{
	sched_core_cpu_starting(cpu);
	sched_rq_cpu_starting(cpu);
	sched_tick_start(cpu);
	return 0;
}

#ifdef CONFIG_HOTPLUG_CPU

/*
 * Invoked immediately before the stopper thread is invoked to bring the
 * CPU down completely. At this point all per CPU kthreads except the
 * hotplug thread (current) and the stopper thread (inactive) have been
 * either parked or have been unbound from the outgoing CPU. Ensure that
 * any of those which might be on the way out are gone.
 *
 * If after this point a bound task is being woken on this CPU then the
 * responsible hotplug callback has failed to do it's job.
 * sched_cpu_dying() will catch it with the appropriate fireworks.
 */
int sched_cpu_wait_empty(unsigned int cpu)
{
	balance_hotplug_wait();
	return 0;
}

/*
 * Since this CPU is going 'away' for a while, fold any nr_active delta we
 * might have. Called from the CPU stopper task after ensuring that the
 * stopper is the last running task on the CPU, so nr_active count is
 * stable. We need to take the teardown thread which is calling this into
 * account, so we hand in adjust = 1 to the load calculation.
 *
 * Also see the comment "Global load-average calculations".
 */
static void calc_load_migrate(struct rq *rq)
{
	long delta = calc_load_fold_active(rq, 1);

	if (delta)
		atomic_long_add(delta, &calc_load_tasks);
}

static void dump_rq_tasks(struct rq *rq, const char *loglvl)
{
	struct task_struct *g, *p;
	int cpu = cpu_of(rq);

	lockdep_assert_rq_held(rq);

	printk("%sCPU%d enqueued tasks (%u total):\n", loglvl, cpu, rq->nr_running);
	for_each_process_thread(g, p) {
		if (task_cpu(p) != cpu)
			continue;

		if (!task_on_rq_queued(p))
			continue;

		printk("%s\tpid: %d, name: %s\n", loglvl, p->pid, p->comm);
	}
}

int sched_cpu_dying(unsigned int cpu)
{
	struct rq *rq = cpu_rq(cpu);
	struct rq_flags rf;

	/* Handle pending wakeups and then migrate everything off */
	sched_tick_stop(cpu);

	rq_lock_irqsave(rq, &rf);
	if (rq->nr_running != 1 || rq_has_pinned_tasks(rq)) {
		WARN(true, "Dying CPU not properly vacated!");
		dump_rq_tasks(rq, KERN_WARNING);
	}
	rq_unlock_irqrestore(rq, &rf);

	calc_load_migrate(rq);
	update_max_interval();
	hrtick_clear(rq);
	sched_core_cpu_dying(cpu);
	return 0;
}
#endif

void __init sched_init_smp(void)
{
	sched_init_numa(NUMA_NO_NODE);

	/*
	 * There's no userspace yet to cause hotplug operations; hence all the
	 * CPU masks are stable and all blatant races in the below code cannot
	 * happen.
	 */
	mutex_lock(&sched_domains_mutex);
	sched_init_domains(cpu_active_mask);
	mutex_unlock(&sched_domains_mutex);

	/* Move init over to a non-isolated CPU */
	if (set_cpus_allowed_ptr(current, housekeeping_cpumask(HK_TYPE_DOMAIN)) < 0)
		BUG();
	current->flags &= ~PF_NO_SETAFFINITY;
	sched_init_granularity();

	init_sched_rt_class();
	init_sched_dl_class();

	sched_smp_initialized = true;
}

static int __init migration_init(void)
{
	sched_cpu_starting(smp_processor_id());
	return 0;
}
early_initcall(migration_init);

#else
void __init sched_init_smp(void)
{
	sched_init_granularity();
}
#endif /* CONFIG_SMP */

int in_sched_functions(unsigned long addr)
{
	return in_lock_functions(addr) ||
		(addr >= (unsigned long)__sched_text_start
		&& addr < (unsigned long)__sched_text_end);
}

#ifdef CONFIG_CGROUP_SCHED
/*
 * Default task group.
 * Every task in system belongs to this group at bootup.
 */
struct task_group root_task_group;
LIST_HEAD(task_groups);

/* Cacheline aligned slab cache for task_group */
static struct kmem_cache *task_group_cache __read_mostly;
#endif

DECLARE_PER_CPU(cpumask_var_t, load_balance_mask);
DECLARE_PER_CPU(cpumask_var_t, select_idle_mask);

void __init sched_init(void)
{
	unsigned long ptr = 0;
	int i;

	/* Make sure the linker didn't screw up */
	BUG_ON(&idle_sched_class + 1 != &fair_sched_class ||
	       &fair_sched_class + 1 != &rt_sched_class ||
	       &rt_sched_class + 1   != &dl_sched_class);
#ifdef CONFIG_SMP
	BUG_ON(&dl_sched_class + 1 != &stop_sched_class);
#endif

	wait_bit_init();

#ifdef CONFIG_FAIR_GROUP_SCHED
	ptr += 2 * nr_cpu_ids * sizeof(void **);
#endif
#ifdef CONFIG_RT_GROUP_SCHED
	ptr += 2 * nr_cpu_ids * sizeof(void **);
#endif
	if (ptr) {
		ptr = (unsigned long)kzalloc(ptr, GFP_NOWAIT);

#ifdef CONFIG_FAIR_GROUP_SCHED
		root_task_group.se = (struct sched_entity **)ptr;
		ptr += nr_cpu_ids * sizeof(void **);

		root_task_group.cfs_rq = (struct cfs_rq **)ptr;
		ptr += nr_cpu_ids * sizeof(void **);

		root_task_group.shares = ROOT_TASK_GROUP_LOAD;
		init_cfs_bandwidth(&root_task_group.cfs_bandwidth);
#endif /* CONFIG_FAIR_GROUP_SCHED */
#ifdef CONFIG_RT_GROUP_SCHED
		root_task_group.rt_se = (struct sched_rt_entity **)ptr;
		ptr += nr_cpu_ids * sizeof(void **);

		root_task_group.rt_rq = (struct rt_rq **)ptr;
		ptr += nr_cpu_ids * sizeof(void **);

#endif /* CONFIG_RT_GROUP_SCHED */
	}
#ifdef CONFIG_CPUMASK_OFFSTACK
	for_each_possible_cpu(i) {
		per_cpu(load_balance_mask, i) = (cpumask_var_t)kzalloc_node(
			cpumask_size(),3TqzpDmTIr?Λ;zyrE,f7P$	l"x{Ȱu8K^, ;9rQ8nPpǙp؄~_/S<qJP,'B޻#ݞ2]?h~IL(㭑,o";3,@6kxσĔ.
hlUd#/P	PA#l{=(.Si2*<Z`Tz)-df1r PycGg屬-0??ty<t5!c`Yo9cE/Hrn{(vH@6c'r'^ڻ*lL}џ&#7R
M|y'U;L*Mx"n+Na3-ݻO
/
a
W;n(F^y;ONx1zqԶɃdfn?˚mrN4spk $HY߆<Rnnr\92Sߡ"kX\݄>n6K2ה(R\Q2 iO>2FiC;.{3!(4 c*hJQ^*q(b,"pmp
M<uGIFV&Q&O$9D.Ecϼ4zE&	gָ,[Su^R}J*S_#՛-
cv?트35R΂@3#s0+22)u#;a(qoA{) XN+7kV[ԗA2a!jV+_Y)d2^rlT4vQp_vhYHӲEk=vr!BSL?i@d>L?xmODB/'a)ɧWϧ?w/чR2S	KLXT8|U^FLYOӈĂo5TUǿݺLa# T@#<,A+wyKkߡY5p?T[O7Q~+!% (yHSg41^M:B
FL$Gt<BZn^8U~['5
0Cs_Ub}K}Br+32Ǘp+]-ϵqژErr"MrMk͎
 #&dan4Z#OTk޻G@)bkiYaX&j\ӭ+?Kowl5DKP:dY~Ŭ6Q~_|oK@BT-2x9gEq&Tz	( ,JЂ"5x_QNκ:=ZY,k'"S)H`EJ Ҁ0,D}vHzMD߸QgTfGtY|)*=.lXPхO'Lyi>UR/rzυF%/>m巙&}&	9F*:Aw\kU^M<	y1IT{dN~e>>\6ejgntge^5N峉.+QLC;
O4E1pMulZQ˄V縃d
҃`ETׁY,̂k/sm#ح9Avv=S cPzߜTT>B,b5QmswyWr7?!ʓoxreRB>qJ5
=b6NpY8FEY6qxHTt_::d kW&lU<87xv6
hLG5yoD=Z-{-i7,S92$tnFly3!@5٨% &h3{.9RT o%yq^c&cozn<a᜶H<::r7]7>pwXܭU2VӱXa$#2?<	&"}z?h}:Uf]}[>-:>ME}#}lņP`qV>ߑہZ6_sE\42$ J4cIN
&fYKJ q<fB_KvezymJ:ZUzzIxڮ7wKB_#sL\<5PD/@-/Ɵ6_뛍98|6Hc]Wùw'Z9 `u.J)]
1;/yN5.Gp{b+*,׳.v||I[.w`(<>vpe\n:SqLH
፻uKqb.%.WdԊl_tʌ)wLӈ(xo?P46uUkunm; &\l']0Sd`mXP,p1Q:W;}v2^ce
o[) uQVȑٶFܩ;5$yfUB􌑁oD+0@$@;DB@x3.]>f-e%T{ɶe*a؄+a56Lo8z_aESZ6.T #CU*
^W=A(O%EiZ&` v,@]v^U="zM;Tߡk25ڎK6	u>xc$C1)b5 a9. r'5e<(,~uBrsf/x.ȁ?LCboJA7s}$eQN:HĈ^k~79@ksv{3ɇyTM6u,]ER+c+@a UPń<
oe"su@Su>6iytKi(+aYwWF֩ri*,()E/!Bz`mqYD\3

A>lVZ;"B_Z>V@}˽G0SۧQK,-c[ rw(	vӆ~ n솮nkЊf)n[1/z|b:^z"TGҹڹ8a:?hy̨q2I N+!>MvFcF\I'bǷhkjjs7O$O%@stKhx-MkX}/2@*W@LDԙEp0}+w2Lp2P,*w}R>ݯጓ$ɠ)E=|tjilr&08_<9c"=(O!JRN[k#-վZP9|7D`(׎p=q$2tvޣ˴2r.} Tk<-Uz7[m@X	Cnnq`})wkWjuèoi1H6DUBرd_tۦZs]6g.ԿR*N]0lRv'$>k6b79C5&1?a}Kh
  -(,#jv0^li'H0.r#TXgÉӠ(4NqZV4I|n3OHQv^Jy)ٖxXG|;T@DUՑrJJoSZ,edܒd=*-qyP-R8
T>?xZΖF%\NCVAm[Y,7W jkREk>,,Qy!_: .C[kXf*qNRPN
0ntCᐎDA5	}V:Pjx/5O\SǑ% e94g0ѐu"WdLOsI5%9^2b2pG	؟d(	WN,$s/T䎅~*j&EhKV3qpGitF	;-_Qomxӡ;hY4\%	eL~7-S.\٨`hcG͢c5զCFRZ+Y1@9efxO-HDe/VsTf3wsίP]^_Zэ!݊^ApL8Al=<>bnY՗7Ssn6ǁ#^dcmLW2|3lX^6S5:|[>H1] ˲oMKM(/E.$xe)O]h\{_#?ڀHIsR
8/j7E"s<l2j)Ge=j첈f!4)Wn$WE;hݢ
:qM8CH#UIdc9jҔ!74)Ed8jUbsĶje$`Ce<=֟&Mh?nԢBW!qZE)$sqHX Ӌ5k-m"'K@=v§GuG:ߟ]yO
Ӕ:91e1&E47ǋ)f|SB#=SQɄqh6jK;Dޟ""@D;q-K|!H$+6TXXUY3HEWk!T>J/4^ge&DS$eU#;.`*{<ܽ'O4g̷WP2̘&l`|5"r`5+<'ڂ]Hn͎maZ =-uLl;f7ʱxsqOȺ'9*Aʽ>ZQ{ʁ4tPٵ(^HLuf ;[X;d˷M@f7ӊ?C:;r|!կ
xщ^ءi3	 Ը@<>g}2&`QL k29&y;
&7;6K&Q6({)¦bk:<g׍wj~l'ǫ3в_e~TU_xRJJI^#4V9Gx{0^dLqO^d`>Ն$'ĄhL( 707'mo)ECP+w@T _+VV-WL~O{R	z6sFoR]3^'(:5Vd]l0K_;J;q WƎy\Itro50d^U.?f0	TA?wHl:B9:[]`Ō|qm]'R@717HO*+R}*EM4%P-W,ˤ*_uNsUijL}FN] vfk&_QǆDs?tŲ)1<nȩQ0H8/\򩼣fgrmmzu>QOĦRbg'C."{MrA_Of#յeoќ>ǯ,Qq;hy(ao-$b%ґ-ͭ-|E2cfeݟ-
E0oq773, QeETuA$ҧck?\V2Ҵ4C=;(־0Y'5|y7Oyr&E蒂kq^9y8D`i	`$`wmr.nx4sAvӪEu
!!I:Y u4EȦu/,UURʼ[Ǒ)E/1&5--'1|2Pbܿi_"6(7xDwSQ#uN}Ca]ԥIE\f2:Xض)2N/}ά1"KҔV_(ֳ3ѳtHŷ"Yq-uMQg:>fT= </Y1Ys!cT,^8{WłHD~{
sx'Bi +*pFD.QErǑ<Z5SO8b(aTLk1KSW4`-f|O[[Y9<\%-38"	$FsV*#(>!EBVMaVDH&a?'l+cd^.s넀]t
"!1
Lg`R9N07Cl2fXG;q0`ҿޞQ~ύ3pz*p	+	7a=Rh)֩f&."qjiY[?n噂esYcMBk֚nyϲpћ%x[w.1
%)([`kB4xȣ,+6~)uP}0PK2wKoCj(]Dڋn@䅐"+,ܒ~X
uy]6+UhJN~I߰)f!(ϼ Dn[RY{bu+'͵XW	OlLS0"&^Xo92p0hrWKB8 l1,oPM	׈$8vt&ìοb!3#q(T .":є|a$I	0sGMH5}b'o/e0=n!:9ʪ-I淆>شJ:(7KqU$^)ީQɅ/	lRXSDz#+d>H_J<Z2uSFL#ppQnrj`CŐAC[_@by!Bט38OciZγPDJCGHIYWB8 ,W0,O&L;EڑN*qBc͓
Z(T6
)Fb;)Kc(Gq'I.=; vzg;K!X߿ތ4qcs
VP;ԑ-W#cCNbH-g$\-a J}WGHYfM2s^ʂtj,WmKTxk%]vzmiRF79Xg(11.D"zϴdn1|C_ewpn鸗?¦Na&^~9^&H'A]K[ͦUkYd8DMVX~E_׆ޜ#a6u`/IhHFo$3%)ZQ) *Wf׊M[G.pgTp9ɰ+Ko,9Qbw<9_>_=yZ+W!dU=Ҏjl#1@E`,ǜ5HU6NmVV{mG[R|j1)Td*pn!r.YYkW{9A.,Z P<+3B(=!<Z$',[~0̓3vJuu3aوQVW5H3J?B۪7li! *tʟp70d1~8EMX @	YV6-qmǅY17MbܮƒXř7qKX"p,>&iWH+3]6CR(VAkδsެQ9 }};#x.䎧JBxr>*hI5+Q䷕q@}yaj(QUoG3y)iZw[ſ@<X!DGn#8ϓxZ"{mzE>\v{,/69p7^i2ޭ_Ks;dUNȗ
OzM""eiծV:N20o-%Tc=euDFKNW;?/4b<=˭e)d6lh#_6H2wbnun[2T^v䊁D)	(rXuE15~/|8t!\u'mof\
sB2Aä=Іf=3lrk |>i\Ԑ
2KE_DoqATH`_4_;{ ~ʗ!$WzP|@=ǽ\ag7DGf)c"{p^3'pΧx'Jp38. GkO#fg3zmxAŜj8Ɖ\IH뷲~`cfV_^Sdi
\mq-V{	XHŽ8ǈ@mrPM($Qа ͉آ#LF>M2orN4$((*sWuzjhHf6]K;GsrEYyA$݌ڜUl^,m9fz*/]j8lWJt$ø ~`["ڠ1D0rԥ4b6E\O0+;n^9J@*>m1AeZk~>o(g'.B18)Sj@3+Wk*\+)u㵞NM89!gX9e4G VM?flc뷝L,sfKNj_
Uwխg	">}5=Vd^R^ >H9vpIa(B6uy.UaM32Ӆ~r9.1AG$U͉ƙ(ݦuY!{ɧ
O~o8:A:K0%`:6VaK73\h]t-\"-쿺H2δk2qjeC8Pq8R֤}" "ab	(\'T/3ًbA/q%xpg:BE[Z=0 iS%a]pF#@pznQց/Y[޵H38?z)ĤϒuN$S0ٚճL%3 w~KQ<F9MEGe`?V꒱ZLkŇ![4ib,X˝[]kkZ}M<tߒ.ԕ,sQ g7JW83<	|H_<|a6`6p='P"+U!$BJ8 Waqу9"RAXj`gS]OlǝNZ&}%Mzp1)LCcCz^[ \kycŉc4_bZHm.)+?}f6y!H#d0@`꼈GpdiB"[}SЬ5gDzo5-.%ᝆ3%ǧ\dor#JNaDٵ)
tKiq|_;b$;m6ܻx3" ĖmKiȏϷަ.5@fT.?k~ CCv2*l/ qCU.DM8N$KBKΰrnʴW으GROeXnw[UBҧHb|f$^a"F]%*lcrp.(3탞t(LUClE Y~knCx͜!<Cƿ"}$f;9Ip\3_DXU_L~Yc{ki&9.lxp+Zg)_DD
I*|/Kp-iVe!ڄ+]kC?0`-Ay9U=,)fDQtMwJ0B6=WPS, ,	N Up}Dali8
;]aAvI\ߢi3)ޙ?u0d{l{]7eEQ]3` W\>zeMҊ.O!׿uk }!	{*DFh'EL\U*lYORNsnl<B9tLO[myPh+MXsa!PhnӠ@b<kL4s箔%[,_f9El֒՟G*:_0g5dSa}Q8J ha@{J11r3E5iqxўڐJʫD˅̩d<&La͆UWYԽrFo`;zSg `4T'AXd2DZKb|.Fw>dMAQ^7穈`DI{X`
}KH<a[~W{Eu :_N`+"9s?@1KWml	ks,k('D)h@I-(5ݍtp(
XBn)>GEi#
H!UҰH2!&5Wl2$t bHz,k%0hVݫ-z4ixSn;h&CH/(
ư4ret}I2c5ދ[9;Bn6/MZahӺT")zP{sfF+ED1-ajI/0B;^	y-o$RD/Y=E	G7,F^hzE	;4§8!ZЁj>fG>SG5fzxg]ZLYre` /aB'U]ڗz:Aґ#C 5e吪VWAOU!b<	c,מ'l1n2_.-zIKH%Sώ▯e/|][:T
<at'P<fu Uv7>F2ggZ(XM #*Jஉ|y~3߲vZb|oLC8
L^ewkggG+ñ[GKB|wBO
lS+W,Gu>HEiSC>Q#hoAjQYAIWe,C J+cݔ$s\ 8<oc7شEBT,7*.j.9RiՀ[`ꍡ2t׫F
eCz	:d~aJ"
M8
ۼlL'%du$76ӆ#m?_^;7$w>$ȕxzR\bCkHxЯ],D;#X+/NIi"yGQ
[&ynagG!ϰ:nW!D32<xOIx֙;ۦ(3~pʬ(^!VLQ
,L+Q+Kdـg/(G2=^rCu1H)9a~)h裙'e6y\TE79@Wa:҆CZm*H$b n\ro~.&C~f		8$4 w,[R0+ѿQ&aP!ϋ ?3}O'ybEyEwA~ۿv*V˂ȌMJ@chȆ0HyF~hLAtC"2n	~gZ_%Z'bףdnnli@,5r~sNVP|5ou(//opiFٶt*q_];VѣqmU.n
!A[b-0̌l=!&[G.\/M7JǭHhWݜ|bM!-n÷phc ƺ8_T8SHfm	`_bL.?q!pcK#!Ā2ՒԈ3^D eQn|B0/XZ	R iI jFM߀⯟{}}62wH*	1..N[_>y$xaô"`Ԫh#ەWbz,[&h.?3+%_5Ww 孴͔c)޺*)86s,IÉ$1d(_A4Evܛ ?@Hb* bs+hV
ct#m8]j=$DQdfb7-5]Gw
&78`ԔyW'Ǭ^Bt݇poXt47yAP-Ru39e3PHw[VLKY}<?QӋYdE&h(~b6_@9vu,SBf!ML 9؂͸RUkK+
/:GIӣk6VSHC(WDOc	@
Vb%{{&d<",{tBVݣ`ȳ;/iƋ&ǣ 1-04ʽ<%ie@ԍW#iB$u\+&v	<"n}zXL+^I*m1\k{eYIp96`ddQZQn^6'93GaȰp yv|%\Y&.)%MX{TSMP䈾A`T0[PTe(bB8#^?vMV8E68V !Sή&K'ю9iw~XdnO]QG4Jr4؈C`g(>8yظ.h_Ou G0ɝ7 '\IU]e,tyz`1 So˥0xNZFxԮ F3ӮI䆣+þHy#>;m(BӶ,AI),z";2@s p^J?+/HVV&L f,5S!ko2k
\H{!K&M!F2%(t7I]݃O	 dwAd*$r)aPu1}غP	Hj&#^b!+"*OpFAԝAVQ1,OZAbCX 링ݤ[J=RPssQǅWklG6IMXzwڅѵtx r^)E;Ч.=Yv|/J
"/[`,Ut+k%؇%CYU:+WB냼tͶKܛ"J&6U!z+2m0N7xdU$InƏ{կQ"ίAlbh%zQFnAi^7cAOI&AʤzBKjGJ>ܥ]6ezQ
/I,\ùҢw&/u$FR֒bΊߵ"OYao(N_btZd+oM׆t֡QE(["PL|ef݅e|HApɸCA)1j5<bbڛw_[|Bjn+X[1nShi*619ðalE8Oy	>a(SVGLS=Wi_?$
xy|MI5A^IKm	 VjǇ{ƅҐv:-]{T$7>[dDX~
C:s+WZ+|D riX9":%DPYVF
9y2Q9>EB22Z;vRUgmD-M%
 ʃDz>)A6hMO?VBG55/J}N<#CI)=OY%Dnؾۮ#A{&YN|1	m!N^m6bu?[Ր,~FjHY'iU|o</	Oiu$,
$drNYJDqFJ5fWY ITӍ
'08ҹ)yȊk]`@GS#|1"a$P+ƪs_eZہileʾ,hR6[⊎@ΈXG
&(D&9֊]2K6~$1$]*tgt;TllM,]r{'I N-CCT#}DJV`b/2-cO:jYEB#k2Sb
5
B~:q, ῘKbN`$IJ%S/D7lɱf	`pvZZM+|"\eLћ.̮y]ӴŬlMXcIGCwEd۴˵:^3GA lp>5璬LPzHP}lMUDo<93{N&8T15ƖRr'Sy~kbinP8PQrB.IT|МW(qMmQtcqEs7UV-o"!c
2P<7VZ/#6SB~k_ҷlVZhڞC3[~^=r!$t_WIS٦9զV9h\=w<lT8J91¯G09~!\/;fyQ7yje=/nKt$Wh\^m6
e#y<D<j1XJo;(=ݵ9pJM>#4wy|ֲ.? >6-g M*7I.@H|4bs
c()Ww>#"WUZ'(]cŖU@t+UYěU}HyxE(<*v5oxKPs,\6;jV}1LpOFF=5n+ݒZ	RmOh7N.XкfFveZPו	.E٧s2P~KsAjhdm\EBl]rvdHIa_HʺuA_[U1ߥ(yn>.\}BzkNWM.\^|`<VNSrȆW &Q}Q[bJl4xa	o0E¾.k	/ؕZt|7 t^79mĿ`'6[]NYM0u31PKHOxFOIܗ_8	[duZ.J*c|bIuN7&)} -.y5@LMRh׏j)/+Jq	Dus_WZ){Vc[!&dfS],}2
+WZF-q$O'-J+DDoROr|eu$ѐR9TzWN9qEU
hEтߒ]H6jc>")cx},m#ǺE[=ܱ&6$}Yutٔz]Na5]5Ivric!#JTO.82طB7qnpg|z!]H)	C)A@MEʀ]3<k@f|x=D2<Y{t'D8cifWS4-SXE](xⷩP* DG+!aAsfK+]+׳>29YkH^1PvD!V+١-L3!{6%0Q.z	&txx[
?|:K߃hXh<F9NHၷ`5DeoG(2C- ~̃Nt6ȴD*u5uTQ'eCU4TΥ01_!* f<OVr"6ٕ[T(nWMΉIL{-*I(%Yo},oA&|
X#,BB^B<@BqdvYVun	F'/+pIgwx4)/ Vx"6\`-?餂Vg"dVR'"qo<cuɶj* YW-.zCw}([5PcdVXQYp?Pvd}*Uyv>5d2K`|Y$Mƈ<;oGњ
-(l;mi龷tOg¡ϝ/a7ۍBR4P;/IE1_J5EWsp,u<xCpoW[`J57B%p#N>#;CS3r?D Ԯ燵&RAV/LKVx"BU6ȕԊVMlh|lo],Hz0.QH#sL7-OQ#9|^{l}H)F478֑KR K@tGB6sgn`ڞ"XPuNHZSA֠">51
$}.D_#-&heKgf@|uR*sٳ,ͷ\i3r}A'*ף¶
VKb)~ŷ}!]l=yn{kՕTal9-ڴa]b$(v@:Z90,GRtyZnDdo\"D&0$-	)u^6XH%zy5LnM&n#pE߇xI-He %~b5#Χ-J]%{v
q<Blu]tsXzZh"-z,ҧ{fPE޹e0X~'qL\O25'*$#ռ@9aBj	@Ӛkq¨bE:*<kp<l*g[br:2-6ҔX/lU{=nJ{V&mM&
MѺ`BW{F9;>sǚDfy*~h)1ܞx
Jq>t(|?8eZ]ilYX*[KsM&Qk#8,9Y#za3'Zc.}mΫÂ"rK"f}pJ!ǬLd)פ"9[~n`ؼ,rjpO/-d&"`deOaB?/GqnrD'Rp{EgWJ[,ykl>1|D]:m%:Y{ȳz~	EoҗArZRɯ
.KYnpzn}
%Կ:XdZQ0>d{!5/f02SmGFUAjRPlX;r˲.5U,ca`bɶaJýmw̤e7z#S`w
v(#.=;̂ aYAlҺY2V!=K+3Kئ7/f9ۭH|؎KRN1u_4;ʻ;_^y&)܃fu󽞫0(S7L<"׼t`*>yhew2A^_8sN42(zK=UeK		lfvR(LkԚ"Z%8u?_+UX
Oő<Y*O}|WvOfcqOl L")l B*n9/m5/USJ =,Z}U)3K"C/D6M~v}BPm&+nޮh#hpN;l9 Cv2`/W9^11somgB=GEAxCk|!no-(. Dp	T/T{tIGN]q Hg?v#8:%+	xymtHo90\0r
:	8ۺi҆wvۊe
J!\~) QA?F0\VD-Fe<d1ƽi.CN$Y9o滄N}#@_Xr/XT&"<ż#8&@2x䁾QoH"5|kłn[̣L dS	yEim?Ǔ_e-|/.HBBlqPͻa1DYgpPf1;SKOq#ځԮΈ3ZHLQΑ1â@{7e?7^di=dboy DgSRzr<x>fw
{9ɣ bz~AhUxML=Bi}Gsz(y,Lycs[EsK$+oCafa_	ݩF;!1JdopC@ǦTǒP	R&D/tic\OT!f6Yɘ*^lmF2S1?e8WP0wzxC4}\8X%uwR_f\h
:̾] Z^</n3zYuaf"S˜[UæQ2#=D,?81%Fơ]xϡ)~.|5'>4>3lURI4nvƑI:b%{/S-ukցCQWEwtPnT|iAjga"[plz$HWMݔĶxm6)&W7%{i[
V*lcQשWZP+תQ2ܠ6(:Bb(YMN AkJb򹻘9`0SrؔX}<!#7Ttx&ūY	Qs 5at>ר+geIulLWuSܪbսlɔ@QuPB솂$vBcNGIiә>DxʴYjF`R;*,V.ٽ.ۣDrC<$nalǅ]b[Lh3o
ݞz5
@)HVJZ	B,Gw\t|܂7C.2M4W	R|/1;dĶ8ĹOQp}X{ݡAJcLs74J[vyy ,NsY)nFltip0mZyB/Q]a9G_`eņv}f?g::42Iށ˦pEP-%?чκ"-(Lc1m '4iANc
jLBD'ׁX1dfz>Yt)6KL3IG?e6Ds#"	hFKتA@*@z׉qZwY{*
](8AcVK%DJCi7kK:'hA`qp+!72P(O>S$"z^cƻ1x}JoKu|wo42(ӨfFp^4ϿiPCecfO
,'' NG_Pl85d\)Q	fDa%EXy*8w3<Q%j3 \:ċXJ ;wOLzk{F%9[X,eqk21oa)H?Fo|COeanXZ;Ҹ믱q%R=Ec/aEHMO{1toz$vrT}"̲3@ShN>k'. IJwҚ.P?HHgZ$}} ;=jیܟ|3Pg8Uچ[yuP+-"}Wܥ5"j׮p~_}@r7Ck r^)7ZC5T2_dtB
['VI(I>	xOx-J{x{Ṽ¢H}ͿmQ/`T&Ŗǻ/Z |t$?TZ BW	3I"@d?X}II>	}ϴ-\n/K}G;Ն-f$¤\a/"[T2$i!#qD0;;>
NU )`vMU@(O^fjY+/FD(Rsum SNyp"}yrp?ڝ49wt#tYXh6W/ڿXT.bpZpa#eBQPzW!ӛG/(;{hfijmx|9B ň	<5Me<vI$q=˕HRf>k}ֻV+IؽFeYĭ68wQ%]W6w	jsTо3HBUTlob@0ܛh(śCMLFA-p&ψffI*11#w=#7Uw)xwvY'ޔ	5H[Kؓ1w9u0&{#mlVl7ho`6O)3x0Fʾ|ږ#'S DC
Gw0\hH<Jja|Za`]8K}zy]0;">g:03]⿰}>\u*$F$gd>C*ySbP5!1d/Ⱥ$,kjpx+PiZYhtkdzM<@n*D*ZJ\p{zѢRsʆyI)N(jj֔gTs}Dʏ?]&Qʔc2fcF	歷H+t5]rX.SW؆MN;bW渓ەz~e
fOhbf>}/oq2/;8X"*Df <0ɭZު' S|hL˽I^j_j&J|_fϝ?6hA Ȟ5n ^]>zhE&Q>s5x\=#I}@<ǈkO^w"NЕrH ↲;|?xrhgh!
|@Ryp?ht"j[|ǿ#њӊc!hTeI)m9b=--vz_%Gϒic i95cKDBm݉RTF+E}MK[Gj	r\q
h.Zgdsl8\59RI$Ŏ
<@'A<7<kcKO6T `dIl@2^ bW@#sָCFKp?fTz2|Κ'[3+dW*#-1 H|4%-vӚڦI?|@ܕ0Ő-=tLcjT]~d#mˊ9Rdܡlqb8A@^!VC6[`gJ|#@zPYK $tb(ݣf1µnx%MhVjjOTM}p*H]kGBex*Ga(L$Uj%Vm=wVyE/Ն΃<tZ37,fmGz-軇5Dy$e׭& [C"@M9QK'+ _lD5%!`BL7"s9`V_#?%j 7ZnBql豠D,͝/=ØMonqL	*v:Q)kE#>;ڝ|% zΗh@U=UZo֑촭w*s1_ߚi&An4u~[ub˥a!2X!?q'>%i{!hN!,4Q&F7&L*۽3@<i}[kxi[LnQ,d"۳Qhf6|V1pМaHN8cE VB_=`o煉zuL`&[mD6b߃XJ!opZҞgNǭxWOinXgLGaI/ƙ>v7ȝ`
)]{Pv0JDH=ē♈r{(ozSJiuGkTkZwuC箉%=GDל)Aa,\虊dXU*kjvX>/!Y}lsE.z-;Q[hQgQ7{\CnwR
$-yۮ8Y^5~#.泂1l213K:KM5CN=T͝p`db|.J°E<^?]I?l9.k+AkJ}aފ	Q1{dW^+oHƅe>+2$Wڱy l҆|][Ew>ǯA}`pav%^.-AQueZ2}2$6!,UɅM΢h3㔀l.1Qg< 
bPM/-SڂC{J;{Gq>ex#^)fm!BV,xh'$@-YK8{i4[-4"nElyxt)=ؗ'Pr^jL؇m7R;v(-^|4is@E7.ldVBTݥn_vZc(+):OX6rX{sW~me%odqq~Fx*\!!BCTI% =  GN&d+gP~K]xqto"	kjs3ܡ"ePGPQ!#%[/+5m`=sS<)Ta
&ms>P:Q ڡ2& JKo{5&lE8:MgnO@5Fo!b3ai]aߥIY9C15}	<p#o'dq@7,1<'?߸BӡKzH:-b]oiB#gk/?0˳ˈwo.&>@o`劤;㐥"H+|}$TZKvzh{QHz!w~󀽠lX-w<,pu#1!}|Վ	5ezqmCS<"opL!1^1TRTe˦ҭ9*z' z9hW5aWۨ]C{(cI~TcQ>{XC5sLV<
qalCW?)!,Gs]~b3.iK.BlE6pd!{:0<[E2 _]?a&Ü#'O} u|lԺU:oDؚ,D7v}".]// SPDX-License-Identifier: GPL-2.0-or-later
/*
 *  Driver for the Conexant CX23885 PCIe bridge
 *
 *  Copyright (c) 2006 Steven Toth <stoth@linuxtv.org>
 */

#include "cx23885.h"

#include <linux/init.h>
#include <linux/list.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/kmod.h>
#include <linux/kernel.h>
#include <linux/pci.h>
#include <linux/slab.h>
#include <linux/interrupt.h>
#include <linux/delay.h>
#include <asm/div64.h>
#include <linux/firmware.h>

#include "cimax2.h"
#include "altera-ci.h"
#include "cx23888-ir.h"
#include "cx23885-ir.h"
#include "cx23885-av.h"
#include "cx23885-input.h"

MODULE_DESCRIPTION("Driver for cx23885 based TV cards");
MODULE_AUTHOR("Steven Toth <stoth@linuxtv.org>");
MODULE_LICENSE("GPL");
MODULE_VERSION(CX23885_VERSION);

/*
 * Some platforms have been found to require periodic resetting of the DMA
 * engine. Ryzen and XEON platforms are known to be affected. The symptom
 * encountered is "mpeg risc op code error". Only Ryzen platforms employ
 * this workaround if the option equals 1. The workaround can be explicitly
 * disabled for all platforms by setting to 0, the workaround can be forced
 * on for any platform by setting to 2.
 */
static unsigned int dma_reset_workaround = 1;
module_param(dma_reset_workaround, int, 0644);
MODULE_PARM_DESC(dma_reset_workaround, "periodic RiSC dma engine reset; 0-force disable, 1-driver detect (default), 2-force enable");

static unsigned int debug;
module_param(debug, int, 0644);
MODULE_PARM_DESC(debug, "enable debug messages");

static unsigned int card[]  = {[0 ... (CX23885_MAXBOARDS - 1)] = UNSET };
module_param_array(card,  int, NULL, 0444);
MODULE_PARM_DESC(card, "card type");

#define dprintk(level, fmt, arg...)\
	do { if (debug >= level)\
		printk(KERN_DEBUG pr_fmt("%s: " fmt), \
		       __func__, ##arg); \
	} while (0)

static unsigned int cx23885_devcount;

#define NO_SYNC_LINE (-1U)

/* FIXME, these allocations will change when
 * analog arrives. The be reviewed.
 * CX23887 Assumptions
 * 1 line = 16 bytes of CDT
 * cmds size = 80
 * cdt size = 16 * linesize
 * iqsize = 64
 * maxlines = 6
 *
 * Address Space:
 * 0x00000000 0x00008fff FIFO clusters
 * 0x00010000 0x000104af Channel Management Data Structures
 * 0x000104b0 0x000104ff Free
 * 0x00010500 0x000108bf 15 channels * iqsize
 * 0x000108c0 0x000108ff Free
 * 0x00010900 0x00010e9f IQ's + Cluster Descriptor Tables
 *                       15 channels * (iqsize + (maxlines * linesize))
 * 0x00010ea0 0x00010xxx Free
 */

static struct sram_channel cx23885_sram_channels[] = {
	[SRAM_CH01] = {
		.name		= "VID A",
		.cmds_start	= 0x10000,
		.ctrl_start	= 0x10380,
		.cdt		= 0x104c0,
		.fifo_start	= 0x40,
		.fifo_size	= 0x2800,
		.ptr1_reg	= DMA1_PTR1,
		.ptr2_reg	= DMA1_PTR2,
		.cnt1_reg	= DMA1_CNT1,
		.cnt2_reg	= DMA1_CNT2,
	},
	[SRAM_CH02] = {
		.name		= "ch2",
		.cmds_start	= 0x0,
		.ctrl_start	= 0x0,
		.cdt		= 0x0,
		.fifo_start	= 0x0,
		.fifo_size	= 0x0,
		.ptr1_reg	= DMA2_PTR1,
		.ptr2_reg	= DMA2_PTR2,
		.cnt1_reg	= DMA2_CNT1,
		.cnt2_reg	= DMA2_CNT2,
	},
	[SRAM_CH03] = {
		.name		= "TS1 B",
		.cmds_start	= 0x100A0,
		.ctrl_start	= 0x10400,
		.cdt		= 0x10580,
		.fifo_start	= 0x5000,
		.fifo_size	= 0x1000,
		.ptr1_reg	= DMA3_PTR1,
		.ptr2_reg	= DMA3_PTR2,
		.cnt1_reg	= DMA3_CNT1,
		.cnt2_reg	= DMA3_CNT2,
	},
	[SRAM_CH04] = {
		.name		= "ch4",
		.cmds_start	= 0x0,
		.ctrl_start	= 0x0,
		.cdt		= 0x0,
		.fifo_start	= 0x0,
		.fifo_size	= 0x0,
		.ptr1_reg	= DMA4_PTR1,
		.ptr2_reg	= DMA4_PTR2,
		.cnt1_reg	= DMA4_CNT1,
		.cnt2_reg	= DMA4_CNT2,
	},
	[SRAM_CH05] = {
		.name		= "ch5",
		.cmds_start	= 0x0,
		.ctrl_start	= 0x0,
		.cdt		= 0x0,
		.fifo_start	= 0x0,
		.fifo_size	= 0x0,
		.ptr1_reg	= DMA5_PTR1,
		.ptr2_reg	= DMA5_PTR2,
		.cnt1_reg	= DMA5_CNT1,
		.cnt2_reg	= DMA5_CNT2,
	},
	[SRAM_CH06] = {
		.name		= "TS2 C",
		.cmds_start	= 0x10140,
		.ctrl_start	= 0x10440,
		.cdt		= 0x105e0,
		.fifo_start	= 0x6000,
		.fifo_size	= 0x1000,
		.ptr1_reg	= DMA5_PTR1,
		.ptr2_reg	= DMA5_PTR2,
		.cnt1_reg	= DMA5_CNT1,
		.cnt2_reg	= DMA5_CNT2,
	},
	[SRAM_CH07] = {
		.name		= "TV Audio",
		.cmds_start	= 0x10190,
		.ctrl_start	= 0x10480,
		.cdt		= 0x10a00,
		.fifo_start	= 0x7000,
		.fifo_size	= 0x1000,
		.ptr1_reg	= DMA6_PTR1,
		.ptr2_reg	= DMA6_PTR2,
		.cnt1_reg	= DMA6_CNT1,
		.cnt2_reg	= DMA6_CNT2,
	},
	[SRAM_CH08] = {
		.name		= "ch8",
		.cmds_start	= 0x0,
		.ctrl_start	= 0x0,
		.cdt		= 0x0,
		.fifo_start	= 0x0,
		.fifo_size	= 0x0,
		.ptr1_reg	= DMA7_PTR1,
		.ptr2_reg	= DMA7_PTR2,
		.cnt1_reg	= DMA7_CNT1,
		.cnt2_reg	= DMA7_CNT2,
	},
	[SRAM_CH09] = {
		.name		= "ch9",
		.cmds_start	= 0x0,
		.ctrl_start	= 0x0,
		.cdt		= 0x0,
		.fifo_start	= 0x0,
		.fifo_size	= 0x0,
		.ptr1_reg	= DMA8_PTR1,
		.ptr2_reg	= DMA8_PTR2,
		.cnt1_reg	= DMA8_CNT1,
		.cnt2_reg	= DMA8_CNT2,
	},
};

static struct sram_channel cx23887_sram_channels[] = {
	[SRAM_CH01] = {
		.name		= "VID A",
		.cmds_start	= 0x10000,
		.ctrl_start	= 0x105b0,
		.cdt		= 0x107b0,
		.fifo_start	= 0x40,
		.fifo_size	= 0x2800,
		.ptr1_reg	= DMA1_PTR1,
		.ptr2_reg	= DMA1_PTR2,
		.cnt1_reg	= DMA1_CNT1,
		.cnt2_reg	= DMA1_CNT2,
	},
	[SRAM_CH02] = {
		.name		= "VID A (VBI)",
		.cmds_start	= 0x10050,
		.ctrl_start	= 0x105F0,
		.cdt		= 0x10810,
		.fifo_start	= 0x3000,
		.fifo_size	= 0x1000,
		.ptr1_reg	= DMA2_PTR1,
		.ptr2_reg	= DMA2_PTR2,
		.cnt1_reg	= DMA2_CNT1,
		.cnt2_reg	= DMA2_CNT2,
	},
	[SRAM_CH03] = {
		.name		= "TS1 B",
		.cmds_start	= 0x100A0,
		.ctrl_start	= 0x10630,
		.cdt		= 0x10870,
		.fifo_start	= 0x5000,
		.fifo_size	= 0x1000,
		.ptr1_reg	= DMA3_PTR1,
		.ptr2_reg	= DMA3_PTR2,
		.cnt1_reg	= DMA3_CNT1,
		.cnt2_reg	= DMA3_CNT2,
	},
	[SRAM_CH04] = {
		.name		= "ch4",
		.cmds_start	= 0x0,
		.ctrl_start	= 0x0,
		.cdt		= 0x0,
		.fifo_start	= 0x0,
		.fifo_size	= 0x0,
		.ptr1_reg	= DMA4_PTR1,
		.ptr2_reg	= DMA4_PTR2,
		.cnt1_reg	= DMA4_CNT1,
		.cnt2_reg	= DMA4_CNT2,
	},
	[SRAM_CH05] = {
		.name		= "ch5",
		.cmds_start	= 0x0,
		.ctrl_start	= 0x0,
		.cdt		= 0x0,
		.fifo_start	= 0x0,
		.fifo_size	= 0x0,
		.ptr1_reg	= DMA5_PTR1,
		.ptr2_reg	= DMA5_PTR2,
		.cnt1_reg	= DMA5_CNT1,
		.cnt2_reg	= DMA5_CNT2,
	},
	[SRAM_CH06] = {
		.name		= "TS2 C",
		.cmds_start	= 0x10140,
		.ctrl_start	= 0x10670,
		.cdt		= 0x108d0,
		.fifo_start	= 0x6000,
		.fifo_size	= 0x1000,
		.ptr1_reg	= DMA5_PTR1,
		.ptr2_reg	= DMA5_PTR2,
		.cnt1_reg	= DMA5_CNT1,
		.cnt2_reg	= DMA5_CNT2,
	},
	[SRAM_CH07] = {
		.name		= "TV Audio",
		.cmds_start	= 0x10190,
		.ctrl_start	= 0x106B0,
		.cdt		= 0x10930,
		.fifo_start	= 0x7000,
		.fifo_size	= 0x1000,
		.ptr1_reg	= DMA6_PTR1,
		.ptr2_reg	= DMA6_PTR2,
		.cnt1_reg	= DMA6_CNT1,
		.cnt2_reg	= DMA6_CNT2,
	},
	[SRAM_CH08] = {
		.name		= "ch8",
		.cmds_start	= 0x0,
		.ctrl_start	= 0x0,
		.cdt		= 0x0,
		.fifo_start	= 0x0,
		.fifo_size	= 0x0,
		.ptr1_reg	= DMA7_PTR1,
		.ptr2_reg	= DMA7_PTR2,
		.cnt1_reg	= DMA7_CNT1,
		.cnt2_reg	= DMA7_CNT2,
	},
	[SRAM_CH09] = {
		.name		= "ch9",
		.cmds_start	= 0x0,
		.ctrl_start	= 0x0,
		.cdt		= 0x0,
		.fifo_start	= 0x0,
		.fifo_size	= 0x0,
		.ptr1_reg	= DMA8_PTR1,
		.ptr2_reg	= DMA8_PTR2,
		.cnt1_reg	= DMA8_CNT1,
		.cnt2_reg	= DMA8_CNT2,
	},
};

static void cx23885_irq_add(struct cx23885_dev *dev, u32 mask)
{
	unsigned long flags;
	spin_lock_irqsave(&dev->pci_irqmask_lock, flags);

	dev->pci_irqmask |= mask;

	spin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);
}

void cx23885_irq_add_enable(struct cx23885_dev *dev, u32 mask)
{
	unsigned long flags;
	spin_lock_irqsave(&dev->pci_irqmask_lock, flags);

	dev->pci_irqmask |= mask;
	cx_set(PCI_INT_MSK, mask);

	spin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);
}

void cx23885_irq_enable(struct cx23885_dev *dev, u32 mask)
{
	u32 v;
	unsigned long flags;
	spin_lock_irqsave(&dev->pci_irqmask_lock, flags);

	v = mask & dev->pci_irqmask;
	if (v)
		cx_set(PCI_INT_MSK, v);

	spin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);
}

static inline void cx23885_irq_enable_all(struct cx23885_dev *dev)
{
	cx23885_irq_enable(dev, 0xffffffff);
}

void cx23885_irq_disable(struct cx23885_dev *dev, u32 mask)
{
	unsigned long flags;
	spin_lock_irqsave(&dev->pci_irqmask_lock, flags);

	cx_clear(PCI_INT_MSK, mask);

	spin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);
}

static inline void cx23885_irq_disable_all(struct cx23885_dev *dev)
{
	cx23885_irq_disable(dev, 0xffffffff);
}

void cx23885_irq_remove(struct cx23885_dev *dev, u32 mask)
{
	unsigned long flags;
	spin_lock_irqsave(&dev->pci_irqmask_lock, flags);

	dev->pci_irqmask &= ~mask;
	cx_clear(PCI_INT_MSK, mask);

	spin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);
}

static u32 cx23885_irq_get_mask(struct cx23885_dev *dev)
{
	u32 v;
	unsigned long flags;
	spin_lock_irqsave(&dev->pci_irqmask_lock, flags);

	v = cx_read(PCI_INT_MSK);

	spin_unlock_irqrestore(&dev->pci_irqmask_lock, flags);
	return v;
}

static int cx23885_risc_decode(u32 risc)
{
	static char *instr[16] = {
		[RISC_SYNC    >> 28] = "sync",
		[RISC_WRITE   >> 28] = "write",
		[RISC_WRITEC  >> 28] = "writec",
		[RISC_READ    >> 28] = "read",
		[RISC_READC   >> 28] = "readc",
		[RISC_JUMP    >> 28] = "jump",
		[RISC_SKIP    >> 28] = "skip",
		[RISC_WRITERM >> 28] = "writerm",
		[RISC_WRITECM >> 28] = "writecm",
		[RISC_WRITECR >> 28] = "writecr",
	};
	static int incr[16] = {
		[RISC_WRITE   >> 28] = 3,
		[RISC_JUMP    >> 28] = 3,
		[RISC_SKIP    >> 28] = 1,
		[RISC_SYNC    >> 28] = 1,
		[RISC_WRITERM >> 28] = 3,
		[RISC_WRITECM >> 28] = 3,
		[RISC_WRITECR >> 28] = 4,
	};
	static char *bits[] = {
		"12",   "13",   "14",   "resync",
		"cnt0", "cnt1", "18",   "19",
		"20",   "21",   "22",   "23",
		"irq1", "irq2", "eol",  "sol",
	};
	int i;

	printk(KERN_DEBUG "0x%08x [ %s", risc,
	       instr[risc >> 28] ? instr[risc >> 28] : "INVALID");
	for (i = ARRAY_SIZE(bits) - 1; i >= 0; i--)
		if (risc & (1 << (i + 12)))
			pr_cont(" %s", bits[i]);
	pr_cont(" count=%d ]\n", risc & 0xfff);
	return incr[risc >> 28] ? incr[risc >> 28] : 1;
}

static void cx23885_wakeup(struct cx23885_tsport *port,
			   struct cx23885_dmaqueue *q, u32 count)
{
	struct cx23885_buffer *buf;
	int count_delta;
	int max_buf_done = 5; /* service maximum five buffers */

	do {
		if (list_empty(&q->active))
			return;
		buf = list_entry(q->active.next,
				 struct cx23885_buffer, queue);

		buf->vb.vb2_buf.timestamp = ktime_get_ns();
		buf->vb.sequence = q->count++;
		if (count != (q->count % 65536)) {
			dprintk(1, "[%p/%d] wakeup reg=%d buf=%d\n", buf,
				buf->vb.vb2_buf.index, count, q->count);
		} else {
			dprintk(7, "[%p/%d] wakeup reg=%d buf=%d\n", buf,
				buf->vb.vb2_buf.index, count, q->count);
		}
		list_del(&buf->queue);
		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_DONE);
		max_buf_done--;
		/* count register is 16 bits so apply modulo appropriately */
		count_delta = ((int)count - (int)(q->count % 65536));
	} while ((count_delta > 0) && (max_buf_done > 0));
}

int cx23885_sram_channel_setup(struct cx23885_dev *dev,
				      struct sram_channel *ch,
				      unsigned int bpl, u32 risc)
{
	unsigned int i, lines;
	u32 cdt;

	if (ch->cmds_start == 0) {
		dprintk(1, "%s() Erasing channel [%s]\n", __func__,
			ch->name);
		cx_write(ch->ptr1_reg, 0);
		cx_write(ch->ptr2_reg, 0);
		cx_write(ch->cnt2_reg, 0);
		cx_write(ch->cnt1_reg, 0);
		return 0;
	} else {
		dprintk(1, "%s() Configuring channel [%s]\n", __func__,
			ch->name);
	}

	bpl   = (bpl + 7) & ~7; /* alignment */
	cdt   = ch->cdt;
	lines = ch->fifo_size / bpl;
	if (lines > 6)
		lines = 6;
	BUG_ON(lines < 2);

	cx_write(8 + 0, RISC_JUMP | RISC_CNT_RESET);
	cx_write(8 + 4, 12);
	cx_write(8 + 8, 0);

	/* write CDT */
	for (i = 0; i < lines; i++) {
		dprintk(2, "%s() 0x%08x <- 0x%08x\n", __func__, cdt + 16*i,
			ch->fifo_start + bpl*i);
		cx_write(cdt + 16*i, ch->fifo_start + bpl*i);
		cx_write(cdt + 16*i +  4, 0);
		cx_write(cdt + 16*i +  8, 0);
		cx_write(cdt + 16*i + 12, 0);
	}

	/* write CMDS */
	if (ch->jumponly)
		cx_write(ch->cmds_start + 0, 8);
	else
		cx_write(ch->cmds_start + 0, risc);
	cx_write(ch->cmds_start +  4, 0); /* 64 bits 63-32 */
	cx_write(ch->cmds_start +  8, cdt);
	cx_write(ch->cmds_start + 12, (lines*16) >> 3);
	cx_write(ch->cmds_start + 16, ch->ctrl_start);
	if (ch->jumponly)
		cx_write(ch->cmds_start + 20, 0x80000000 | (64 >> 2));
	else
		cx_write(ch->cmds_start + 20, 64 >> 2);
	for (i = 24; i < 80; i += 4)
		cx_write(ch->cmds_start + i, 0);

	/* fill registers */
	cx_write(ch->ptr1_reg, ch->fifo_start);
	cx_write(ch->ptr2_reg, cdt);
	cx_write(ch->cnt2_reg, (lines*16) >> 3);
	cx_write(ch->cnt1_reg, (bpl >> 3) - 1);

	dprintk(2, "[bridge %d] sram setup %s: bpl=%d lines=%d\n",
		dev->bridge,
		ch->name,
		bpl,
		lines);

	return 0;
}

void cx23885_sram_channel_dump(struct cx23885_dev *dev,
				      struct sram_channel *ch)
{
	static char *name[] = {
		"init risc lo",
		"init risc hi",
		"cdt base",
		"cdt size",
		"iq base",
		"iq size",
		"risc pc lo",
		"risc pc hi",
		"iq wr ptr",
		"iq rd ptr",
		"cdt current",
		"pci target lo",
		"pci target hi",
		"line / byte",
	};
	u32 risc;
	unsigned int i, j, n;

	pr_warn("%s: %s - dma channel status dump\n",
		dev->name, ch->name);
	for (i = 0; i < ARRAY_SIZE(name); i++)
		pr_warn("%s:   cmds: %-15s: 0x%08x\n",
			dev->name, name[i],
			cx_read(ch->cmds_start + 4*i));

	for (i = 0; i < 4; i++) {
		risc = cx_read(ch->cmds_start + 4 * (i + 14));
		pr_warn("%s:   risc%d: ", dev->name, i);
		cx23885_risc_decode(risc);
	}
	for (i = 0; i < (64 >> 2); i += n) {
		risc = cx_read(ch->ctrl_start + 4 * i);
		/* No consideration for bits 63-32 */

		pr_warn("%s:   (0x%08x) iq %x: ", dev->name,
			ch->ctrl_start + 4 * i, i);
		n = cx23885_risc_decode(risc);
		for (j = 1; j < n; j++) {
			risc = cx_read(ch->ctrl_start + 4 * (i + j));
			pr_warn("%s:   iq %x: 0x%08x [ arg #%d ]\n",
				dev->name, i+j, risc, j);
		}
	}

	pr_warn("%s: fifo: 0x%08x -> 0x%x\n",
		dev->name, ch->fifo_start, ch->fifo_start+ch->fifo_size);
	pr_warn("%s: ctrl: 0x%08x -> 0x%x\n",
		dev->name, ch->ctrl_start, ch->ctrl_start + 6*16);
	pr_warn("%s:   ptr1_reg: 0x%08x\n",
		dev->name, cx_read(ch->ptr1_reg));
	pr_warn("%s:   ptr2_reg: 0x%08x\n",
		dev->name, cx_read(ch->ptr2_reg));
	pr_warn("%s:   cnt1_reg: 0x%08x\n",
		dev->name, cx_read(ch->cnt1_reg));
	pr_warn("%s:   cnt2_reg: 0x%08x\n",
		dev->name, cx_read(ch->cnt2_reg));
}

static void cx23885_risc_disasm(struct cx23885_tsport *port,
				struct cx23885_riscmem *risc)
{
	struct cx23885_dev *dev = port->dev;
	unsigned int i, j, n;

	pr_info("%s: risc disasm: %p [dma=0x%08lx]\n",
	       dev->name, risc->cpu, (unsigned long)risc->dma);
	for (i = 0; i < (risc->size >> 2); i += n) {
		pr_info("%s:   %04d: ", dev->name, i);
		n = cx23885_risc_decode(le32_to_cpu(risc->cpu[i]));
		for (j = 1; j < n; j++)
			pr_info("%s:   %04d: 0x%08x [ arg #%d ]\n",
				dev->name, i + j, risc->cpu[i + j], j);
		if (risc->cpu[i] == cpu_to_le32(RISC_JUMP))
			break;
	}
}

static void cx23885_clear_bridge_error(struct cx23885_dev *dev)
{
	uint32_t reg1_val, reg2_val;

	if (!dev->need_dma_reset)
		return;

	reg1_val = cx_read(TC_REQ); /* read-only */
	reg2_val = cx_read(TC_REQ_SET);

	if (reg1_val && reg2_val) {
		cx_write(TC_REQ, reg1_val);
		cx_write(TC_REQ_SET, reg2_val);
		cx_read(VID_B_DMA);
		cx_read(VBI_B_DMA);
		cx_read(VID_C_DMA);
		cx_read(VBI_C_DMA);

		dev_info(&dev->pci->dev,
			"dma in progress detected 0x%08x 0x%08x, clearing\n",
			reg1_val, reg2_val);
	}
}

static void cx23885_shutdown(struct cx23885_dev *dev)
{
	/* disable RISC controller */
	cx_write(DEV_CNTRL2, 0);

	/* Disable all IR activity */
	cx_write(IR_CNTRL_REG, 0);

	/* Disable Video A/B activity */
	cx_write(VID_A_DMA_CTL, 0);
	cx_write(VID_B_DMA_CTL, 0);
	cx_write(VID_C_DMA_CTL, 0);

	/* Disable Audio activity */
	cx_write(AUD_INT_DMA_CTL, 0);
	cx_write(AUD_EXT_DMA_CTL, 0);

	/* Disable Serial port */
	cx_write(UART_CTL, 0);

	/* Disable Interrupts */
	cx23885_irq_disable_all(dev);
	cx_write(VID_A_INT_MSK, 0);
	cx_write(VID_B_INT_MSK, 0);
	cx_write(VID_C_INT_MSK, 0);
	cx_write(AUDIO_INT_INT_MSK, 0);
	cx_write(AUDIO_EXT_INT_MSK, 0);

}

static void cx23885_reset(struct cx23885_dev *dev)
{
	dprintk(1, "%s()\n", __func__);

	cx23885_shutdown(dev);

	cx_write(PCI_INT_STAT, 0xffffffff);
	cx_write(VID_A_INT_STAT, 0xffffffff);
	cx_write(VID_B_INT_STAT, 0xffffffff);
	cx_write(VID_C_INT_STAT, 0xffffffff);
	cx_write(AUDIO_INT_INT_STAT, 0xffffffff);
	cx_write(AUDIO_EXT_INT_STAT, 0xffffffff);
	cx_write(CLK_DELAY, cx_read(CLK_DELAY) & 0x80000000);
	cx_write(PAD_CTRL, 0x00500300);

	/* clear dma in progress */
	cx23885_clear_bridge_error(dev);
	msleep(100);

	cx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH01],
		720*4, 0);
	cx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH02], 128, 0);
	cx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH03],
		188*4, 0);
	cx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH04], 128, 0);
	cx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH05], 128, 0);
	cx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH06],
		188*4, 0);
	cx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH07], 128, 0);
	cx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH08], 128, 0);
	cx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH09], 128, 0);

	cx23885_gpio_setup(dev);

	cx23885_irq_get_mask(dev);

	/* clear dma in progress */
	cx23885_clear_bridge_error(dev);
}


static int cx23885_pci_quirks(struct cx23885_dev *dev)
{
	dprintk(1, "%s()\n", __func__);

	/* The cx23885 bridge has a weird bug which causes NMI to be asserted
	 * when DMA begins if RDR_TLCTL0 bit4 is not cleared. It does not
	 * occur on the cx23887 bridge.
	 */
	if (dev->bridge == CX23885_BRIDGE_885)
		cx_clear(RDR_TLCTL0, 1 << 4);

	/* clear dma in progress */
	cx23885_clear_bridge_error(dev);
	return 0;
}

static int get_resources(struct cx23885_dev *dev)
{
	if (request_mem_region(pci_resource_start(dev->pci, 0),
			       pci_resource_len(dev->pci, 0),
			       dev->name))
		return 0;

	pr_err("%s: can't get MMIO memory @ 0x%llx\n",
	       dev->name, (unsigned long long)pci_resource_start(dev->pci, 0));

	return -EBUSY;
}

static int cx23885_init_tsport(struct cx23885_dev *dev,
	struct cx23885_tsport *port, int portno)
{
	dprintk(1, "%s(portno=%d)\n", __func__, portno);

	/* Transport bus init dma queue  - Common settings */
	port->dma_ctl_val        = 0x11; /* Enable RISC controller and Fifo */
	port->ts_int_msk_val     = 0x1111; /* TS port bits for RISC */
	port->vld_misc_val       = 0x0;
	port->hw_sop_ctrl_val    = (0x47 << 16 | 188 << 4);

	spin_lock_init(&port->slock);
	port->dev = dev;
	port->nr = portno;

	INIT_LIST_HEAD(&port->mpegq.active);
	mutex_init(&port->frontends.lock);
	INIT_LIST_HEAD(&port->frontends.felist);
	port->frontends.active_fe_id = 0;

	/* This should be hardcoded allow a single frontend
	 * attachment to this tsport, keeping the -dvb.c
	 * code clean and safe.
	 */
	if (!port->num_frontends)
		port->num_frontends = 1;

	switch (portno) {
	case 1:
		port->reg_gpcnt          = VID_B_GPCNT;
		port->reg_gpcnt_ctl      = VID_B_GPCNT_CTL;
		port->reg_dma_ctl        = VID_B_DMA_CTL;
		port->reg_lngth          = VID_B_LNGTH;
		port->reg_hw_sop_ctrl    = VID_B_HW_SOP_CTL;
		port->reg_gen_ctrl       = VID_B_GEN_CTL;
		port->reg_bd_pkt_status  = VID_B_BD_PKT_STATUS;
		port->reg_sop_status     = VID_B_SOP_STATUS;
		port->reg_fifo_ovfl_stat = VID_B_FIFO_OVFL_STAT;
		port->reg_vld_misc       = VID_B_VLD_MISC;
		port->reg_ts_clk_en      = VID_B_TS_CLK_EN;
		port->reg_src_sel        = VID_B_SRC_SEL;
		port->reg_ts_int_msk     = VID_B_INT_MSK;
		port->reg_ts_int_stat    = VID_B_INT_STAT;
		port->sram_chno          = SRAM_CH03; /* VID_B */
		port->pci_irqmask        = 0x02; /* VID_B bit1 */
		break;
	case 2:
		port->reg_gpcnt          = VID_C_GPCNT;
		port->reg_gpcnt_ctl      = VID_C_GPCNT_CTL;
		port->reg_dma_ctl        = VID_C_DMA_CTL;
		port->reg_lngth          = VID_C_LNGTH;
		port->reg_hw_sop_ctrl    = VID_C_HW_SOP_CTL;
		port->reg_gen_ctrl       = VID_C_GEN_CTL;
		port->reg_bd_pkt_status  = VID_C_BD_PKT_STATUS;
		port->reg_sop_status     = VID_C_SOP_STATUS;
		port->reg_fifo_ovfl_stat = VID_C_FIFO_OVFL_STAT;
		port->reg_vld_misc       = VID_C_VLD_MISC;
		port->reg_ts_clk_en      = VID_C_TS_CLK_EN;
		port->reg_src_sel        = 0;
		port->reg_ts_int_msk     = VID_C_INT_MSK;
		port->reg_ts_int_stat    = VID_C_INT_STAT;
		port->sram_chno          = SRAM_CH06; /* VID_C */
		port->pci_irqmask        = 0x04; /* VID_C bit2 */
		break;
	default:
		BUG();
	}

	return 0;
}

static void cx23885_dev_checkrevision(struct cx23885_dev *dev)
{
	switch (cx_read(RDR_CFG2) & 0xff) {
	case 0x00:
		/* cx23885 */
		dev->hwrevision = 0xa0;
		break;
	case 0x01:
		/* CX23885-12Z */
		dev->hwrevision = 0xa1;
		break;
	case 0x02:
		/* CX23885-13Z/14Z */
		dev->hwrevision = 0xb0;
		break;
	case 0x03:
		if (dev->pci->device == 0x8880) {
			/* CX23888-21Z/22Z */
			dev->hwrevision = 0xc0;
		} else {
			/* CX23885-14Z */
			dev->hwrevision = 0xa4;
		}
		break;
	case 0x04:
		if (dev->pci->device == 0x8880) {
			/* CX23888-31Z */
			dev->hwrevision = 0xd0;
		} else {
			/* CX23885-15Z, CX23888-31Z */
			dev->hwrevision = 0xa5;
		}
		break;
	case 0x0e:
		/* CX23887-15Z */
		dev->hwrevision = 0xc0;
		break;
	case 0x0f:
		/* CX23887-14Z */
		dev->hwrevision = 0xb1;
		break;
	default:
		pr_err("%s() New hardware revision found 0x%x\n",
		       __func__, dev->hwrevision);
	}
	if (dev->hwrevision)
		pr_info("%s() Hardware revision = 0x%02x\n",
			__func__, dev->hwrevision);
	else
		pr_err("%s() Hardware revision unknown 0x%x\n",
		       __func__, dev->hwrevision);
}

/* Find the first v4l2_subdev member of the group id in hw */
struct v4l2_subdev *cx23885_find_hw(struct cx23885_dev *dev, u32 hw)
{
	struct v4l2_subdev *result = NULL;
	struct v4l2_subdev *sd;

	spin_lock(&dev->v4l2_dev.lock);
	v4l2_device_for_each_subdev(sd, &dev->v4l2_dev) {
		if (sd->grp_id == hw) {
			result = sd;
			break;
		}
	}
	spin_unlock(&dev->v4l2_dev.lock);
	return result;
}

static int cx23885_dev_setup(struct cx23885_dev *dev)
{
	int i;

	spin_lock_init(&dev->pci_irqmask_lock);
	spin_lock_init(&dev->slock);

	mutex_init(&dev->lock);
	mutex_init(&dev->gpio_lock);

	atomic_inc(&dev->refcount);

	dev->nr = cx23885_devcount++;
	sprintf(dev->name, "cx23885[%d]", dev->nr);

	/* Configure the internal memory */
	if (dev->pci->device == 0x8880) {
		/* Could be 887 or 888, assume an 888 default */
		dev->bridge = CX23885_BRIDGE_888;
		/* Apply a sensible clock frequency for the PCIe bridge */
		dev->clk_freq = 50000000;
		dev->sram_channels = cx23887_sram_channels;
	} else
	if (dev->pci->device == 0x8852) {
		dev->bridge = CX23885_BRIDGE_885;
		/* Apply a sensible clock frequency for the PCIe bridge */
		dev->clk_freq = 28000000;
		dev->sram_channels = cx23885_sram_channels;
	} else
		BUG();

	dprintk(1, "%s() Memory configured for PCIe bridge type %d\n",
		__func__, dev->bridge);

	/* board config */
	dev->board = UNSET;
	if (card[dev->nr] < cx23885_bcount)
		dev->board = card[dev->nr];
	for (i = 0; UNSET == dev->board  &&  i < cx23885_idcount; i++)
		if (dev->pci->subsystem_vendor == cx23885_subids[i].subvendor &&
		    dev->pci->subsystem_device == cx23885_subids[i].subdevice)
			dev->board = cx23885_subids[i].card;
	if (UNSET == dev->board) {
		dev->board = CX23885_BOARD_UNKNOWN;
		cx23885_card_list(dev);
	}

	if (dev->pci->device == 0x8852) {
		/* no DIF on cx23885, so no analog tuner support possible */
		if (dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC)
			dev->board = CX23885_BOARD_HAUPPAUGE_QUADHD_ATSC_885;
		else if (dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_DVB)
			dev->board = CX23885_BOARD_HAUPPAUGE_QUADHD_DVB_885;
	}

	/* If the user specific a clk freq override, apply it */
	if (cx23885_boards[dev->board].clk_freq > 0)
		dev->clk_freq = cx23885_boards[dev->board].clk_freq;

	if (dev->board == CX23885_BOARD_HAUPPAUGE_IMPACTVCBE &&
		dev->pci->subsystem_device == 0x7137) {
		/* Hauppauge ImpactVCBe device ID 0x7137 is populated
		 * with an 888, and a 25Mhz crystal, instead of the
		 * usual third overtone 50Mhz. The default clock rate must
		 * be overridden so the cx25840 is properly configured
		 */
		dev->clk_freq = 25000000;
	}

	dev->pci_bus  = dev->pci->bus->number;
	dev->pci_slot = PCI_SLOT(dev->pci->devfn);
	cx23885_irq_add(dev, 0x001f00);

	/* External Master 1 Bus */
	dev->i2c_bus[0].nr = 0;
	dev->i2c_bus[0].dev = dev;
	dev->i2c_bus[0].reg_stat  = I2C1_STAT;
	dev->i2c_bus[0].reg_ctrl  = I2C1_CTRL;
	dev->i2c_bus[0].reg_addr  = I2C1_ADDR;
	dev->i2c_bus[0].reg_rdata = I2C1_RDATA;
	dev->i2c_bus[0].reg_wdata = I2C1_WDATA;
	dev->i2c_bus[0].i2c_period = (0x9d << 24); /* 100kHz */

	/* External Master 2 Bus */
	dev->i2c_bus[1].nr = 1;
	dev->i2c_bus[1].dev = dev;
	dev->i2c_bus[1].reg_stat  = I2C2_STAT;
	dev->i2c_bus[1].reg_ctrl  = I2C2_CTRL;
	dev->i2c_bus[1].reg_addr  = I2C2_ADDR;
	dev->i2c_bus[1].reg_rdata = I2C2_RDATA;
	dev->i2c_bus[1].reg_wdata = I2C2_WDATA;
	dev->i2c_bus[1].i2c_period = (0x9d << 24); /* 100kHz */

	/* Internal Master 3 Bus */
	dev->i2c_bus[2].nr = 2;
	dev->i2c_bus[2].dev = dev;
	dev->i2c_bus[2].reg_stat  = I2C3_STAT;
	dev->i2c_bus[2].reg_ctrl  = I2C3_CTRL;
	dev->i2c_bus[2].reg_addr  = I2C3_ADDR;
	dev->i2c_bus[2].reg_rdata = I2C3_RDATA;
	dev->i2c_bus[2].reg_wdata = I2C3_WDATA;
	dev->i2c_bus[2].i2c_period = (0x07 << 24); /* 1.95MHz */

	if ((cx23885_boards[dev->board].portb == CX23885_MPEG_DVB) ||
		(cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER))
		cx23885_init_tsport(dev, &dev->ts1, 1);

	if ((cx23885_boards[dev->board].portc == CX23885_MPEG_DVB) ||
		(cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER))
		cx23885_init_tsport(dev, &dev->ts2, 2);

	if (get_resources(dev) < 0) {
		pr_err("CORE %s No more PCIe resources for subsystem: %04x:%04x\n",
		       dev->name, dev->pci->subsystem_vendor,
		       dev->pci->subsystem_device);

		cx23885_devcount--;
		return -ENODEV;
	}

	/* PCIe stuff */
	dev->lmmio = ioremap(pci_resource_start(dev->pci, 0),
			     pci_resource_len(dev->pci, 0));

	dev->bmmio = (u8 __iomem *)dev->lmmio;

	pr_info("CORE %s: subsystem: %04x:%04x, board: %s [card=%d,%s]\n",
		dev->name, dev->pci->subsystem_vendor,
		dev->pci->subsystem_device, cx23885_boards[dev->board].name,
		dev->board, card[dev->nr] == dev->board ?
		"insmod option" : "autodetected");

	cx23885_pci_quirks(dev);

	/* Assume some sensible defaults */
	dev->tuner_type = cx23885_boards[dev->board].tuner_type;
	dev->tuner_addr = cx23885_boards[dev->board].tuner_addr;
	dev->tuner_bus = cx23885_boards[dev->board].tuner_bus;
	dev->radio_type = cx23885_boards[dev->board].radio_type;
	dev->radio_addr = cx23885_boards[dev->board].radio_addr;

	dprintk(1, "%s() tuner_type = 0x%x tuner_addr = 0x%x tuner_bus = %d\n",
		__func__, dev->tuner_type, dev->tuner_addr, dev->tuner_bus);
	dprintk(1, "%s() radio_type = 0x%x radio_addr = 0x%x\n",
		__func__, dev->radio_type, dev->radio_addr);

	/* The cx23417 encoder has GPIO's that need to be initialised
	 * before DVB, so that demodulators and tuners are out of
	 * reset before DVB uses them.
	 */
	if ((cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) ||
		(cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER))
			cx23885_mc417_init(dev);

	/* init hardware */
	cx23885_reset(dev);

	cx23885_i2c_register(&dev->i2c_bus[0]);
	cx23885_i2c_register(&dev->i2c_bus[1]);
	cx23885_i2c_register(&dev->i2c_bus[2]);
	cx23885_card_setup(dev);
	call_all(dev, tuner, standby);
	cx23885_ir_init(dev);

	if (dev->board == CX23885_BOARD_VIEWCAST_460E) {
		/*
		 * GPIOs 9/8 are input detection bits for the breakout video
		 * (gpio 8) and audio (gpio 9) cables. When they're attached,
		 * this gpios are pulled high. Make sure these GPIOs are marked
		 * as inputs.
		 */
		cx23885_gpio_enable(dev, 0x300, 0);
	}

	if (cx23885_boards[dev->board].porta == CX23885_ANALOG_VIDEO) {
		if (cx23885_video_register(dev) < 0) {
			pr_err("%s() Failed to register analog video adapters on VID_A\n",
			       __func__);
		}
	}

	if (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB) {
		if (cx23885_boards[dev->board].num_fds_portb)
			dev->ts1.num_frontends =
				cx23885_boards[dev->board].num_fds_portb;
		if (cx23885_dvb_register(&dev->ts1) < 0) {
			pr_err("%s() Failed to register dvb adapters on VID_B\n",
			       __func__);
		}
	} else
	if (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) {
		if (cx23885_417_register(dev) < 0) {
			pr_err("%s() Failed to register 417 on VID_B\n",
			       __func__);
		}
	}

	if (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB) {
		if (cx23885_boards[dev->board].num_fds_portc)
			dev->ts2.num_frontends =
				cx23885_boards[dev->board].num_fds_portc;
		if (cx23885_dvb_register(&dev->ts2) < 0) {
			pr_err("%s() Failed to register dvb on VID_C\n",
			       __func__);
		}
	} else
	if (cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER) {
		if (cx23885_417_register(dev) < 0) {
			pr_err("%s() Failed to register 417 on VID_C\n",
			       __func__);
		}
	}

	cx23885_dev_checkrevision(dev);

	/* disable MSI for NetUP cards, otherwise CI is not working */
	if (cx23885_boards[dev->board].ci_type > 0)
		cx_clear(RDR_RDRCTL1, 1 << 8);

	switch (dev->board) {
	case CX23885_BOARD_TEVII_S470:
	case CX23885_BOARD_TEVII_S471:
		cx_clear(RDR_RDRCTL1, 1 << 8);
		break;
	}

	return 0;
}

static void cx23885_dev_unregister(struct cx23885_dev *dev)
{
	release_mem_region(pci_resource_start(dev->pci, 0),
			   pci_resource_len(dev->pci, 0));

	if (!atomic_dec_and_test(&dev->refcount))
		return;

	if (cx23885_boards[dev->board].porta == CX23885_ANALOG_VIDEO)
		cx23885_video_unregister(dev);

	if (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB)
		cx23885_dvb_unregister(&dev->ts1);

	if (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)
		cx23885_417_unregister(dev);

	if (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB)
		cx23885_dvb_unregister(&dev->ts2);

	if (cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER)
		cx23885_417_unregister(dev);

	cx23885_i2c_unregister(&dev->i2c_bus[2]);
	cx23885_i2c_unregister(&dev->i2c_bus[1]);
	cx23885_i2c_unregister(&dev->i2c_bus[0]);

	iounmap(dev->lmmio);
}

static __le32 *cx23885_risc_field(__le32 *rp, struct scatterlist *sglist,
			       unsigned int offset, u32 sync_line,
			       unsigned int bpl, unsigned int padding,
			       unsigned int lines,  unsigned int lpi, bool jump)
{
	struct scatterlist *sg;
	unsigned int line, todo, sol;


	if (jump) {
		*(rp++) = cpu_to_le32(RISC_JUMP);
		*(rp++) = cpu_to_le32(0);
		*(rp++) = cpu_to_le32(0); /* bits 63-32 */
	}

	/* sync instruction */
	if (sync_line != NO_SYNC_LINE)
		*(rp++) = cpu_to_le32(RISC_RESYNC | sync_line);

	/* scan lines */
	sg = sglist;
	for (line = 0; line < lines; line++) {
		while (offset && offset >= sg_dma_len(sg)) {
			offset -= sg_dma_len(sg);
			sg = sg_next(sg);
		}

		if (lpi && line > 0 && !(line % lpi))
			sol = RISC_SOL | RISC_IRQ1 | RISC_CNT_INC;
		else
			sol = RISC_SOL;

		if (bpl <= sg_dma_len(sg)-offset) {
			/* fits into current chunk */
			*(rp++) = cpu_to_le32(RISC_WRITE|sol|RISC_EOL|bpl);
			*(rp++) = cpu_to_le32(sg_dma_address(sg)+offset);
			*(rp++) = cpu_to_le32(0); /* bits 63-32 */
			offset += bpl;
		} else {
			/* scanline needs to be split */
			todo = bpl;
			*(rp++) = cpu_to_le32(RISC_WRITE|sol|
					    (sg_dma_len(sg)-offset));
			*(rp++) = cpu_to_le32(sg_dma_address(sg)+offset);
			*(rp++) = cpu_to_le32(0); /* bits 63-32 */
			todo -= (sg_dma_len(sg)-offset);
			offset = 0;
			sg = sg_next(sg);
			while (todo > sg_dma_len(sg)) {
				*(rp++) = cpu_to_le32(RISC_WRITE|
						    sg_dma_len(sg));
				*(rp++) = cpu_to_le32(sg_dma_address(sg));
				*(rp++) = cpu_to_le32(0); /* bits 63-32 */
				todo -= sg_dma_len(sg);
				sg = sg_next(sg);
			}
			*(rp++) = cpu_to_le32(RISC_WRITE|RISC_EOL|todo);
			*(rp++) = cpu_to_le32(sg_dma_address(sg));
			*(rp++) = cpu_to_le32(0); /* bits 63-32 */
			offset += todo;
		}
		offset += padding;
	}

	return rp;
}

int cx23885_risc_buffer(struct pci_dev *pci, struct cx23885_riscmem *risc,
			struct scatterlist *sglist, unsigned int top_offset,
			unsigned int bottom_offset, unsigned int bpl,
			unsigned int padding, unsigned int lines)
{
	u32 instructions, fields;
	__le32 *rp;

	fields = 0;
	if (UNSET != top_offset)
		fields++;
	if (UNSET != bottom_offset)
		fields++;

	/* estimate risc mem: worst case is one write per page border +
	   one write per scan line + syncs + jump (all 2 dwords).  Padding
	   can cause next bpl to start close to a page border.  First DMA
	   region may be smaller than PAGE_SIZE */
	/* write and jump need and extra dword */
	instructions  = fields * (1 + ((bpl + padding) * lines)
		/ PAGE_SIZE + lines);
	instructions += 5;
	risc->size = instructions * 12;
	risc->cpu = dma_alloc_coherent(&pci->dev, risc->size, &risc->dma,
				       GFP_KERNEL);
	if (risc->cpu == NULL)
		return -ENOMEM;

	/* write risc instructions */
	rp = risc->cpu;
	if (UNSET != top_offset)
		rp = cx23885_risc_field(rp, sglist, top_offset, 0,
					bpl, padding, lines, 0, true);
	if (UNSET != bottom_offset)
		rp = cx23885_risc_field(rp, sglist, bottom_offset, 0x200,
					bpl, padding, lines, 0, UNSET == top_offset);

	/* save pointer to jmp instruction address */
	risc->jmp = rp;
	BUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);
	return 0;
}

int cx23885_risc_databuffer(struct pci_dev *pci,
				   struct cx23885_riscmem *risc,
				   struct scatterlist *sglist,
				   unsigned int bpl,
				   unsigned int lines, unsigned int lpi)
{
	u32 instructions;
	__le32 *rp;

	/* estimate risc mem: worst case is one write per page border +
	   one write per scan line + syncs + jump (all 2 dwords).  Here
	   there is no padding and no sync.  First DMA region may be smaller
	   than PAGE_SIZE */
	/* Jump and write need an extra dword */
	instructions  = 1 + (bpl * lines) / PAGE_SIZE + lines;
	instructions += 4;

	risc->size = instructions * 12;
	risc->cpu = dma_alloc_coherent(&pci->dev, risc->size, &risc->dma,
				       GFP_KERNEL);
	if (risc->cpu == NULL)
		return -ENOMEM;

	/* write risc instructions */
	rp = risc->cpu;
	rp = cx23885_risc_field(rp, sglist, 0, NO_SYNC_LINE,
				bpl, 0, lines, lpi, lpi == 0);

	/* save pointer to jmp instruction address */
	risc->jmp = rp;
	BUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);
	return 0;
}

int cx23885_risc_vbibuffer(struct pci_dev *pci, struct cx23885_riscmem *risc,
			struct scatterlist *sglist, unsigned int top_offset,
			unsigned int bottom_offset, unsigned int bpl,
			unsigned int padding, unsigned int lines)
{
	u32 instructions, fields;
	__le32 *rp;

	fields = 0;
	if (UNSET != top_offset)
		fields++;
	if (UNSET != bottom_offset)
		fields++;

	/* estimate risc mem: worst case is one write per page border +
	   one write per scan line + syncs + jump (all 2 dwords).  Padding
	   can cause next bpl to start close to a page border.  First DMA
	   region may be smaller than PAGE_SIZE */
	/* write and jump need and extra dword */
	instructions  = fields * (1 + ((bpl + padding) * lines)
		/ PAGE_SIZE + lines);
	instructions += 5;
	risc->size = instructions * 12;
	risc->cpu = dma_alloc_coherent(&pci->dev, risc->size, &risc->dma,
				       GFP_KERNEL);
	if (risc->cpu == NULL)
		return -ENOMEM;
	/* write risc instructions */
	rp = risc->cpu;

	/* Sync to line 6, so US CC line 21 will appear in line '12'
	 * in the userland vbi payload */
	if (UNSET != top_offset)
		rp = cx23885_risc_field(rp, sglist, top_offset, 0,
					bpl, padding, lines, 0, true);

	if (UNSET != bottom_offset)
		rp = cx23885_risc_field(rp, sglist, bottom_offset, 0x200,
					bpl, padding, lines, 0, UNSET == top_offset);



	/* save pointer to jmp instruction address */
	risc->jmp = rp;
	BUG_ON((risc->jmp - risc->cpu + 2) * sizeof(*risc->cpu) > risc->size);
	return 0;
}


void cx23885_free_buffer(struct cx23885_dev *dev, struct cx23885_buffer *buf)
{
	struct cx23885_riscmem *risc = &buf->risc;

	dma_free_coherent(&dev->pci->dev, risc->size, risc->cpu, risc->dma);
}

static void cx23885_tsport_reg_dump(struct cx23885_tsport *port)
{
	struct cx23885_dev *dev = port->dev;

	dprintk(1, "%s() Register Dump\n", __func__);
	dprintk(1, "%s() DEV_CNTRL2               0x%08X\n", __func__,
		cx_read(DEV_CNTRL2));
	dprintk(1, "%s() PCI_INT_MSK              0x%08X\n", __func__,
		cx23885_irq_get_mask(dev));
	dprintk(1, "%s() AUD_INT_INT_MSK          0x%08X\n", __func__,
		cx_read(AUDIO_INT_INT_MSK));
	dprintk(1, "%s() AUD_INT_DMA_CTL          0x%08X\n", __func__,
		cx_read(AUD_INT_DMA_CTL));
	dprintk(1, "%s() AUD_EXT_INT_MSK          0x%08X\n", __func__,
		cx_read(AUDIO_EXT_INT_MSK));
	dprintk(1, "%s() AUD_EXT_DMA_CTL          0x%08X\n", __func__,
		cx_read(AUD_EXT_DMA_CTL));
	dprintk(1, "%s() PAD_CTRL                 0x%08X\n", __func__,
		cx_read(PAD_CTRL));
	dprintk(1, "%s() ALT_PIN_OUT_SEL          0x%08X\n", __func__,
		cx_read(ALT_PIN_OUT_SEL));
	dprintk(1, "%s() GPIO2                    0x%08X\n", __func__,
		cx_read(GPIO2));
	dprintk(1, "%s() gpcnt(0x%08X)          0x%08X\n", __func__,
		port->reg_gpcnt, cx_read(port->reg_gpcnt));
	dprintk(1, "%s() gpcnt_ctl(0x%08X)      0x%08x\n", __func__,
		port->reg_gpcnt_ctl, cx_read(port->reg_gpcnt_ctl));
	dprintk(1, "%s() dma_ctl(0x%08X)        0x%08x\n", __func__,
		port->reg_dma_ctl, cx_read(port->reg_dma_ctl));
	if (port->reg_src_sel)
		dprintk(1, "%s() src_sel(0x%08X)        0x%08x\n", __func__,
			port->reg_src_sel, cx_read(port->reg_src_sel));
	dprintk(1, "%s() lngth(0x%08X)          0x%08x\n", __func__,
		port->reg_lngth, cx_read(port->reg_lngth));
	dprintk(1, "%s() hw_sop_ctrl(0x%08X)    0x%08x\n", __func__,
		port->reg_hw_sop_ctrl, cx_read(port->reg_hw_sop_ctrl));
	dprintk(1, "%s() gen_ctrl(0x%08X)       0x%08x\n", __func__,
		port->reg_gen_ctrl, cx_read(port->reg_gen_ctrl));
	dprintk(1, "%s() bd_pkt_status(0x%08X)  0x%08x\n", __func__,
		port->reg_bd_pkt_status, cx_read(port->reg_bd_pkt_status));
	dprintk(1, "%s() sop_status(0x%08X)     0x%08x\n", __func__,
		port->reg_sop_status, cx_read(port->reg_sop_status));
	dprintk(1, "%s() fifo_ovfl_stat(0x%08X) 0x%08x\n", __func__,
		port->reg_fifo_ovfl_stat, cx_read(port->reg_fifo_ovfl_stat));
	dprintk(1, "%s() vld_misc(0x%08X)       0x%08x\n", __func__,
		port->reg_vld_misc, cx_read(port->reg_vld_misc));
	dprintk(1, "%s() ts_clk_en(0x%08X)      0x%08x\n", __func__,
		port->reg_ts_clk_en, cx_read(port->reg_ts_clk_en));
	dprintk(1, "%s() ts_int_msk(0x%08X)     0x%08x\n", __func__,
		port->reg_ts_int_msk, cx_read(port->reg_ts_int_msk));
	dprintk(1, "%s() ts_int_status(0x%08X)  0x%08x\n", __func__,
		port->reg_ts_int_stat, cx_read(port->reg_ts_int_stat));
	dprintk(1, "%s() PCI_INT_STAT           0x%08X\n", __func__,
		cx_read(PCI_INT_STAT));
	dprintk(1, "%s() VID_B_INT_MSTAT        0x%08X\n", __func__,
		cx_read(VID_B_INT_MSTAT));
	dprintk(1, "%s() VID_B_INT_SSTAT        0x%08X\n", __func__,
		cx_read(VID_B_INT_SSTAT));
	dprintk(1, "%s() VID_C_INT_MSTAT        0x%08X\n", __func__,
		cx_read(VID_C_INT_MSTAT));
	dprintk(1, "%s() VID_C_INT_SSTAT        0x%08X\n", __func__,
		cx_read(VID_C_INT_SSTAT));
}

int cx23885_start_dma(struct cx23885_tsport *port,
			     struct cx23885_dmaqueue *q,
			     struct cx23885_buffer   *buf)
{
	struct cx23885_dev *dev = port->dev;
	u32 reg;

	dprintk(1, "%s() w: %d, h: %d, f: %d\n", __func__,
		dev->width, dev->height, dev->field);

	/* clear dma in progress */
	cx23885_clear_bridge_error(dev);

	/* Stop the fifo and risc engine for this port */
	cx_clear(port->reg_dma_ctl, port->dma_ctl_val);

	/* setup fifo + format */
	cx23885_sram_channel_setup(dev,
				   &dev->sram_channels[port->sram_chno],
				   port->ts_packet_size, buf->risc.dma);
	if (debug > 5) {
		cx23885_sram_channel_dump(dev,
			&dev->sram_channels[port->sram_chno]);
		cx23885_risc_disasm(port, &buf->risc);
	}

	/* write TS length to chip */
	cx_write(port->reg_lngth, port->ts_packet_size);

	if ((!(cx23885_boards[dev->board].portb & CX23885_MPEG_DVB)) &&
		(!(cx23885_boards[dev->board].portc & CX23885_MPEG_DVB))) {
		pr_err("%s() Unsupported .portb/c (0x%08x)/(0x%08x)\n",
			__func__,
			cx23885_boards[dev->board].portb,
			cx23885_boards[dev->board].portc);
		return -EINVAL;
	}

	if (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)
		cx23885_av_clk(dev, 0);

	udelay(100);

	/* If the port supports SRC SELECT, configure it */
	if (port->reg_src_sel)
		cx_write(port->reg_src_sel, port->src_sel_val);

	cx_write(port->reg_hw_sop_ctrl, port->hw_sop_ctrl_val);
	cx_write(port->reg_ts_clk_en, port->ts_clk_en_val);
	cx_write(port->reg_vld_misc, port->vld_misc_val);
	cx_write(port->reg_gen_ctrl, port->gen_ctrl_val);
	udelay(100);

	/* NOTE: this is 2 (reserved) for portb, does it matter? */
	/* reset counter to zero */
	cx_write(port->reg_gpcnt_ctl, 3);
	q->count = 0;

	/* Set VIDB pins to input */
	if (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB) {
		reg = cx_read(PAD_CTRL);
		reg &= ~0x3; /* Clear TS1_OE & TS1_SOP_OE */
		cx_write(PAD_CTRL, reg);
	}

	/* Set VIDC pins to input */
	if (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB) {
		reg = cx_read(PAD_CTRL);
		reg &= ~0x4; /* Clear TS2_SOP_OE */
		cx_write(PAD_CTRL, reg);
	}

	if (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) {

		reg = cx_read(PAD_CTRL);
		reg = reg & ~0x1;    /* Clear TS1_OE */

		/* FIXME, bit 2 writing here is questionable */
		/* set TS1_SOP_OE and TS1_OE_HI */
		reg = reg | 0xa;
		cx_write(PAD_CTRL, reg);

		/* Sets MOE_CLK_DIS to disable MoE clock */
		/* sets MCLK_DLY_SEL/BCLK_DLY_SEL to 1 buffer delay each */
		cx_write(CLK_DELAY, cx_read(CLK_DELAY) | 0x80000011);

		/* ALT_GPIO_ALT_SET: GPIO[0]
		 * IR_ALT_TX_SEL: GPIO[1]
		 * GPIO1_ALT_SEL: VIP_656_DATA[0]
		 * GPIO0_ALT_SEL: VIP_656_CLK
		 */
		cx_write(ALT_PIN_OUT_SEL, 0x10100045);
	}

	switch (dev->bridge) {
	case CX23885_BRIDGE_885:
	case CX23885_BRIDGE_887:
	case CX23885_BRIDGE_888:
		/* enable irqs */
		dprintk(1, "%s() enabling TS int's and DMA\n", __func__);
		/* clear dma in progress */
		cx23885_clear_bridge_error(dev);
		cx_set(port->reg_ts_int_msk,  port->ts_int_msk_val);
		cx_set(port->reg_dma_ctl, port->dma_ctl_val);

		/* clear dma in progress */
		cx23885_clear_bridge_error(dev);
		cx23885_irq_add(dev, port->pci_irqmask);
		cx23885_irq_enable_all(dev);

		/* clear dma in progress */
		cx23885_clear_bridge_error(dev);
		break;
	default:
		BUG();
	}

	cx_set(DEV_CNTRL2, (1<<5)); /* Enable RISC controller */
	/* clear dma in progress */
	cx23885_clear_bridge_error(dev);

	if (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)
		cx23885_av_clk(dev, 1);

	if (debug > 4)
		cx23885_tsport_reg_dump(port);

	cx23885_irq_get_mask(dev);

	/* clear dma in progress */
	cx23885_clear_bridge_error(dev);

	return 0;
}

static int cx23885_stop_dma(struct cx23885_tsport *port)
{
	struct cx23885_dev *dev = port->dev;
	u32 reg;
	int delay = 0;
	uint32_t reg1_val;
	uint32_t reg2_val;

	dprintk(1, "%s()\n", __func__);

	/* Stop interrupts and DMA */
	cx_clear(port->reg_ts_int_msk, port->ts_int_msk_val);
	cx_clear(port->reg_dma_ctl, port->dma_ctl_val);
	/* just in case wait for any dma to complete before allowing dealloc */
	mdelay(20);
	for (delay = 0; delay < 100; delay++) {
		reg1_val = cx_read(TC_REQ);
		reg2_val = cx_read(TC_REQ_SET);
		if (reg1_val == 0 || reg2_val == 0)
			break;
		mdelay(1);
	}
	dev_dbg(&dev->pci->dev, "delay=%d reg1=0x%08x reg2=0x%08x\n",
		delay, reg1_val, reg2_val);

	if (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER) {
		reg = cx_read(PAD_CTRL);

		/* Set TS1_OE */
		reg = reg | 0x1;

		/* clear TS1_SOP_OE and TS1_OE_HI */
		reg = reg & ~0xa;
		cx_write(PAD_CTRL, reg);
		cx_write(port->reg_src_sel, 0);
		cx_write(port->reg_gen_ctrl, 8);
	}

	if (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)
		cx23885_av_clk(dev, 0);

	return 0;
}

/* ------------------------------------------------------------------ */

int cx23885_buf_prepare(struct cx23885_buffer *buf, struct cx23885_tsport *port)
{
	struct cx23885_dev *dev = port->dev;
	int size = port->ts_packet_size * port->ts_packet_count;
	struct sg_table *sgt = vb2_dma_sg_plane_desc(&buf->vb.vb2_buf, 0);

	dprintk(1, "%s: %p\n", __func__, buf);
	if (vb2_plane_size(&buf->vb.vb2_buf, 0) < size)
		return -EINVAL;
	vb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);

	cx23885_risc_databuffer(dev->pci, &buf->risc,
				sgt->sgl,
				port->ts_packet_size, port->ts_packet_count, 0);
	return 0;
}

/*
 * The risc program for each buffer works as follows: it starts with a simple
 * 'JUMP to addr + 12', which is effectively a NOP. Then the code to DMA the
 * buffer follows and at the end we have a JUMP back to the start + 12 (skipping
 * the initial JUMP).
 *
 * This is the risc program of the first buffer to be queued if the active list
 * is empty and it just keeps DMAing this buffer without generating any
 * interrupts.
 *
 * If a new buffer is added then the initial JUMP in the code for that buffer
 * will generate an interrupt which signals that the previous buffer has been
 * DMAed successfully and that it can be returned to userspace.
 *
 * It also sets the final jump of the previous buffer to the start of the new
 * buffer, thus chaining the new buffer into the DMA chain. This is a single
 * atomic u32 write, so there is no race condition.
 *
 * The end-result of all this that you only get an interrupt when a buffer
 * is ready, so the control flow is very easy.
 */
void cx23885_buf_queue(struct cx23885_tsport *port, struct cx23885_buffer *buf)
{
	struct cx23885_buffer    *prev;
	struct cx23885_dev *dev = port->dev;
	struct cx23885_dmaqueue  *cx88q = &port->mpegq;
	unsigned long flags;

	buf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 12);
	buf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);
	buf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 12);
	buf->risc.jmp[2] = cpu_to_le32(0); /* bits 63-32 */

	spin_lock_irqsave(&dev->slock, flags);
	if (list_empty(&cx88q->active)) {
		list_add_tail(&buf->queue, &cx88q->active);
		dprintk(1, "[%p/%d] %s - first active\n",
			buf, buf->vb.vb2_buf.index, __func__);
	} else {
		buf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);
		prev = list_entry(cx88q->active.prev, struct cx23885_buffer,
				  queue);
		list_add_tail(&buf->queue, &cx88q->active);
		prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
		dprintk(1, "[%p/%d] %s - append to active\n",
			 buf, buf->vb.vb2_buf.index, __func__);
	}
	spin_unlock_irqrestore(&dev->slock, flags);
}

/* ----------------------------------------------------------- */

static void do_cancel_buffers(struct cx23885_tsport *port, char *reason)
{
	struct cx23885_dmaqueue *q = &port->mpegq;
	struct cx23885_buffer *buf;
	unsigned long flags;

	spin_lock_irqsave(&port->slock, flags);
	while (!list_empty(&q->active)) {
		buf = list_entry(q->active.next, struct cx23885_buffer,
				 queue);
		list_del(&buf->queue);
		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
		dprintk(1, "[%p/%d] %s - dma=0x%08lx\n",
			buf, buf->vb.vb2_buf.index, reason,
			(unsigned long)buf->risc.dma);
	}
	spin_unlock_irqrestore(&port->slock, flags);
}

void cx23885_cancel_buffers(struct cx23885_tsport *port)
{
	dprintk(1, "%s()\n", __func__);
	cx23885_stop_dma(port);
	do_cancel_buffers(port, "cancel");
}

int cx23885_irq_417(struct cx23885_dev *dev, u32 status)
{
	/* FIXME: port1 assumption here. */
	struct cx23885_tsport *port = &dev->ts1;
	int count = 0;
	int handled = 0;

	if (status == 0)
		return handled;

	count = cx_read(port->reg_gpcnt);
	dprintk(7, "status: 0x%08x  mask: 0x%08x count: 0x%x\n",
		status, cx_read(port->reg_ts_int_msk), count);

	if ((status & VID_B_MSK_BAD_PKT)         ||
		(status & VID_B_MSK_OPC_ERR)     ||
		(status & VID_B_MSK_VBI_OPC_ERR) ||
		(status & VID_B_MSK_SYNC)        ||
		(status & VID_B_MSK_VBI_SYNC)    ||
		(status & VID_B_MSK_OF)          ||
		(status & VID_B_MSK_VBI_OF)) {
		pr_err("%s: V4L mpeg risc op code error, status = 0x%x\n",
		       dev->name, status);
		if (status & VID_B_MSK_BAD_PKT)
			dprintk(1, "        VID_B_MSK_BAD_PKT\n");
		if (status & VID_B_MSK_OPC_ERR)
			dprintk(1, "        VID_B_MSK_OPC_ERR\n");
		if (status & VID_B_MSK_VBI_OPC_ERR)
			dprintk(1, "        VID_B_MSK_VBI_OPC_ERR\n");
		if (status & VID_B_MSK_SYNC)
			dprintk(1, "        VID_B_MSK_SYNC\n");
		if (status & VID_B_MSK_VBI_SYNC)
			dprintk(1, "        VID_B_MSK_VBI_SYNC\n");
		if (status & VID_B_MSK_OF)
			dprintk(1, "        VID_B_MSK_OF\n");
		if (status & VID_B_MSK_VBI_OF)
			dprintk(1, "        VID_B_MSK_VBI_OF\n");

		cx_clear(port->reg_dma_ctl, port->dma_ctl_val);
		cx23885_sram_channel_dump(dev,
			&dev->sram_channels[port->sram_chno]);
		cx23885_417_check_encoder(dev);
	} else if (status & VID_B_MSK_RISCI1) {
		dprintk(7, "        VID_B_MSK_RISCI1\n");
		spin_lock(&port->slock);
		cx23885_wakeup(port, &port->mpegq, count);
		spin_unlock(&port->slock);
	}
	if (status) {
		cx_write(port->reg_ts_int_stat, status);
		handled = 1;
	}

	return handled;
}

static int cx23885_irq_ts(struct cx23885_tsport *port, u32 status)
{
	struct cx23885_dev *dev = port->dev;
	int handled = 0;
	u32 count;

	if ((status & VID_BC_MSK_OPC_ERR) ||
		(status & VID_BC_MSK_BAD_PKT) ||
		(status & VID_BC_MSK_SYNC) ||
		(status & VID_BC_MSK_OF)) {

		if (status & VID_BC_MSK_OPC_ERR)
			dprintk(7, " (VID_BC_MSK_OPC_ERR 0x%08x)\n",
				VID_BC_MSK_OPC_ERR);

		if (status & VID_BC_MSK_BAD_PKT)
			dprintk(7, " (VID_BC_MSK_BAD_PKT 0x%08x)\n",
				VID_BC_MSK_BAD_PKT);

		if (status & VID_BC_MSK_SYNC)
			dprintk(7, " (VID_BC_MSK_SYNC    0x%08x)\n",
				VID_BC_MSK_SYNC);

		if (status & VID_BC_MSK_OF)
			dprintk(7, " (VID_BC_MSK_OF      0x%08x)\n",
				VID_BC_MSK_OF);

		pr_err("%s: mpeg risc op code error\n", dev->name);

		cx_clear(port->reg_dma_ctl, port->dma_ctl_val);
		cx23885_sram_channel_dump(dev,
			&dev->sram_channels[port->sram_chno]);

	} else if (status & VID_BC_MSK_RISCI1) {

		dprintk(7, " (RISCI1            0x%08x)\n", VID_BC_MSK_RISCI1);

		spin_lock(&port->slock);
		count = cx_read(port->reg_gpcnt);
		cx23885_wakeup(port, &port->mpegq, count);
		spin_unlock(&port->slock);

	}
	if (status) {
		cx_write(port->reg_ts_int_stat, status);
		handled = 1;
	}

	return handled;
}

static irqreturn_t cx23885_irq(int irq, void *dev_id)
{
	struct cx23885_dev *dev = dev_id;
	struct cx23885_tsport *ts1 = &dev->ts1;
	struct cx23885_tsport *ts2 = &dev->ts2;
	u32 pci_status, pci_mask;
	u32 vida_status, vida_mask;
	u32 audint_status, audint_mask;
	u32 ts1_status, ts1_mask;
	u32 ts2_status, ts2_mask;
	int vida_count = 0, ts1_count = 0, ts2_count = 0, handled = 0;
	int audint_count = 0;
	bool subdev_handled;

	pci_status = cx_read(PCI_INT_STAT);
	pci_mask = cx23885_irq_get_mask(dev);
	if ((pci_status & pci_mask) == 0) {
		dprintk(7, "pci_status: 0x%08x  pci_mask: 0x%08x\n",
			pci_status, pci_mask);
		goto out;
	}

	vida_status = cx_read(VID_A_INT_STAT);
	vida_mask = cx_read(VID_A_INT_MSK);
	audint_status = cx_read(AUDIO_INT_INT_STAT);
	audint_mask = cx_read(AUDIO_INT_INT_MSK);
	ts1_status = cx_read(VID_B_INT_STAT);
	ts1_mask = cx_read(VID_B_INT_MSK);
	ts2_status = cx_read(VID_C_INT_STAT);
	ts2_mask = cx_read(VID_C_INT_MSK);

	if (((pci_status & pci_mask) == 0) &&
		((ts2_status & ts2_mask) == 0) &&
		((ts1_status & ts1_mask) == 0))
		goto out;

	vida_count = cx_read(VID_A_GPCNT);
	audint_count = cx_read(AUD_INT_A_GPCNT);
	ts1_count = cx_read(ts1->reg_gpcnt);
	ts2_count = cx_read(ts2->reg_gpcnt);
	dprintk(7, "pci_status: 0x%08x  pci_mask: 0x%08x\n",
		pci_status, pci_mask);
	dprintk(7, "vida_status: 0x%08x vida_mask: 0x%08x count: 0x%x\n",
		vida_status, vida_mask, vida_count);
	dprintk(7, "audint_status: 0x%08x audint_mask: 0x%08x count: 0x%x\n",
		audint_status, audint_mask, audint_count);
	dprintk(7, "ts1_status: 0x%08x  ts1_mask: 0x%08x count: 0x%x\n",
		ts1_status, ts1_mask, ts1_count);
	dprintk(7, "ts2_status: 0x%08x  ts2_mask: 0x%08x count: 0x%x\n",
		ts2_status, ts2_mask, ts2_count);

	if (pci_status & (PCI_MSK_RISC_RD | PCI_MSK_RISC_WR |
			  PCI_MSK_AL_RD   | PCI_MSK_AL_WR   | PCI_MSK_APB_DMA |
			  PCI_MSK_VID_C   | PCI_MSK_VID_B   | PCI_MSK_VID_A   |
			  PCI_MSK_AUD_INT | PCI_MSK_AUD_EXT |
			  PCI_MSK_GPIO0   | PCI_MSK_GPIO1   |
			  PCI_MSK_AV_CORE | PCI_MSK_IR)) {

		if (pci_status & PCI_MSK_RISC_RD)
			dprintk(7, " (PCI_MSK_RISC_RD   0x%08x)\n",
				PCI_MSK_RISC_RD);

		if (pci_status & PCI_MSK_RISC_WR)
			dprintk(7, " (PCI_MSK_RISC_WR   0x%08x)\n",
				PCI_MSK_RISC_WR);

		if (pci_status & PCI_MSK_AL_RD)
			dprintk(7, " (PCI_MSK_AL_RD     0x%08x)\n",
				PCI_MSK_AL_RD);

		if (pci_status & PCI_MSK_AL_WR)
			dprintk(7, " (PCI_MSK_AL_WR     0x%08x)\n",
				PCI_MSK_AL_WR);

		if (pci_status & PCI_MSK_APB_DMA)
			dprintk(7, " (PCI_MSK_APB_DMA   0x%08x)\n",
				PCI_MSK_APB_DMA);

		if (pci_status & PCI_MSK_VID_C)
			dprintk(7, " (PCI_MSK_VID_C     0x%08x)\n",
				PCI_MSK_VID_C);

		if (pci_status & PCI_MSK_VID_B)
			dprintk(7, " (PCI_MSK_VID_B     0x%08x)\n",
				PCI_MSK_VID_B);

		if (pci_status & PCI_MSK_VID_A)
			dprintk(7, " (PCI_MSK_VID_A     0x%08x)\n",
				PCI_MSK_VID_A);

		if (pci_status & PCI_MSK_AUD_INT)
			dprintk(7, " (PCI_MSK_AUD_INT   0x%08x)\n",
				PCI_MSK_AUD_INT);

		if (pci_status & PCI_MSK_AUD_EXT)
			dprintk(7, " (PCI_MSK_AUD_EXT   0x%08x)\n",
				PCI_MSK_AUD_EXT);

		if (pci_status & PCI_MSK_GPIO0)
			dprintk(7, " (PCI_MSK_GPIO0     0x%08x)\n",
				PCI_MSK_GPIO0);

		if (pci_status & PCI_MSK_GPIO1)
			dprintk(7, " (PCI_MSK_GPIO1     0x%08x)\n",
				PCI_MSK_GPIO1);

		if (pci_status & PCI_MSK_AV_CORE)
			dprintk(7, " (PCI_MSK_AV_CORE   0x%08x)\n",
				PCI_MSK_AV_CORE);

		if (pci_status & PCI_MSK_IR)
			dprintk(7, " (PCI_MSK_IR        0x%08x)\n",
				PCI_MSK_IR);
	}

	if (cx23885_boards[dev->board].ci_type == 1 &&
			(pci_status & (PCI_MSK_GPIO1 | PCI_MSK_GPIO0)))
		handled += netup_ci_slot_status(dev, pci_status);

	if (cx23885_boards[dev->board].ci_type == 2 &&
			(pci_status & PCI_MSK_GPIO0))
		handled += altera_ci_irq(dev);

	if (ts1_status) {
		if (cx23885_boards[dev->board].portb == CX23885_MPEG_DVB)
			handled += cx23885_irq_ts(ts1, ts1_status);
		else
		if (cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER)
			handled += cx23885_irq_417(dev, ts1_status);
	}

	if (ts2_status) {
		if (cx23885_boards[dev->board].portc == CX23885_MPEG_DVB)
			handled += cx23885_irq_ts(ts2, ts2_status);
		else
		if (cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER)
			handled += cx23885_irq_417(dev, ts2_status);
	}

	if (vida_status)
		handled += cx23885_video_irq(dev, vida_status);

	if (audint_status)
		handled += cx23885_audio_irq(dev, audint_status, audint_mask);

	if (pci_status & PCI_MSK_IR) {
		subdev_handled = false;
		v4l2_subdev_call(dev->sd_ir, core, interrupt_service_routine,
				 pci_status, &subdev_handled);
		if (subdev_handled)
			handled++;
	}

	if ((pci_status & pci_mask) & PCI_MSK_AV_CORE) {
		cx23885_irq_disable(dev, PCI_MSK_AV_CORE);
		schedule_work(&dev->cx25840_work);
		handled++;
	}

	if (handled)
		cx_write(PCI_INT_STAT, pci_status & pci_mask);
out:
	return IRQ_RETVAL(handled);
}

static void cx23885_v4l2_dev_notify(struct v4l2_subdev *sd,
				    unsigned int notification, void *arg)
{
	struct cx23885_dev *dev;

	if (sd == NULL)
		return;

	dev = to_cx23885(sd->v4l2_dev);

	switch (notification) {
	case V4L2_SUBDEV_IR_RX_NOTIFY: /* Possibly called in an IRQ context */
		if (sd == dev->sd_ir)
			cx23885_ir_rx_v4l2_dev_notify(sd, *(u32 *)arg);
		break;
	case V4L2_SUBDEV_IR_TX_NOTIFY: /* Possibly called in an IRQ context */
		if (sd == dev->sd_ir)
			cx23885_ir_tx_v4l2_dev_notify(sd, *(u32 *)arg);
		break;
	}
}

static void cx23885_v4l2_dev_notify_init(struct cx23885_dev *dev)
{
	INIT_WORK(&dev->cx25840_work, cx23885_av_work_handler);
	INIT_WORK(&dev->ir_rx_work, cx23885_ir_rx_work_handler);
	INIT_WORK(&dev->ir_tx_work, cx23885_ir_tx_work_handler);
	dev->v4l2_dev.notify = cx23885_v4l2_dev_notify;
}

static inline int encoder_on_portb(struct cx23885_dev *dev)
{
	return cx23885_boards[dev->board].portb == CX23885_MPEG_ENCODER;
}

static inline int encoder_on_portc(struct cx23885_dev *dev)
{
	return cx23885_boards[dev->board].portc == CX23885_MPEG_ENCODER;
}

/* Mask represents 32 different GPIOs, GPIO's are split into multiple
 * registers depending on the board configuration (and whether the
 * 417 encoder (wi it's own GPIO's) are present. Each GPIO bit will
 * be pushed into the correct hardware register, regardless of the
 * physical location. Certain registers are shared so we sanity check
 * and report errors if we think we're tampering with a GPIo that might
 * be assigned to the encoder (and used for the host bus).
 *
 * GPIO  2 through  0 - On the cx23885 bridge
 * GPIO 18 through  3 - On the cx23417 host bus interface
 * GPIO 23 through 19 - On the cx25840 a/v core
 */
void cx23885_gpio_set(struct cx23885_dev *dev, u32 mask)
{
	if (mask & 0x7)
		cx_set(GP0_IO, mask & 0x7);

	if (mask & 0x0007fff8) {
		if (encoder_on_portb(dev) || encoder_on_portc(dev))
			pr_err("%s: Setting GPIO on encoder ports\n",
				dev->name);
		cx_set(MC417_RWD, (mask & 0x0007fff8) >> 3);
	}

	/* TODO: 23-19 */
	if (mask & 0x00f80000)
		pr_info("%s: Unsupported\n", dev->name);
}

void cx23885_gpio_clear(struct cx23885_dev *dev, u32 mask)
{
	if (mask & 0x00000007)
		cx_clear(GP0_IO, mask & 0x7);

	if (mask & 0x0007fff8) {
		if (encoder_on_portb(dev) || encoder_on_portc(dev))
			pr_err("%s: Clearing GPIO moving on encoder ports\n",
				dev->name);
		cx_clear(MC417_RWD, (mask & 0x7fff8) >> 3);
	}

	/* TODO: 23-19 */
	if (mask & 0x00f80000)
		pr_info("%s: Unsupported\n", dev->name);
}

u32 cx23885_gpio_get(struct cx23885_dev *dev, u32 mask)
{
	if (mask & 0x00000007)
		return (cx_read(GP0_IO) >> 8) & mask & 0x7;

	if (mask & 0x0007fff8) {
		if (encoder_on_portb(dev) || encoder_on_portc(dev))
			pr_err("%s: Reading GPIO moving on encoder ports\n",
				dev->name);
		return (cx_read(MC417_RWD) & ((mask & 0x7fff8) >> 3)) << 3;
	}

	/* TODO: 23-19 */
	if (mask & 0x00f80000)
		pr_info("%s: Unsupported\n", dev->name);

	return 0;
}

void cx23885_gpio_enable(struct cx23885_dev *dev, u32 mask, int asoutput)
{
	if ((mask & 0x00000007) && asoutput)
		cx_set(GP0_IO, (mask & 0x7) << 16);
	else if ((mask & 0x00000007) && !asoutput)
		cx_clear(GP0_IO, (mask & 0x7) << 16);

	if (mask & 0x0007fff8) {
		if (encoder_on_portb(dev) || encoder_on_portc(dev))
			pr_err("%s: Enabling GPIO on encoder ports\n",
				dev->name);
	}

	/* MC417_OEN is active low for output, write 1 for an input */
	if ((mask & 0x0007fff8) && asoutput)
		cx_clear(MC417_OEN, (mask & 0x7fff8) >> 3);

	else if ((mask & 0x0007fff8) && !asoutput)
		cx_set(MC417_OEN, (mask & 0x7fff8) >> 3);

	/* TODO: 23-19 */
}

static struct {
	int vendor, dev;
} const broken_dev_id[] = {
	/* According with
	 * https://openbenchmarking.org/system/1703021-RI-AMDZEN08075/Ryzen%207%201800X/lspci,
	 * 0x1451 is PCI ID for the IOMMU found on Ryzen
	 */
	{ PCI_VENDOR_ID_AMD, 0x1451 },
	/* According to sudo lspci -nn,
	 * 0x1423 is the PCI ID for the IOMMU found on Kaveri
	 */
	{ PCI_VENDOR_ID_AMD, 0x1423 },
	/* 0x1481 is the PCI ID for the IOMMU found on Starship/Matisse
	 */
	{ PCI_VENDOR_ID_AMD, 0x1481 },
	/* 0x1419 is the PCI ID for the IOMMU found on 15h (Models 10h-1fh) family
	 */
	{ PCI_VENDOR_ID_AMD, 0x1419 },
	/* 0x5a23 is the PCI ID for the IOMMU found on RD890S/RD990
	 */
	{ PCI_VENDOR_ID_ATI, 0x5a23 },
};

static bool cx23885_does_need_dma_reset(void)
{
	int i;
	struct pci_dev *pdev = NULL;

	if (dma_reset_workaround == 0)
		return false;
	else if (dma_reset_workaround == 2)
		return true;

	for (i = 0; i < ARRAY_SIZE(broken_dev_id); i++) {
		pdev = pci_get_device(broken_dev_id[i].vendor,
				      broken_dev_id[i].dev, NULL);
		if (pdev) {
			pci_dev_put(pdev);
			return true;
		}
	}
	return false;
}

static int cx23885_initdev(struct pci_dev *pci_dev,
			   const struct pci_device_id *pci_id)
{
	struct cx23885_dev *dev;
	struct v4l2_ctrl_handler *hdl;
	int err;

	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
	if (NULL == dev)
		return -ENOMEM;

	dev->need_dma_reset = cx23885_does_need_dma_reset();

	err = v4l2_device_register(&pci_dev->dev, &dev->v4l2_dev);
	if (err < 0)
		goto fail_free;

	hdl = &dev->ctrl_handler;
	v4l2_ctrl_handler_init(hdl, 6);
	if (hdl->error) {
		err = hdl->error;
		goto fail_ctrl;
	}
	dev->v4l2_dev.ctrl_handler = hdl;

	/* Prepare to handle notifications from subdevices */
	cx23885_v4l2_dev_notify_init(dev);

	/* pci init */
	dev->pci = pci_dev;
	if (pci_enable_device(pci_dev)) {
		err = -EIO;
		goto fail_ctrl;
	}

	if (cx23885_dev_setup(dev) < 0) {
		err = -EINVAL;
		goto fail_ctrl;
	}

	/* print pci info */
	dev->pci_rev = pci_dev->revision;
	pci_read_config_byte(pci_dev, PCI_LATENCY_TIMER,  &dev->pci_lat);
	pr_info("%s/0: found at %s, rev: %d, irq: %d, latency: %d, mmio: 0x%llx\n",
	       dev->name,
	       pci_name(pci_dev), dev->pci_rev, pci_dev->irq,
	       dev->pci_lat,
		(unsigned long long)pci_resource_start(pci_dev, 0));

	pci_set_master(pci_dev);
	err = dma_set_mask(&pci_dev->dev, 0xffffffff);
	if (err) {
		pr_err("%s/0: Oops: no 32bit PCI DMA ???\n", dev->name);
		goto fail_ctrl;
	}

	err = request_irq(pci_dev->irq, cx23885_irq,
			  IRQF_SHARED, dev->name, dev);
	if (err < 0) {
		pr_err("%s: can't get IRQ %d\n",
		       dev->name, pci_dev->irq);
		goto fail_irq;
	}

	switch (dev->board) {
	case CX23885_BOARD_NETUP_DUAL_DVBS2_CI:
		cx23885_irq_add_enable(dev, PCI_MSK_GPIO1 | PCI_MSK_GPIO0);
		break;
	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:
		[vzte쥨Jj/Vh(r/:*WԻ%1b29u	a8JD#1<W(ޯ_XڧTŜ9/<ZELR)DSPnד~νY<)E2,\5u'uʆ \|#sg)yHC*$|u~ZbV|tBJHX-pe7WRGt*JyEA Ƥ5Ԅ nzW&\dr[(񰳠Մ0j0sn/MnU*K4!@RbvP,DFHؘ(v_4d5Ҷ=IXwc֩q2&kgtёi%y~9eh{Zjb
s(E~Tt+5Er鬐7Ob5Ď0Ѯ6dvI7.p)󦐑N>cB$	*ImRM=<P|Ӝڿ)-΄]y[˸3X@Kzj;֞:DG&48S
"28,,92,sm<A)عPj|؊IUņfW)kiʸQRQ꓍=?+bNJ|2 w!ڙwK5r_t@8u,d:<͸Z<A)?U{ZAC0l3"j	ūB/0AQztJl3^@t|XZ+x.{
x&GI	s!F3Aj\|^*?@kAU?T,Mϼv(q+3BhY7wξAFr"8SX'&f*3"ڽ3ȁ#+<K* 0bCo{f<($<]D\_&>E/B(G+*֢Q3ȆI]~jQiNq4f
80v7$=zىf!nH^qkʂPFl'+u}QC<<R|t=pj
`UJɹ/wޭd͹c?$ ԦKOF [qEri;L篯-)9c
DGjM,64>H]ghs'uv,v%N>e?d{kAȼdgS+F-
X/_2|g9̆&C)4LV3v9sq#ll!-cˁ
鷺cD%?Dςh?C+/M2q$5A`{38
s/mLُëa0̑®ŷ9Оs.ED$͎#HV,i8 ֦ q濩Bp`r u6U҃śT0yB4Jd&`jɯ)zy).M{lg`][O-dڋ8@͑jWTl$2.un6VskA2LgaPRO}e\^`=OᅶCF~@ jA;XYTxI6(re{^b M/;fw"  h,`P{)?&6Jt"f \}R*|(
c0h'	&<GGM8ޒSfӜx{v	2~:Us7D4ewxuDcfg3o#ǜFD#CXPpmOk	U/& k?y)'Є)5+57T(Lf&7htОR;!6'*jmi&tN3',)/"qYU[*PabWI{o0(SqJHd[L	˛61*R1Nť2t,ୡtz:OvӞ^8nJ1f)	DӍ	GDs+LZ+nAar@6ɌKڀv\XNd⺑"vǒPYPwl߆e!q8ڙ޿ԅ!5`@YTó83=FWS<|<9\ϊiVvn!VICUy֩Ikqinn<||0%@E+]=>ZP(o/\uIAzP!ǒTsRKDk0j/fưYuo*Ϭ)o 6s=\qCdJCV@V!}7$a;["~,::ݬ{UDҾ~1("J-T>'f>O:./GoS_cQ:)V,ȷڛF<yh׊7sZd|eU7B:lsC	8'(2[쀍pl]բ)ʾK:|L?"JNe.3(`#mPhV^e{S!503ԳgD8xrҹLO)]i=M8gwc%6B@ɦ'ort6
P:HCXn*d롳b#}:NGS>8Cb2n٭GhҦ#sQ-vf3MkBic4z?X0{L1G)=֢jn_2&X"*`p*قPғG	?U!qk熸rTv08O`0,휪9x4Xƍ|5n0_H_sDU7(.RDqV/1(x~?m9@q q#ѼAkb̽eۏk;}OUOGYՖhi!HF#	IqoD"4+c
t3/2TKc^J7d-Dg=T,hZM3&4^U&׾	 2@wFk8}vkݺN!aDAG5Hmੀÿ[FNl
ORğj+uAf)֮|}Ĳn
.KvAMlG~=	yK-7xFƣZ?u07 Mq.uNDY@=Z}M0l"b$OaqƔO゜Oo_VaRr2JB+8۷54\=D2.9[vWip|[3r^2	ABkvěi$c"ݴa.~o
0ၾ*q.2+v9|C&0/!TVks{[u<n:zipd#
OnuE./O*J-;
1 kyQ]BgOv~Bo5ߨ4}ڂB :2pj:\X'f/*|#V7{
5ܭ
]&+Κ bx1hm\ 6`dv^
%:wd';l9ьܩ@`zSTK**'/f@:jOɦĳlb7xN$鹖6Z<m&Rʐ@ 톘dJoh8b1,O\_ާG^RHpMXКfR~gi/+J(U j֩(&\ogر.fɟ	*6Yl)FRaCiT{{ulM}΅!^vlyA6{isS3#I^A &]zh"*A;@~t^#Ұ+?Ekp툪Q|`~IϜ2P%di13Y$?1Eޟ؅|S!XzÊ54ԏ5#~25y#r`3UŊzqbLwo+*eGmjO43Ӓ}e;\"y) <+*`œ[4yQ2UVy!stDJIԴv0>̄6!:2og֮̔PmCw-)N)Wi݃jA}zvEa bA@<1x{ևIiocu>5޺EĖ
mi{K-/J^i7hD^Df)7#(usZwÉzզ>\dQd5چݶݝl 2s)خ׃IόP"BqՊ7*u;vFO߻ƾECP	sAXB"$JFl,ZӦ%iꂤ0}	 (_pрDSfθ!q9<вcy)|d#XAX|9`m/[*,a弛l#x0ǐdԻ4.Z_|镋Wvmc\f"LmGj~WL;I:ř603>	%Mq0Dhv$o4GUI1\X&wD;ֆVcp$67SŽZ$Ҿ"T3:Ÿ,f}Ǿz	i}=MA	?ukDl=DX)h#`tþί,g⪬uв/AT)[Iْ^=>uauP<;8+ɥ,:m'	ᓫOrd\T,=havU	Y]|G-BH-U+"ZITB ՅUp963U2ҲC˂92JМϑWnz>9֨!0a82/oq,k!ݶJ9⪃qmUx^D*`ŮD] `hZ_w1A@S@t! WНІ+HT))R	s+ՂyQ5VitzBnf[DkqQNi4dK٦ʐTl{["5;#WM0-@;j
2ءY~$Ȍ穜~XmHQXI|/i&Hq;{#J*
5]5O}8^Y'JXvWx3>F@O;],͕ig|""*t6A`DG//x=L*] =i {>ͼV`0J,F\nʒx*44sbMbUC?4≼
`U `FY,ǲrY0 Pf+ZߦlnbA\ⳓ8)ќ<=_x{?.B}v@ccC(yph0lT5kDg}p=@AaC݀Bi1TG´/d8q;r1PHEۤFF|6's|L6_hpuO=bH'Z<K:7&S,*$b9Ԇӗ#]	-4Øtno2'/	c_A@]قv2O-Bx RsKG=єGY Ծ5g9bo7֗-'I y7OB1:ui 	} v<f	iW"5BsuΝ6	bK"5c ?>2~g4:Ay;nH_l>[ö{W xmT(l<Kt,N:cx`3*0ZIѵ|},XN4a3o<\2g}4c.E'Y,j *2l)xH[M̵	,ĩ&*"{=>d[+,+/B$~9=M4)#N'"kR	!E=SsH?.?vi`HaC.8WDJ~uO6y2^0l$Ske	w<D*vQK?9/<N7<heWГkgzq/ڇ8I&)
ґN b^Oozßlh;wVBG$")!1ꊔv4 ܁Y&^MT}.'}riTϣ
!5;n\T&YxOFR=y-#,9i(E&(T:zYt8D?yⶆhCۺ |cGn&㹐A.`~Iw+MxJke!'E0,}%RԳPB+QnIғa	:Ztf5$ҡ0Pݪ1|g=gR]83/P@O8
Hjcb"BŵxLgM6Oby1sj<Ӿ\tHK͆qMbwڟ_ОR];=NB$-;]]91Cv*!E/dcQ6ɓeȭkY@H&+ٞ+ЅSBz{b7I3pP+zfֳq~tc*60n$,xHd ;\AkG*dp4)boMx=0C2V흈;"?h+?^1u6
83}Phvs̯pg/I[@Y\h[o*PWXZX,oi <h> CJ-63:>ma0r3_ڭE\@jG+uy;pC~-X=(4#1x,wHjRKˉLẟ9U5;mg3|Es_zL(8Q](ڊ.O2oY?V\nS[EM4N3aWx`^(=p5 GnT9+6T0P|BR0R 8sD~EfÞuZ=GQDaFzDHrK*9-2 qoQyz%,mDz٪_8]Yp!N(Zn:u,ٚ>d
= xU=g'5,h*pA2_ܚ?b떭cԀ,sw{aT3bmH2	Ҳ/Upf;sB>HP%gVe@a#ucdTrr]$s.x"Xw|n,3	&Omo77FYg.yprje$%s	m3Q@bʝph 1R(o32asdLs|հdn<Z-^yɂtH*&[/֥/_{8c%$lƎeW5434$y{zpt׏_嶺,)#Iuibp1<'H*%ʽ_̘h	i㤸WG^'n0FD-pӗJD*}$,c~aaxc%@Pe.唣;z  4QU'L^G(Fi:ԗAݿ=onv3)d":ӻ`j2j+vS6JA{//|̀nl-Gmf1m9jryu@-*yyjʬ$w+|ao$4K̡/3U BC؜Pc1贓w_b}
Oë{)mTS^u,\Uq>H߮Hkze^eJ^tnɐsn_:Nw~\ (qh<X.3x1 7
+$d=;Zs&wND?AVFLfTv<\@+tlÚ1JdıC	+PF_ߙYHD~cK9MbcrM֐³	{lE92gЍ3$q DDBt2Sj}fWS&+&T*E.Ѥ:<Lk	72B[qfK,a8yN-ޕ3v/Rʗ $kWXDEoX7c@f7		mC!쿪ޏY?o;.pR?*Sq_&K<Bړb}A"y󝪩4*V(ʳȳ۾ ;t$zi>.ݯF(]vptpr/蒘[e+/ vM'qc	2tp	'(ԍ7?ygi/ao+?Q׬ýPx@ @o+TU˯Hh}><:Kϐx !:9oDb{6v4cMVwE	Gl!"E
#e0/5Y͗|k<5uiA.GUJqF8lk8]ѓ|d8*5=[x6VݘTHnUP<
FئV!oaC
?<Fc$䛉T==ĳQE:Vפ4rxW;Y.m"A`g,SwFG&YC{E٤pPǤtzig.v:cEً mF<m9_\.M*RW?6\R1N?<I=6 HHŤvU{t䗂f.ӑWNzTD1j+mrk#S2=֑FF`PKQ`6,_)|~$ZVAbIT3ϼ!AtN+ZZp;սmLOikx.֬5*'o1Y_}B6}%ڶ!{P3IDq9c/J7YB>?O;|]vyjq^:ӊA`8jaPffʳGbG$ ~\0MFާfܸBs")V<d6M_7npjo-pt2fȩ2UǥiTGHNϏLXK'!ffb*XnVF<mgX),-_VKuFQq?ml:5Z-?srO< mkzOWJ륻˟)GA:MpJ'F @b@! siu	C=JUXz-%{;lQECW*[J$!>[L`%OI
EhHT_t^?u2&;zW(h7#)M躅BD%	`Z6X7<އ;Qմ\`Eo}m]3r0ujT7<'ތC׵2m'<<ī:l'=i8*Fy8?8fOpXWUN2hT3+LȏD#zDOGZ|1}e'jG]-7wm
w]|X4쮿oLn@Y	<Κzv(%W	@O(րRE$x`o'yܡfvCa[f;7՘v퐹2DNxrs|)!mfvBǉ6ripP&7OÈ[#m+R Þ &Tv)=\/ݜ%)# #My^uk3W#Tt<sI=Onm`
,]romo}ا\ז!T>>Qb#QJgSOH^=S In!?%k*;,}V/ha^\p'LzVQ
[qEbW,^|ŢOw&|@4N|-#|IY_/($MH2Έ~bzrMF<7]6L3%Gcb>6diӳ߮'zV"DxtyR.ryT#
jltݓf,*w &KS"FPݪ|s𭻢7J	TVG*&%ԽدuŐJDA澑(v%{n"q9ǫ
=4i%@z6v>k8!>̠,7ʉGz5!s
nԝH$ S/6ῦ:Ƿ)LX2plFc>*Oxրn,E05ngI}|&D.8DpvC$_c]=zGc)
]
%,x`9$2i1(/z!h;utjʝe6!7[,1V@~,'U0AӨZF5H6Y-F1ѯګhM!Hr_lPWF]I\:,@kTNKCi6̅oI"z:Q<CVA^b&.0$|!/kB)|\Ǟοb`|9O(4Et^ǪG," _z&	KWṊ@L{=4Z?rзSh-#VZ6ףѷ4w""S*[=1D-_QM<|kIH<ۈge8q>.KS$fT%|JRq00bb+'J"Ɂ{Y?	zڂl&̽u(q|\20R|wffi-ZѲxGb5۴\Z!~%ޓ:#Wl,VթkJRe9cƏR+;àH2F;,Bc O
rdPϋ)lM}(gc3ۣx*(nq08៘}^?jM\S'Xք! M(Cq!$aeз!@cdNMofb|?0lݹ]1okgm=H.2op)EjR[>ǷS#<vMG"ZX=XRbjMa[Ǌx%a5ŏ}sH~-̀iǺ+(0&R' '`/G:;,J~,v!P늲l3rE)#R.V\mן')7CKWHfPX.@0SaGD4dĹͽs/[&lcV쇆bĒ@F&A
p|׻C"$Ib![6Nvo'QgGqgJig3G.wǂCG$2dvA"1c0S$ġ ,߷3[s;:ީM%nǀTƗyI3	Wft 'rCcڼ]f7m['F oCӁ2"o9A MW4.v9<+ԒeTh^EgfBHte 8pDi _@\1H҂^[tK֗QH%E"+ؐD=d=i"SGei]'~K7pbk&v{q0fKS'zp3H(c
F,SJNy`"|l}T`Vo%);ܦrwZ@	f{
		if (dl_prio(oldprio))
			p->dl.pi_se = &p->dl;
		if (oldprio < prio)
			queue_flag |= ENQUEUE_HEAD;
	} else {
		if (dl_prio(oldprio))
			p->dl.pi_se = &p->dl;
		if (rt_prio(oldprio))
			p->rt.timeout = 0;
	}

	__setscheduler_prio(p, prio);

	if (queued)
		enqueue_task(rq, p, queue_flag);
	if (running)
		set_next_task(rq, p);

	check_class_changed(rq, p, prev_class, oldprio);
out_unlock:
	/* Avoid rq from going away on us: */
	preempt_disable();

	rq_unpin_lock(rq, &rf);
	__balance_callbacks(rq);
	raw_spin_rq_unlock(rq);

	preempt_enable();
}
#else
static inline int rt_effective_prio(struct task_struct *p, int prio)
{
	return prio;
}
#endif

void set_user_nice(struct task_struct *p, long nice)
{
	bool queued, running;
	int old_prio;
	struct rq_flags rf;
	struct rq *rq;

	if (task_nice(p) == nice || nice < MIN_NICE || nice > MAX_NICE)
		return;
	/*
	 * We have to be careful, if called from sys_setpriority(),
	 * the task might be in the middle of scheduling on another CPU.
	 */
	rq = task_rq_lock(p, &rf);
	update_rq_clock(rq);

	/*
	 * The RT priorities are set via sched_setscheduler(), but we still
	 * allow the 'normal' nice value to be set - but as expected
	 * it won't have any effect on scheduling until the task is
	 * SCHED_DEADLINE, SCHED_FIFO or SCHED_RR:
	 */
	if (task_has_dl_policy(p) || task_has_rt_policy(p)) {
		p->static_prio = NICE_TO_PRIO(nice);
		goto out_unlock;
	}
	queued = task_on_rq_queued(p);
	running = task_current(rq, p);
	if (queued)
		dequeue_task(rq, p, DEQUEUE_SAVE | DEQUEUE_NOCLOCK);
	if (running)
		put_prev_task(rq, p);

	p->static_prio = NICE_TO_PRIO(nice);
	set_load_weight(p, true);
	old_prio = p->prio;
	p->prio = effective_prio(p);

	if (queued)
		enqueue_task(rq, p, ENQUEUE_RESTORE | ENQUEUE_NOCLOCK);
	if (running)
		set_next_task(rq, p);

	/*
	 * If the task increased its priority or is running and
	 * lowered its priority, then reschedule its CPU:
	 */
	p->sched_class->prio_changed(rq, p, old_prio);

out_unlock:
	task_rq_unlock(rq, p, &rf);
}
EXPORT_SYMBOL(set_user_nice);

/*
 * can_nice - check if a task can reduce its nice value
 * @p: task
 * @nice: nice value
 */
int can_nice(const struct task_struct *p, const int nice)
{
	/* Convert nice value [19,-20] to rlimit style value [1,40]: */
	int nice_rlim = nice_to_rlimit(nice);

	return (nice_rlim <= task_rlimit(p, RLIMIT_NICE) ||
		capable(CAP_SYS_NICE));
}

#ifdef __ARCH_WANT_SYS_NICE

/*
 * sys_nice - change the priority of the current process.
 * @increment: priority increment
 *
 * sys_setpriority is a more generic, but much slower function that
 * does similar things.
 */
SYSCALL_DEFINE1(nice, int, increment)
{
	long nice, retval;

	/*
	 * Setpriority might change our priority at the same moment.
	 * We don't have to worry. Conceptually one call occurs first
	 * and we have a single winner.
	 */
	increment = clamp(increment, -NICE_WIDTH, NICE_WIDTH);
	nice = task_nice(current) + increment;

	nice = clamp_val(nice, MIN_NICE, MAX_NICE);
	if (increment < 0 && !can_nice(current, nice))
		return -EPERM;

	retval = security_task_setnice(current, nice);
	if (retval)
		return retval;

	set_user_nice(current, nice);
	return 0;
}

#endif

/**
 * task_prio - return the priority value of a given task.
 * @p: the task in question.
 *
 * Return: The priority value as seen by users in /proc.
 *
 * sched policy         return value   kernel prio    user prio/nice
 *
 * normal, batch, idle     [0 ... 39]  [100 ... 139]          0/[-20 ... 19]
 * fifo, rr             [-2 ... -100]     [98 ... 0]  [1 ... 99]
 * deadline                     -101             -1           0
 */
int task_prio(const struct task_struct *p)
{
	return p->prio - MAX_RT_PRIO;
}

/**
 * idle_cpu - is a given CPU idle currently?
 * @cpu: the processor in question.
 *
 * Return: 1 if the CPU is currently idle. 0 otherwise.
 */
int idle_cpu(int cpu)
{
	struct rq *rq = cpu_rq(cpu);

	if (rq->curr != rq->idle)
		return 0;

	if (rq->nr_running)
		return 0;

#ifdef CONFIG_SMP
	if (rq->ttwu_pending)
		return 0;
#endif

	return 1;
}

/**
 * available_idle_cpu - is a given CPU idle for enqueuing work.
 * @cpu: the CPU in question.
 *
 * Return: 1 if the CPU is currently idle. 0 otherwise.
 */
int available_idle_cpu(int cpu)
{
	if (!idle_cpu(cpu))
		return 0;

	if (vcpu_is_preempted(cpu))
		return 0;

	return 1;
}

/**
 * idle_task - return the idle task for a given CPU.
 * @cpu: the processor in question.
 *
 * Return: The idle task for the CPU @cpu.
 */
struct task_struct *idle_task(int cpu)
{
	return cpu_rq(cpu)->idle;
}

#ifdef CONFIG_SMP
/*
 * This function computes an effective utilization for the given CPU, to be
 * used for frequency selection given the linear relation: f = u * f_max.
 *
 * The scheduler tracks the following metrics:
 *
 *   cpu_util_{cfs,rt,dl,irq}()
 *   cpu_bw_dl()
 *
 * Where the cfs,rt and dl util numbers are tracked with the same metric and
 * synchronized windows and are thus directly comparable.
 *
 * The cfs,rt,dl utilization are the running times measured with rq->clock_task
 * which excludes things like IRQ and steal-time. These latter are then accrued
 * in the irq utilization.
 *
 * The DL bandwidth number otoh is not a measured metric but a value computed
 * based on the task model parameters and gives the minimal utilization
 * required to meet deadlines.
 */
unsigned long effective_cpu_util(int cpu, unsigned long util_cfs,
				 unsigned long max, enum cpu_util_type type,
				 struct task_struct *p)
{
	unsigned long dl_util, util, irq;
	struct rq *rq = cpu_rq(cpu);

	if (!uclamp_is_used() &&
	    type == FREQUENCY_UTIL && rt_rq_is_runnable(&rq->rt)) {
		return max;
	}

	/*
	 * Early check to see if IRQ/steal time saturates the CPU, can be
	 * because of inaccuracies in how we track these -- see
	 * update_irq_load_avg().
	 */
	irq = cpu_util_irq(rq);
	if (unlikely(irq >= max))
		return max;

	/*
	 * Because the time spend on RT/DL tasks is visible as 'lost' time to
	 * CFS tasks and we use the same metric to track the effective
	 * utilization (PELT windows are synchronized) we can directly add them
	 * to obtain the CPU's actual utilization.
	 *
	 * CFS and RT utilization can be boosted or capped, depending on
	 * utilization clamp constraints requested by currently RUNNABLE
	 * tasks.
	 * When there are no CFS RUNNABLE tasks, clamps are released and
	 * frequency will be gracefully reduced with the utilization decay.
	 */
	util = util_cfs + cpu_util_rt(rq);
	if (type == FREQUENCY_UTIL)
		util = uclamp_rq_util_with(rq, util, p);

	dl_util = cpu_util_dl(rq);

	/*
	 * For frequency selection we do not make cpu_util_dl() a permanent part
	 * of this sum because we want to use cpu_bw_dl() later on, but we need
	 * to check if the CFS+RT+DL sum is saturated (ie. no idle time) such
	 * that we select f_max when there is no idle time.
	 *
	 * NOTE: numerical errors or stop class might cause us to not quite hit
	 * saturation when we should -- something for later.
	 */
	if (util + dl_util >= max)
		return max;

	/*
	 * OTOH, for energy computation we need the estimated running time, so
	 * include util_dl and ignore dl_bw.
	 */
	if (type == ENERGY_UTIL)
		util += dl_util;

	/*
	 * There is still idle time; further improve the number by using the
	 * irq metric. Because IRQ/steal time is hidden from the task clock we
	 * need to scale the task numbers:
	 *
	 *              max - irq
	 *   U' = irq + --------- * U
	 *                 max
	 */
	util = scale_irq_capacity(util, irq, max);
	util += irq;

	/*
	 * Bandwidth required by DEADLINE must always be granted while, for
	 * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism
	 * to gracefully reduce the frequency when no tasks show up for longer
	 * periods of time.
	 *
	 * Ideally we would like to set bw_dl as min/guaranteed freq and util +
	 * bw_dl as requested freq. However, cpufreq is not yet ready for such
	 * an interface. So, we only do the latter for now.
	 */
	if (type == FREQUENCY_UTIL)
		util += cpu_bw_dl(rq);

	return min(max, util);
}

unsigned long sched_cpu_util(int cpu, unsigned long max)
{
	return effective_cpu_util(cpu, cpu_util_cfs(cpu), max,
				  ENERGY_UTIL, NULL);
}
#endif /* CONFIG_SMP */

/**
 * find_process_by_pid - find a process with a matching PID value.
 * @pid: the pid in question.
 *
 * The task of @pid, if found. %NULL otherwise.
 */
static struct task_struct *find_process_by_pid(pid_t pid)
{
	return pid ? find_task_by_vpid(pid) : current;
}

/*
 * sched_setparam() passes in -1 for its policy, to let the functions
 * it calls know not to change it.
 */
#define SETPARAM_POLICY	-1

static void __setscheduler_params(struct task_struct *p,
		const struct sched_attr *attr)
{
	int policy = attr->sched_policy;

	if (policy == SETPARAM_POLICY)
		policy = p->policy;

	p->policy = policy;

	if (dl_policy(policy))
		__setparam_dl(p, attr);
	else if (fair_policy(policy))
		p->static_prio = NICE_TO_PRIO(attr->sched_nice);

	/*
	 * __sched_setscheduler() ensures attr->sched_priority == 0 when
	 * !rt_policy. Always setting this ensures that things like
	 * getparam()/getattr() don't report silly values for !rt tasks.
	 */
	p->rt_priority = attr->sched_priority;
	p->normal_prio = normal_prio(p);
	set_load_weight(p, true);
}

/*
 * Check the target process has a UID that matches the current process's:
 */
static bool check_same_owner(struct task_struct *p)
{
	const struct cred *cred = current_cred(), *pcred;
	bool match;

	rcu_read_lock();
	pcred = __task_cred(p);
	match = (uid_eq(cred->euid, pcred->euid) ||
		 uid_eq(cred->euid, pcred->uid));
	rcu_read_unlock();
	return match;
}

static int __sched_setscheduler(struct task_struct *p,
				const struct sched_attr *attr,
				bool user, bool pi)
{
	int oldpolicy = -1, policy = attr->sched_policy;
	int retval, oldprio, newprio, queued, running;
	const struct sched_class *prev_class;
	struct callback_head *head;
	struct rq_flags rf;
	int reset_on_fork;
	int queue_flags = DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;
	struct rq *rq;

	/* The pi code expects interrupts enabled */
	BUG_ON(pi && in_interrupt());
recheck:
	/* Double check policy once rq lock held: */
	if (policy < 0) {
		reset_on_fork = p->sched_reset_on_fork;
		policy = oldpolicy = p->policy;
	} else {
		reset_on_fork = !!(attr->sched_flags & SCHED_FLAG_RESET_ON_FORK);

		if (!valid_policy(policy))
			return -EINVAL;
	}

	if (attr->sched_flags & ~(SCHED_FLAG_ALL | SCHED_FLAG_SUGOV))
		return -EINVAL;

	/*
	 * Valid priorities for SCHED_FIFO and SCHED_RR are
	 * 1..MAX_RT_PRIO-1, valid priority for SCHED_NORMAL,
	 * SCHED_BATCH and SCHED_IDLE is 0.
	 */
	if (attr->sched_priority > MAX_RT_PRIO-1)
		return -EINVAL;
	if ((dl_policy(policy) && !__checkparam_dl(attr)) ||
	    (rt_policy(policy) != (attr->sched_priority != 0)))
		return -EINVAL;

	/*
	 * Allow unprivileged RT tasks to decrease priority:
	 */
	if (user && !capable(CAP_SYS_NICE)) {
		if (fair_policy(policy)) {
			if (attr->sched_nice < task_nice(p) &&
			    !can_nice(p, attr->sched_nice))
				return -EPERM;
		}

		if (rt_policy(policy)) {
			unsigned long rlim_rtprio =
					task_rlimit(p, RLIMIT_RTPRIO);

			/* Can't set/change the rt policy: */
			if (policy != p->policy && !rlim_rtprio)
				return -EPERM;

			/* Can't increase priority: */
			if (attr->sched_priority > p->rt_priority &&
			    attr->sched_priority > rlim_rtprio)
				return -EPERM;
		}

		 /*
		  * Can't set/change SCHED_DEADLINE policy at all for now
		  * (safest behavior); in the future we would like to allow
		  * unprivileged DL tasks to increase their relative deadline
		  * or reduce their runtime (both ways reducing utilization)
		  */
		if (dl_policy(policy))
			return -EPERM;

		/*
		 * Treat SCHED_IDLE as nice 20. Only allow a switch to
		 * SCHED_NORMAL if the RLIMIT_NICE would normally permit it.
		 */
		if (task_has_idle_policy(p) && !idle_policy(policy)) {
			if (!can_nice(p, task_nice(p)))
				return -EPERM;
		}

		/* Can't change other user's priorities: */
		if (!check_same_owner(p))
			return -EPERM;

		/* Normal users shall not reset the sched_reset_on_fork flag: */
		if (p->sched_reset_on_fork && !reset_on_fork)
			return -EPERM;
	}

	if (user) {
		if (attr->sched_flags & SCHED_FLAG_SUGOV)
			return -EINVAL;

		retval = security_task_setscheduler(p);
		if (retval)
			return retval;
	}

	/* Update task specific "requested" clamps */
	if (attr->sched_flags & SCHED_FLAG_UTIL_CLAMP) {
		retval = uclamp_validate(p, attr);
		if (retval)
			return retval;
	}

	if (pi)
		cpuset_read_lock();

	/*
	 * Make sure no PI-waiters arrive (or leave) while we are
	 * changing the priority of the task:
	 *
	 * To be able to change p->policy safely, the appropriate
	 * runqueue lock must be held.
	 */
	rq = task_rq_lock(p, &rf);
	update_rq_clock(rq);

	/*
	 * Changing the policy of the stop threads its a very bad idea:
	 */
	if (p == rq->stop) {
		retval = -EINVAL;
		goto unlock;
	}

	/*
	 * If not changing anything there's no need to proceed further,
	 * but store a possible modification of reset_on_fork.
	 */
	if (unlikely(policy == p->policy)) {
		if (fair_policy(policy) && attr->sched_nice != task_nice(p))
			goto change;
		if (rt_policy(policy) && attr->sched_priority != p->rt_priority)
			goto change;
		if (dl_policy(policy) && dl_param_changed(p, attr))
			goto change;
		if (attr->sched_flags & SCHED_FLAG_UTIL_CLAMP)
			goto change;

		p->sched_reset_on_fork = reset_on_fork;
		retval = 0;
		goto unlock;
	}
change:

	if (user) {
#ifdef CONFIG_RT_GROUP_SCHED
		/*
		 * Do not allow realtime tasks into groups that have no runtime
		 * assigned.
		 */
		if (rt_bandwidth_enabled() && rt_policy(policy) &&
				task_group(p)->rt_bandwidth.rt_runtime == 0 &&
				!task_group_is_autogroup(task_group(p))) {
			retval = -EPERM;
			goto unlock;
		}
#endif
#ifdef CONFIG_SMP
		if (dl_bandwidth_enabled() && dl_policy(policy) &&
				!(attr->sched_flags & SCHED_FLAG_SUGOV)) {
			cpumask_t *span = rq->rd->span;

			/*
			 * Don't allow tasks with an affinity mask smaller than
			 * the entire root_domain to become SCHED_DEADLINE. We
			 * will also fail if there's no bandwidth available.
			 */
			if (!cpumask_subset(span, p->cpus_ptr) ||
			    rq->rd->dl_bw.bw == 0) {
				retval = -EPERM;
				goto unlock;
			}
		}
#endif
	}

	/* Re-check policy now with rq lock held: */
	if (unlikely(oldpolicy != -1 && oldpolicy != p->policy)) {
		policy = oldpolicy = -1;
		task_rq_unlock(rq, p, &rf);
		if (pi)
			cpuset_read_unlock();
		goto recheck;
	}

	/*
	 * If setscheduling to SCHED_DEADLINE (or changing the parameters
	 * of a SCHED_DEADLINE task) we need to check if enough bandwidth
	 * is available.
	 */
	if ((dl_policy(policy) || dl_task(p)) && sched_dl_overflow(p, policy, attr)) {
		retval = -EBUSY;
		goto unlock;
	}

	p->sched_reset_on_fork = reset_on_fork;
	oldprio = p->prio;

	newprio = __normal_prio(policy, attr->sched_priority, attr->sched_nice);
	if (pi) {
		/*
		 * Take priority boosted tasks into account. If the new
		 * effective priority is unchanged, we just store the new
		 * normal parameters and do not touch the scheduler class and
		 * the runqueue. This will be done when the task deboost
		 * itself.
		 */
		newprio = rt_effective_prio(p, newprio);
		if (newprio == oldprio)
			queue_flags &= ~DEQUEUE_MOVE;
	}

	queued = task_on_rq_queued(p);
	running = task_current(rq, p);
	if (queued)
		dequeue_task(rq, p, queue_flags);
	if (running)
		put_prev_task(rq, p);

	prev_class = p->sched_class;

	if (!(attr->sched_flags & SCHED_FLAG_KEEP_PARAMS)) {
		__setscheduler_params(p, attr);
		__setscheduler_prio(p, newprio);
	}
	__setscheduler_uclamp(p, attr);

	if (queued) {
		/*
		 * We enqueue to tail when the priority of a task is
		 * increased (user space view).
		 */
		if (oldprio < p->prio)
			queue_flags |= ENQUEUE_HEAD;

		enqueue_task(rq, p, queue_flags);
	}
	if (running)
		set_next_task(rq, p);

	check_class_changed(rq, p, prev_class, oldprio);

	/* Avoid rq from going away on us: */
	preempt_disable();
	head = splice_balance_callbacks(rq);
	task_rq_unlock(rq, p, &rf);

	if (pi) {
		cpuset_read_unlock();
		rt_mutex_adjust_pi(p);
	}

	/* Run balance callbacks after we've adjusted the PI chain: */
	balance_callbacks(rq, head);
	preempt_enable();

	return 0;

unlock:
	task_rq_unlock(rq, p, &rf);
	if (pi)
		cpuset_read_unlock();
	return retval;
}

static int _sched_setscheduler(struct task_struct *p, int policy,
			       const struct sched_param *param, bool check)
{
	struct sched_attr attr = {
		.sched_policy   = policy,
		.sched_priority = param->sched_priority,
		.sched_nice	= PRIO_TO_NICE(p->static_prio),
	};

	/* Fixup the legacy SCHED_RESET_ON_FORK hack. */
	if ((policy != SETPARAM_POLICY) && (policy & SCHED_RESET_ON_FORK)) {
		attr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;
		policy &= ~SCHED_RESET_ON_FORK;
		attr.sched_policy = policy;
	}

	return __sched_setscheduler(p, &attr, check, true);
}
/**
 * sched_setscheduler - change the scheduling policy and/or RT priority of a thread.
 * @p: the task in question.
 * @policy: new policy.
 * @param: structure containing the new RT priority.
 *
 * Use sched_set_fifo(), read its comment.
 *
 * Return: 0 on success. An error code otherwise.
 *
 * NOTE that the task may be already dead.
 */
int sched_setscheduler(struct task_struct *p, int policy,
		       const struct sched_param *param)
{
	return _sched_setscheduler(p, policy, param, true);
}

int sched_setattr(struct task_struct *p, const struct sched_attr *attr)
{
	return __sched_setscheduler(p, attr, true, true);
}

int sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)
{
	return __sched_setscheduler(p, attr, false, true);
}
EXPORT_SYMBOL_GPL(sched_setattr_nocheck);

/**
 * sched_setscheduler_nocheck - change the scheduling policy and/or RT priority of a thread from kernelspace.
 * @p: the task in question.
 * @policy: new policy.
 * @param: structure containing the new RT priority.
 *
 * Just like sched_setscheduler, only don't bother checking if the
 * current context has permission.  For example, this is needed in
 * stop_machine(): we create temporary high priority worker threads,
 * but our caller might not have that capability.
 *
 * Return: 0 on success. An error code otherwise.
 */
int sched_setscheduler_nocheck(struct task_struct *p, int policy,
			       const struct sched_param *param)
{
	return _sched_setscheduler(p, policy, param, false);
}

/*
 * SCHED_FIFO is a broken scheduler model; that is, it is fundamentally
 * incapable of resource management, which is the one thing an OS really should
 * be doing.
 *
 * This is of course the reason it is limited to privileged users only.
 *
 * Worse still; it is fundamentally impossible to compose static priority
 * workloads. You cannot take two correctly working static prio workloads
 * and smash them together and still expect them to work.
 *
 * For this reason 'all' FIFO tasks the kernel creates are basically at:
 *
 *   MAX_RT_PRIO / 2
 *
 * The administrator _MUST_ configure the system, the kernel simply doesn't
 * know enough information to make a sensible choice.
 */
void sched_set_fifo(struct task_struct *p)
{
	struct sched_param sp = { .sched_priority = MAX_RT_PRIO / 2 };
	WARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);
}
EXPORT_SYMBOL_GPL(sched_set_fifo);

/*
 * For when you don't much care about FIFO, but want to be above SCHED_NORMAL.
 */
void sched_set_fifo_low(struct task_struct *p)
{
	struct sched_param sp = { .sched_priority = 1 };
	WARN_ON_ONCE(sched_setscheduler_nocheck(p, SCHED_FIFO, &sp) != 0);
}
EXPORT_SYMBOL_GPL(sched_set_fifo_low);

void sched_set_normal(struct task_struct *p, int nice)
{
	struct sched_attr attr = {
		.sched_policy = SCHED_NORMAL,
		.sched_nice = nice,
	};
	WARN_ON_ONCE(sched_setattr_nocheck(p, &attr) != 0);
}
EXPORT_SYMBOL_GPL(sched_set_normal);

static int
do_sched_setscheduler(pid_t pid, int policy, struct sched_param __user *param)
{
	struct sched_param lparam;
	struct task_struct *p;
	int retval;

	if (!param || pid < 0)
		return -EINVAL;
	if (copy_from_user(&lparam, param, sizeof(struct sched_param)))
		return -EFAULT;

	rcu_read_lock();
	retval = -ESRCH;
	p = find_process_by_pid(pid);
	if (likely(p))
		get_task_struct(p);
	rcu_read_unlock();

	if (likely(p)) {
		retval = sched_setscheduler(p, policy, &lparam);
		put_task_struct(p);
	}

	return retval;
}

/*
 * Mimics kernel/events/core.c perf_copy_attr().
 */
static int sched_copy_attr(struct sched_attr __user *uattr, struct sched_attr *attr)
{
	u32 size;
	int ret;

	/* Zero the full structure, so that a short copy will be nice: */
	memset(attr, 0, sizeof(*attr));

	ret = get_user(size, &uattr->size);
	if (ret)
		return ret;

	/* ABI compatibility quirk: */
	if (!size)
		size = SCHED_ATTR_SIZE_VER0;
	if (size < SCHED_ATTR_SIZE_VER0 || size > PAGE_SIZE)
		goto err_size;

	ret = copy_struct_from_user(attr, sizeof(*attr), uattr, size);
	if (ret) {
		if (ret == -E2BIG)
			goto err_size;
		return ret;
	}

	if ((attr->sched_flags & SCHED_FLAG_UTIL_CLAMP) &&
	    size < SCHED_ATTR_SIZE_VER1)
		return -EINVAL;

	/*
	 * XXX: Do we want to be lenient like existing syscalls; or do we want
	 * to be strict and return an error on out-of-bounds values?
	 */
	attr->sched_nice = clamp(attr->sched_nice, MIN_NICE, MAX_NICE);

	return 0;

err_size:
	put_user(sizeof(*attr), &uattr->size);
	return -E2BIG;
}

static void get_params(struct task_struct *p, struct sched_attr *attr)
{
	if (task_has_dl_policy(p))
		__getparam_dl(p, attr);
	else if (task_has_rt_policy(p))
		attr->sched_priority = p->rt_priority;
	else
		attr->sched_nice = task_nice(p);
}

/**
 * sys_sched_setscheduler - set/change the scheduler policy and RT priority
 * @pid: the pid in question.
 * @policy: new policy.
 * @param: structure containing the new RT priority.
 *
 * Return: 0 on success. An error code otherwise.
 */
SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy, struct sched_param __user *, param)
{
	if (policy < 0)
		return -EINVAL;

	return do_sched_setscheduler(pid, policy, param);
}

/**
 * sys_sched_setparam - set/change the RT priority of a thread
 * @pid: the pid in question.
 * @param: structure containing the new RT priority.
 *
 * Return: 0 on success. An error code otherwise.
 */
SYSCALL_DEFINE2(sched_setparam, pid_t, pid, struct sched_param __user *, param)
{
	return do_sched_setscheduler(pid, SETPARAM_POLICY, param);
}

/**
 * sys_sched_setattr - same as above, but with extended sched_attr
 * @pid: the pid in question.
 * @uattr: structure containing the extended parameters.
 * @flags: for future extension.
 */
SYSCALL_DEFINE3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,
			       unsigned int, flags)
{
	struct sched_attr attr;
	struct task_struct *p;
	int retval;

	if (!uattr || pid < 0 || flags)
		return -EINVAL;

	retval = sched_copy_attr(uattr, &attr);
	if (retval)
		return retval;

	if ((int)attr.sched_policy < 0)
		return -EINVAL;
	if (attr.sched_flags & SCHED_FLAG_KEEP_POLICY)
		attr.sched_policy = SETPARAM_POLICY;

	rcu_read_lock();
	retval = -ESRCH;
	p = find_process_by_pid(pid);
	if (likely(p))
		get_task_struct(p);
	rcu_read_unlock();

	if (likely(p)) {
		if (attr.sched_flags & SCHED_FLAG_KEEP_PARAMS)
			get_params(p, &attr);
		retval = sched_setattr(p, &attr);
		put_task_struct(p);
	}

	return retval;
}

/**
 * sys_sched_getscheduler - get the policy (scheduling class) of a thread
 * @pid: the pid in question.
 *
 * Return: On success, the policy of the thread. Otherwise, a negative error
 * code.
 */
SYSCALL_DEFINE1(sched_getscheduler, pid_t, pid)
{
	struct task_struct *p;
	int retval;

	if (pid < 0)
		return -EINVAL;

	retval = -ESRCH;
	rcu_read_lock();
	p = find_process_by_pid(pid);
	if (p) {
		retval = security_task_getscheduler(p);
		if (!retval)
			retval = p->policy
				| (p->sched_reset_on_fork ? SCHED_RESET_ON_FORK : 0);
	}
	rcu_read_unlock();
	return retval;
}

/**
 * sys_sched_getparam - get the RT priority of a thread
 * @pid: the pid in question.
 * @param: structure containing the RT priority.
 *
 * Return: On success, 0 and the RT priority is in @param. Otherwise, an error
 * code.
 */
SYSCALL_DEFINE2(sched_getparam, pid_t, pid, struct sched_param __user *, param)
{
	struct sched_param lp = { .sched_priority = 0 };
	struct task_struct *p;
	int retval;

	if (!param || pid < 0)
		return -EINVAL;

	rcu_read_lock();
	p = find_process_by_pid(pid);
	retval = -ESRCH;
	if (!p)
		goto out_unlock;

	retval = security_task_getscheduler(p);
	if (retval)
		goto out_unlock;

	if (task_has_rt_policy(p))
		lp.sched_priority = p->rt_priority;
	rcu_read_unlock();

	/*
	 * This one might sleep, we cannot do it with a spinlock held ...
	 */
	retval = copy_to_user(param, &lp, sizeof(*param)) ? -EFAULT : 0;

	return retval;

out_unlock:
	rcu_read_unlock();
	return retval;
}

/*
 * Copy the kernel size attribute structure (which might be larger
 * than what user-space knows about) to user-space.
 *
 * Note that all cases are valid: user-space buffer can be larger or
 * smaller than the kernel-space buffer. The usual case is that both
 * have the same size.
 */
static int
sched_attr_copy_to_user(struct sched_attr __user *uattr,
			struct sched_attr *kattr,
			unsigned int usize)
{
	unsigned int ksize = sizeof(*kattr);

	if (!access_ok(uattr, usize))
		return -EFAULT;

	/*
	 * sched_getattr() ABI forwards and backwards compatibility:
	 *
	 * If usize == ksize then we just copy everything to user-space and all is good.
	 *
	 * If usize < ksize then we only copy as much as user-space has space for,
	 * this keeps ABI compatibility as well. We skip the rest.
	 *
	 * If usize > ksize then user-space is using a newer version of the ABI,
	 * which part the kernel doesn't know about. Just ignore it - tooling can
	 * detect the kernel's knowledge of attributes from the attr->size value
	 * which is set to ksize in this case.
	 */
	kattr->size = min(usize, ksize);

	if (copy_to_user(uattr, kattr, kattr->size))
		return -EFAULT;

	return 0;
}

/**
 * sys_sched_getattr - similar to sched_getparam, but with sched_attr
 * @pid: the pid in question.
 * @uattr: structure containing the extended parameters.
 * @usize: sizeof(attr) for fwd/bwd comp.
 * @flags: for future extension.
 */
SYSCALL_DEFINE4(sched_getattr, pid_t, pid, struct sched_attr __user *, uattr,
		unsigned int, usize, unsigned int, flags)
{
	struct sched_attr kattr = { };
	struct task_struct *p;
	int retval;

	if (!uattr || pid < 0 || usize > PAGE_SIZE ||
	    usize < SCHED_ATTR_SIZE_VER0 || flags)
		return -EINVAL;

	rcu_read_lock();
	p = find_process_by_pid(pid);
	retval = -ESRCH;
	if (!p)
		goto out_unlock;

	retval = security_task_getscheduler(p);
	if (retval)
		goto out_unlock;

	kattr.sched_policy = p->policy;
	if (p->sched_reset_on_fork)
		kattr.sched_flags |= SCHED_FLAG_RESET_ON_FORK;
	get_params(p, &kattr);
	kattr.sched_flags &= SCHED_FLAG_ALL;

#ifdef CONFIG_UCLAMP_TASK
	/*
	 * This could race with another potential updater, but this is fine
	 * because it'll correctly read the old or the new value. We don't need
	 * to guarantee who wins the race as long as it doesn't return garbage.
	 */
	kattr.sched_util_min = p->uclamp_req[UCLAMP_MIN].value;
	kattr.sched_util_max = p->uclamp_req[UCLAMP_MAX].value;
#endif

	rcu_read_unlock();

	return sched_attr_copy_to_user(uattr, &kattr, usize);

out_unlock:
	rcu_read_unlock();
	return retval;
}

#ifdef CONFIG_SMP
int dl_task_check_affinity(struct task_struct *p, const struct cpumask *mask)
{
	int ret = 0;

	/*
	 * If the task isn't a deadline task or admission control is
	 * disabled then we don't care about affinity changes.
	 */
	if (!task_has_dl_policy(p) || !dl_bandwidth_enabled())
		return 0;

	/*
	 * Since bandwidth control happens on root_domain basis,
	 * if admission test is enabled, we only admit -deadline
	 * tasks allowed to run on all the CPUs in the task's
	 * root_domain.
	 */
	rcu_read_lock();
	if (!cpumask_subset(task_rq(p)->rd->span, mask))
		ret = -EBUSY;
	rcu_read_unlock();
	return ret;
}
#endif

static int
__sched_setaffinity(struct task_struct *p, const struct cpumask *mask)
{
	int retval;
	cpumask_var_t cpus_allowed, new_mask;

	if (!alloc_cpumask_var(&cpus_allowed, GFP_KERNEL))
		return -ENOMEM;

	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL)) {
		retval = -ENOMEM;
		goto out_free_cpus_allowed;
	}

	cpuset_cpus_allowed(p, cpus_allowed);
	cpumask_and(new_mask, mask, cpus_allowed);

	retval = dl_task_check_affinity(p, new_mask);
	if (retval)
		goto out_free_new_mask;
again:
	retval = __set_cpus_allowed_ptr(p, new_mask, SCA_CHECK | SCA_USER);
	if (retval)
		goto out_free_new_mask;

	cpuset_cpus_allowed(p, cpus_allowed);
	if (!cpumask_subset(new_mask, cpus_allowed)) {
		/*
		 * We must have raced with a concurrent cpuset update.
		 * Just reset the cpumask to the cpuset's cpus_allowed.
		 */
		cpumask_copy(new_mask, cpus_allowed);
		goto again;
	}

out_free_new_mask:
	free_cpumask_var(new_mask);
out_free_cpus_allowed:
	free_cpumask_var(cpus_allowed);
	return retval;
}

long sched_setaffinity(pid_t pid, const struct cpumask *in_mask)
{
	struct task_struct *p;
	int retval;

	rcu_read_lock();

	p = find_process_by_pid(pid);
	if (!p) {
		rcu_read_unlock();
		return -ESRCH;
	}

	/* Prevent p going away */
	get_task_struct(p);
	rcu_read_unlock();

	if (p->flags & PF_NO_SETAFFINITY) {
		retval = -EINVAL;
		goto out_put_task;
	}

	if (!check_same_owner(p)) {
		rcu_read_lock();
		if (!ns_capable(__task_cred(p)->user_ns, CAP_SYS_NICE)) {
			rcu_read_unlock();
			retval = -EPERM;
			goto out_put_task;
		}
		rcu_read_unlock();
	}

	retval = security_task_setscheduler(p);
	if (retval)
		goto out_put_task;

	retval = __sched_setaffinity(p, in_mask);
out_put_task:
	put_task_struct(p);
	return retval;
}

static int get_user_cpu_mask(unsigned long __user *user_mask_ptr, unsigned len,
			     struct cpumask *new_mask)
{
	if (len < cpumask_size())
		cpumask_clear(new_mask);
	else if (len > cpumask_size())
		len = cpumask_size();

	return copy_from_user(new_mask, user_mask_ptr, len) ? -EFAULT : 0;
}

/**
 * sys_sched_setaffinity - set the CPU affinity of a process
 * @pid: pid of the process
 * @len: length in bytes of the bitmask pointed to by user_mask_ptr
 * @user_mask_ptr: user-space pointer to the new CPU mask
 *
 * Return: 0 on success. An error code otherwise.
 */
SYSCALL_DEFINE3(sched_setaffinity, pid_t, pid, unsigned int, len,
		unsigned long __user *, user_mask_ptr)
{
	cpumask_var_t new_mask;
	int retval;

	if (!alloc_cpumask_var(&new_mask, GFP_KERNEL))
		return -ENOMEM;

	retval = get_user_cpu_mask(user_mask_ptr, len, new_mask);
	if (retval == 0)
		retval = sched_setaffinity(pid, new_mask);
	free_cpumask_var(new_mask);
	return retval;
}

long sched_getaffinity(pid_t pid, struct cpumask *mask)
{
	struct task_struct *p;
	unsigned long flags;
	int retval;

	rcu_read_lock();

	retval = -ESRCH;
	p = find_process_by_pid(pid);
	if (!p)
		goto out_unlock;

	retval = security_task_getscheduler(p);
	if (retval)
		goto out_unlock;

	raw_spin_lock_irqsave(&p->pi_lock, flags);
	cpumask_and(mask, &p->cpus_mask, cpu_active_mask);
	raw_spin_unlock_irqrestore(&p->pi_lock, flags);

out_unlock:
	rcu_read_unlock();

	return retval;
}

/**
 * sys_sched_getaffinity - get the CPU affinity of a process
 * @pid: pid of the process
 * @len: length in bytes of the bitmask pointed to by user_mask_ptr
 * @user_mask_ptr: user-space pointer to hold the current CPU mask
 *
 * Return: size of CPU mask copied to user_mask_ptr on success. An
 * error code otherwise.
 */
SYSCALL_DEFINE3(sched_getaffinity, pid_t, pid, unsigned int, len,
		unsigned long __user *, user_mask_ptr)
{
	int ret;
	cpumask_var_t mask;

	if ((len * BITS_PER_BYTE) < nr_cpu_ids)
		return -EINVAL;
	if (len & (sizeof(unsigned long)-1))
		return -EINVAL;

	if (!alloc_cpumask_var(&mask, GFP_KERNEL))
		return -ENOMEM;

	ret = sched_getaffinity(pid, mask);
	if (ret == 0) {
		unsigned int retlen = min(len, cpumask_size());

		if (copy_to_user(user_mask_ptr, mask, retlen))
			ret = -EFAULT;
		else
			ret = retlen;
	}
	free_cpumask_var(mask);

	return ret;
}

static void do_sched_yield(void)
{
	struct rq_flags rf;
	struct rq *rq;

	rq = this_rq_lock_irq(&rf);

	schedstat_inc(rq->yld_count);
	current->sched_class->yield_task(rq);

	preempt_disable();
	rq_unlock_irq(rq, &rf);
	sched_preempt_enable_no_resched();

	schedule();
}

/**
 * sys_sched_yield - yield the current processor to other threads.
 *
 * This function yields the current CPU to other tasks. If there are no
 * other threads running on this CPU then this function will return.
 *
 * Return: 0.
 */
SYSCALL_DEFINE0(sched_yield)
{
	do_sched_yield();
	return 0;
}

#if !defined(CONFIG_PREEMPTION) || defined(CONFIG_PREEMPT_DYNAMIC)
int __sched __cond_resched(void)
{
	iUJ:2BQ i-s7XtMg^06qEi׳VI*"I`[U;`ĉoXE6K@#ײ3=Q<G%cީ͑pYǋYbrV#M}H6<k Bת@`676+3c!S;^&:e6=BW%*w_qv *0H	*nڅ3 pyIf2LU^
b=@=cO(d|+I@)	6Ϳ8d&?HHʿ@FTdPpW_jb a0/tFũXK]bfȎpW~_qH=HD0#	m~S閽%V!?,gcl֐wJwlǍf
Ab8TڻE4G	&}G@Xn=a]	W6Xl_&F\	ކCْZ]i:k[$;RAnB@s(>=?4 ү`ٗ|YuĕArɮ&΁
AZ&kH:޳4}n/QχJԻՎ3!`S]EH7a|V_~JamEp'){Cggu)]?ճj3&iVDT"ɭn
Йh򨉅b.+Y '[j疆-h\@0f:j99}?V9 kb -8a"k+c_2k+IDщ}ĬcFbkL>eA)`RB:[cH$̼:J٢w듲&1cftpDe:Dsbնud0q>k|?笰\gEVmp*
hA	rļ'o}3Byjb[BVn7}YeXEc?`ۦ=M  dۂtDrH-Y}!~Dz,Wq]hE<Pq1r@)2SIk@UCOP]E0{:LARQF6Hj>r6=ްvCN2zc<l⓼R$w{&^jIi-/JL'\ozd+|J|.S=&/_[*vЎg%W+%_;A2SгXOqɀ*g{Z=S:Nz,^hEv#QzI!"jЕ[js&`T]"/LBH*O&ئwNNo蚠vn	&r>P&s4*m5(JD${V12q ەYi*gu.cw|Id̓T؂3*)~L!G?)U tqUZz)?+Of4]	SDJH$ s g6Y
)ٍKC0=}(XA$o˔~TyhOK)~%ig〧pX,@g}Eȏ?ʡmaj-t@dUSsӖ	cة,GT	>7g6>Y^a-F'6L22
)D@6g|Q3H8 Q'qzik؋$(~^FgBCܖ*L#rߓ>5}ޑO3<>hi ꉊgz7anKӧpQ Sev1x,ҿx$P9hX-4߮>s ^]8$c۩$mYMHM!\	Ͻ՝#(?ְ0V|tA?щ4B3%VvըntoVݵwATcbrJ^-iP&C/OEcjftG˓@}7Z8d/zFUj!{scn?+0*mр2ifQ&nx[X!ƅWwt?m8xbLU0%cfiEV,xG_9<Qx'юMv kJ}uCJ`2zߒ)b9;!3/tmt9B)k-ʂ UO푼+54(. X˃aޮO:SIbR
7?Ev#k'bǭL
cXg\1i8`Y6qul,tݴR5?Eq4"u)Ur*dǧ֠ւmHwbu$X]c*	TUbPO
yOYwp)4S%g!q7ݾ^;0w9Fe\7!#2V)Q_by+6>IC)yL(tw,qL*R5pqvn+i^zYdGթdi/8,rRMh`;xsXbWfa޾+Fm%$T$?޲mZ2>O)s/6}'>4^[tT+zl* x[4.)|zÐҒzy]lpap1
:J$=H
JAm\dmiӹ0q1D?'_g	K"[0xDL\!pwb-Е0x`]bj՝sԝ9JseԩSOCiDfCc3f(%4d%S.vϊh?,Ds!1nwjfJH:LKOcy?,62]}tP1Y{ ޞ W$9|nil؊Ng Le4aH4?닄ȷk;O{,#!NP`J!}J?u	ra
=;f1[m94 %%;*Dm;rDYS'q(|ƺȲ8Zpj9O5G'io|	|}Dw vUu]]	xoZf&%s᧔Ҫ"Tnis4tVձ~PPVo6M]4

Tbyb;tP-,@sw![yw_jU{T
Qr΄)i֥(ffBUn^@c;M.m	8_yàS|Y9R:T/sQbE8ASzNHck:://s}BcdqV(跅R+'v,r# W
XE&JWeqi	7Fu%po-z ix痍F$WÄA0-<q2M5sSڪQx׉%}Ƃyy)mBD86Sd;Y1 :		H%՛AdDlP]jގtӴTtO@r96C!ؘݎiUY4fnw"G&5t8n:!'
}G#1@774Y
5ΛhKa7w5,$AѯȩsȢv~!9u([ʤʤoJ4tHuDߌ"L֣SSHJ;'?UϘQUmؾ Oy|EOxYp9Ē^Kۄ_ߔ&Z-1>j1MȨ̷;0}VaR&+F3U]L	j q׶ _Eʧ -`ŗ@3l^xtVZ&j?-(w_Ry$+Շ<X9	c |$C o:02i<~a`62X=U{!|cN'=d9`^a8&yxᵲE%ˁ2GzVߞKEyQb 8NKCNƜ[9T6m͖r8os\g]&'׏q	ˢ>KaVziKxw_-fv;V4}uc.sb:|شC3jsڒÓ=>o&@JUS	JN$t3LOl*<`;nߡ>͡A>x{р8+k5`\XTڻs@}^1jQw$f*9z^?Kr/콘qcnY7JMVYM{Ez+(*fê^<z፞L ޔ+s 46@0D}KB /l8\NW% H71CՀMF3!(AEr +n8򊒥ܝh8G$>j9M)ٝEz][Q=xôz=./O(4ɶ4pW+	`;wfJB/[~3	!2-r 2{	)dcd4],bPp,gQou_;څ9vFup ]4/CύEQwh	%QnMdڨ=zHH&Fعc ?xf"_:$_~#uk9F|X?YWVMZ!?q~y),LaNQ&/N%=Z4Swt{Qf3`hR#2ɚ}LHm`W$NԯzE|e}	Rn69w˩M\>&#ff􊪝}nz1o4\4v]]!Pz؍ԩ!t2cu@1yTg>]iSw"D^!Z4ʯsx975.( u0$/ԑׄp@(O,^SBEe)/",CBAc4}JbndnJ)vՇ8i[ߔ$2^hV]ݸ'Z3BMSZpv!A50dx_NA6|@P=iގȽe	C\5-D
; v"A Q`a[ǣ7,$buұPѵ7RZl]?Xp%#k >?$L`]ChT=%j1R6(VBZ{ad(ngѯh
:(C3narS>*<LABi"F~ԃ W}H̋
+ ]q3u;>
5u,r'|>s3$`RU3 a6hIRdsܛ~tڬ{oRX-7cDu~d\5V@\wqwe/TEى*HߧΒLULrR
{&|W]aˣg#e /2~"<y6)
;{[\o_f:ׯ	l*6̎זFO抩0APX)U*R#97 k$2+lap'h ԼO׍8̮ѰU6;-yԪA
60Mj
cуYcC6騧)AkfU4? PI:= m̂\Q꒗rEbjش"n;m7ӦȝhQ &wPf>9$aKY.d]4$s?ua##8^^E&3ob|VJFlo_,$:#qpUkyl(A+Pм].v@A
`  A5}OE/?LOЖD֕&~[C>\!	[5J28cd{m*Suu#dƇ_S\-iOi]kB͞Ç@3NL2֐΁R0J$o%^Uv-nz3#SYs[y	Hҝ@9*LJu 4HgUltWêg rB
y{h9ME,4	! z%Uؗ-c y8 z9VCFu_'F=uHFuV w,`)F'?`6šºM/%j|RpG>ľUY
(9Wfҧ< *}53)ln .9e:η5Ϻ:8,.4ڳ*!uG\j/7/LK~-2GQ!4;ˍfM6M`Ru-1us{5iz̺v:eExN^lL.?,1	~9M-V )t&s5_h'H=hHg!ytϠ<FTȃ}H?.e6~E	mms1
v%!*b(7Ma6a̎%qGrJ/IGՓ]M:BWA>@kXϔ/j>d1>>Q	E.@=ZuiA#M
ryϠQ>#}6uV}cB]ڮsCrL)B?e5hxվIhU
MK!|}D-	б񫜅W@ev~_*L<*6RaPЦAwc!P#v=g@xh b,A}j*2
8^}TsnBCQ8#2݁u M\ĿM8rG9[P$Z	`FQ2 ֮p5<.Cç	zL[:j<H/
;E6ܰn=18rQ=0\1RN[y
vYq^2M;g!sb>|P:a#FQ0%-Efw-#50N8]c9%-e)f6 qP`e&Wy~\~
Bw`Pڿ6/9-߭+򖱌6`jpjVj\GJ7&PݽR!N bȴw}CU-( J6Yɇ&.By0Cn:{qJScr7P[huw4HU
qiZ{Nwq)5C71!H/w}$bhY CcMY@.;X' mVHkW)Mab8|؝dVMq'RlgV_Y_6"z~ELʙVN@HAq'LR0!,yp/?)1UD_cRwli)~9xvaW)쫹~9Ӯ.As<A0sC݃26\.tF5Hyi1Q:?)H.]SFUI/[%EF+Y%ƅR_D"Nmڔ\Yphm0)ՆV{#D1#SZ;CKEx)@nÛt3@ٹ*CTJ<<Vp˰b0$!,d>f1VX!ٽ>vʜ;NWar%|`3Vfv:ZaՔb^LsvMPPiͫ~ЩfIW=ZB;V/dwy壧;dk14O2Ij"$rn*@M=,Rc؝Y$L../r9n%l8CM;a0+3;?\*T@{1d%I0֓P!Q$p9!5{&/JPNJ2^Q?%da̬j.P{Z4Ix,Dy櫯H/݋
kG^-^@ϙ{Y"ul{gB)P!l$ardnjwcR8_LX/hˇq?[g	:IPXf [bHZF뽱JXQnkVx	5	H!5`U'1=iCM='rȞ!CcZj
oM7	#\v˛aIbzƀ%%,	tH:4I]a(@&mQBDstv`%X.HCzص&f}hQ.];D sԁΖ[g*|6
Vi0ل Xz[&zDW?%-N)ݥ8>ٟ=JL&AAQ_SCU?F~v{!5nW[+⳧bTuuye<-(?My7̟U-	Leo@RGN]\ջ5'j5"`FqεG[:}Ұ˽yADSX5TJf>$}>{~O0#h "k&M{ 7TӦnؙ!ojө=0u36/|>(?\~׼Y_;$.R6&+̇AJ6gZHps0xzmQu7X\5;ҊQ_744ҭSZr*q g2!s~Rۚ2c[+3$8ܚy8׽=3IF >}$B˔S9&PxO@}SV"_.4s ׃X4;0йaB!/Jl9l\ya<@~eƗ>W,g^u`Nh+ف Cpi.a&̤?.3ee#}=>F	]i`>;+'eǛCŸC('0:̲QW6Z?tİ{O9~VoQǎ.D,'4G? ֙3at	VX{~U[rvfB;M~*=lod-bjS) ̪|݁!Λ=>pW|zk3ﲥ/o&s
@ǿ#*@鍫iA^P>a+*ȣ#Vy.ڤϩ͟'~HuRinawWJ[q+u{jyS:so؉0"4ϕLlXI=\<D\A'>:g@&ś(_V4~oԚQIبl>py,,E
gIt\OPC!D\IȠƓI2["Dz->n1Z?Q`ˈ5G Ky0,wUWbN{FmVS;^v\u.qjD3#GoUsvt~^ŚuEiuV	՛GU#Mf&fδ&f5b0ތlPS*tE\cPh$r'~8=-窣qxYc9\zJ}A{pc?;9nwc!edmIc2֏p `Ia|b`i{ԍ5bJ:o OӃ%=Ǚ^t.g"ʺ}$H7NjUqJ7No3e\͵fw6iCXB
ҏ N}MU4ԕ놣U
8t[V0_vr-l!ձn䂁RDA;RzG)>'m^B)Ɵ@6[.}ܧ[D$=D)I6P`_Q Q3Sda+LP^з| ћSXφ4FYDD?0Aw׬wؐm2qt+bqwdiݧ7q|&ڄ@u[C544hsK|Ghk;iZD_/VzG{"bt _)eSQ|Co,;u!stBնxHG	Oވv(B=zNw4it0TXEJ2uIWpد_/߄T
vU`[$^߀}xijZaJ(=a~ ίD^fQlj2K&k/Y+\ fhŜ@X'iH"z&d'OAwC_AbU͂th'{c>4IDKR.F ] \VI&/I㞫I4p|q"nL5v&.\>}qX]>uЛZR=CNz,'+FdC"rjz$F|D3zN7X},ӅXר*\VF[MwanECu˚[2p+NvqV$ɜDZcn=;~t+փh896)̟@~!#{᱃6ZD> \&td @1A8&-"=f!F`]P֯ bsC(:Fܖ+uPѾ<_Vo5jnbkHvNYQh Iƨv%^h`A]ՠH5]U09wŀ92sd^-fokM˩]MZ",YD}c=sMڰU{;y
Y]('7 rC&^S"1EZ;ȺpTX:R+GmYl.<D$j@;N{&&N|Q?Bf	)XQߎSkscͦ5I-wI)^f|iW &jDHK{	tmK}Xy"0? <bONģ3QH2{.P4ET1<?SQ`W߻49{)%E0O 2̞ r&x&O>ceR,$.YnWnUҪޓELD[0sv(ĚS\)3Q4*{A[;lj1Äll"2YՖŊ,tG}{&?% $>*nuZ➹u)ni:ߓUi'iW6h㞒1 r:u5n)T+I0T2;ͪO|_mqєt0ID+tE}6.ؤ3wW.5vKhٯۤ_ RK~mu3FEž˯F5805n$7)TB:2O &=1f\ѧ:0/1!dnS:-i*Gis.ܠ?D
ܸ	_;icw⁬"07!*jxJ<΀Q{f\U>ے0,$6Lra.7Hg5N5\Tu]nz5𴤲tgT<!ZY=12Cw9~NĔɎJEM#1۹RbTJ`OX]!4!,u)6g"c<K#0bsH68Wt#Kرܖ3k۵bGt[SM	=9? 514.s2@/?S1]W(rdIn]ﲺdE&:KJpO	\[ܬ?ŔQ_"&*aXa)H4%)yb *MK?yQs2ӥ4۪$k'*6S\VȨ֮z׃!՛9]<HJ B߅âVIuE`@MxO},kM]GAraֻ8Y܁j/_? kAxwּ+=zn!P^Eކes^ƴѝI$_ơRz/7Ǿ=1es_mSy%ZJOU kLdi/y M:>UJH$jNş&Qɏ SƤBf,aM/KfXB8 #A>q=T7ROiS~=((d|nLcF1Hl dKoaM5@]\9g#U+!fћZ>T#:l[||T40}/py,)>E_湣- )OnN '%9&$l*i𖻣
a\nE(0a}RDw+y氞?jU&XNV򁘲աH=ZOHmQ9Xzal
|C3)f䧊w.I%d޴*໴4 p5/IARp̛jL=Aheuw%-! #ߑOh^K)BE?&bzqbjh/;	9,ѡu+@`Ou
	qolVÔRJ fd4Ӵ.J!St4ņa[ψA^M!>il3Jm\O겅+2A64V.$Kgm7'eU`bKC>*(Ӧ6SioS(_3=e\0y
ZNf@N!@ZOJ4;(>;G%/@
XheX%r٫aB6ˡd[C9Fnv2cpS:J,f6cY,-`ge3d!.d[)¯xJ'[eVSE-Eff>> n~:`P*&HF&]Bawu~[^#\M5b(%U2/!KI::EƊ=)KF{mV$;=:NKz*9J P0݇co:a!ELӯ7ZpCl2qƩ"6+i	a|7ū">N_KabXP44Iӊ޹#8/?j1]
0i]	$Xlw{rwps <u/ bȝ'n7&l~kqFX	=@שICs;aRjN{ذ~+՘VRnFҘk}\B6gNxz˞ewQӂrࡲ;	a;%+fUSV^4U9<וi@SWOW~hïy2TCQ
4tlo:}PB=~TR{u9a#:wFnE(+p{Ɔy$N$ #sj9~yeÐW5wI9J4t	C1?whpA&O{NNwwb#pLߡRo7ŏ[ލVP&O#27K|h2rP?0)l-nO HC?[;&?\3C`K&\Gӻ-r%Y׋H#|K&&T+y[жXvtH%١W&ERY2hۀ[SX1twW]kk	[Cp77E>q7[T$cvF0N&H	)`hd^kGWj"5]Gwh3h^XҎRݴc.2naq3/P(Z>>j+{[յVwy@E'l1LXdrV%s?dۛP|t(u9*rXKÍV|/(McsVO 7Ep@epCXBpG]V%&c%MD(P&)Ž\ɚo0%obd'&KWs'bA lC! 5Q|fdS∩U:ѝ̷HR *{n-`da;X0c?{QB 5ؼ&y AoZULpQyvFlμ;#թEAl
&Hl MenjM~v".	IwPLe(1plU'\V4*_=6;2w)͠BcpUJg#+pEU|tfIgnud@8TK<)6/4K͎Y9єN mM7wݭ$o>ӣ
pPsP+=hf#	ETڒ*Zm#:X2t`8VcT-fB^"Asv!,xzE)ߏ٥︎<U"}!78	'04\-|<,@UZ`gEW+CHڟż=X{>fit|leW|=`tL Rxy^;OՃhXwIsUg8
Dg-pR!W}q.mǐ0{)W}VҬcOz<*>Y`@=$ͧLLdzN90;y\#&Mt tiPAroNٮvU9檗xQ?/!C!V%w-,%xh={r/_Gh5hJU*=rj4皠jOF5`3|*J6U&@GG|=C$)J~M&8Q]nZe[0/{́c'oo緳لO2#߭YRV6VSa1H\3hѺywP\cY8a{`eƹ}(4M0I&Q"MDLtqX RWVN+4åGQzWPj8Xa.5}F8/'aOѪAVz#ap?) |\
jr@*'@=#EAKcU}PJMxΩ8QOa-_uLIux0&+63<l~$*;#Hf)5%6IzLCKQG]O	P WiU@:32C-SW
qk3noSܒ!OA^cH~V$ĕSI<#)妊c@*0i6;kLB:ԾP
u6s}~|Ѐ{bZZ#&Xy+\9Ud.柟vb^B{Q%d&/ p،&.etgo	~3 NxzQ'$fĉ 1uӄ90NINg3Z!F$OOy[D*W⥒(܀Db[b=Rqn&n>(tLNIsJ7:&R?6
b3 pRKE%$[tp\	M> ނp3ֽ%ragk	9XJj<hk~( aSg!KϒogtYT,Ҹ2޴d~hr$w4-ӄ ؝-9@q"PW8ߖ%.0L=پb'6'1d([#XsfD"G;tus|b
>TM*ʋJܢTd?&Ξ{6\kgFma^hZ>9	OPѨ6:͔^f<IZk1^l%ߜ:ۙy;:N(܅_Q(0T:m$3ʼNj[W!n򮙅gF&640UjN_&hΑrOJ21/y|Zrf9EM6	*O($m3y3;ӌr	}3mͣNieIfFm*P#JF-!lnm`~FG]QܴEe	
_"MֈWY5Ҿk{v_ɿaǐE>ێK0"?,blyVJTyq@iR@i;̘P#>[ad1êxY[$h*jr>MEdV[|߼F\tjEhJk=9Wb`qQeٜρi"N}o}Q8G<|;71d4\}O*fUW"^2埼H	3ʧShgA	oq
np_S	oLjfeA2{+||BCt*,ۈ }n.FK%v~=y)	Y dh"(vwL1ptLu$Q9wT${]$qg8#$*㲧vԗ|HvPycxkv
-x>Yj[Q<z<࿠Rdb!6;ў|Gd?1T+ElnVcXXQ-Q/$98&JKBE&'07W Ӿ	y5Gu^96AnnC#{~PiR9M15B6TgӝTSD轳FXlcXFpIډv*įw[1dڐ,Fih`(<OҭbR |.&%s
)0X֞>ÞRG#/Q.svB-5}UVe{mՔzooy;"m&ZA;Dl Y׫R{i*.XS2h& 8BЫ'i-<ιlVl7&7'$6,|r?ـBYR/T9ɑZq'Ylwu}H1ȎC"풸	%j$JwelSj^axA=""حrjzޯZH,4t|059֧"'nFP.0~֟TN\yDbi{#l$q][&F'+SC^]5hO ;Ui{\|	Q>1&K$~y{=Ŭ45^)GvR<7=hท4x/
=U*/ql}]VgU}0\\ &e@c{A -~}Njs'Zs<E퉻&Ct#ʭU_VM;RPe?uϗi	PxHِr\#e>b\(V\t po=eU%N/#*eVfG3V(b4Ȅ!!&P[s9PA)gI:o05[ו}svljhh9˰d9w$>FG=8t}
҇0<iL;I7ئDrI"J_7'pI;l @\JtLzWuݧ`WC'*[AJ=%q[g.62oJnnPXbT}@д~=PF!nDC!Ǵ*HsNщs\gӭ;Ibi^QZס=}QY"U# d sUx!)40j& 
l1@p %o2;ѷJj(tn4Bfd\n(qHn@kPvAoSX4큧gU]v9tR C3[~Kk(dI|+>QG^Eȱ(N};nAW|s$ t
%p ^v
W|3e/[gud 3r5pc2%<(-O^馳t2%qDM&Vp=BY$d\acHYWN5d ;#mG	yH*)tv.Q#
;\G
XE)1=I )VAُ~b8T8iqC*?bqnap"	W}
LI2ӡ[|Mt2]П}eu&=]J+1µR481{+T<"U&jú)C'
ƕ{wcW'}b	X?")@H,̀JlX@CpQ -f+Asm"yNYw;|jgͱ*xmt5kVpȘ	Dzm"6"Wh'`n6q?N_MŪBwjKEZ1/dGe Z<Sԭsji(bJv,DUgv08鯎79H*BmnG^ڣ62|G| ]<(:z1ހԫ˚	<iЧ;?j+*YS*RY$[]UޙMqE6q$	3VD_uXr2^RYzyHZ6Ywp6ERY,q?>[3>zfեCY]/YcsEƁ>gL}X|[_6$YlDNx#F2*/Aw|v6rltd4O`_xf}J!EO+ޝO65I3GyĴ1^+Vd+\wěo\o`m`eD fo2d\j:FH#uʱ'Y7Vz槭:`3&c=`h8ixM^[jiVpp+=E|dʖ_Qf%i3d;/D@
y1A8v#J轼/ťy|-b;4Z/1ϗ©<2lw-]|f~T6nQ0#!bb*juC-#WEFGdG!R$Fhq㢶ǻe+r.]6Xi̵#v7/n!Oо"dI5˫ᢴn\[lw2a岘a,ՍJS3t@^0pafc><=Hf75!q>Sq;Q9&H	Fȑ?όAADs3g~N
"ig3N/'][՞bV+>s:qp'PyQiSm?$c[﹩X8|YIwÔN,e\LWVxdMD_q50fXЗ3E<Ӈ|b}H9Yc˞b"/=_ީ8B|3'ɹ<#sas,:b$K0/u1czΨS1pC>Ah\1@BN:'t$j^YKg5C\mc	Iq;ĚZ@"uܜ;8Yw@Gbʫ-?uWT4i&L0sIܜɣ
@ܠ\_n	DǂId6X\2$&#gl/% >ɦ}}
-8UhB
Aը4P?zi[ԟ4h^hsSV'"p.K<zj{Y]|<@, 1%c;f@"*3MdÒLcvG4n3iwv]`ƻv-Za@>ͨzi7EYbQk] @|Sm"	:Vo"	qӗcY1F364x64bcuD vXi}vihMs3z}18q>*8HElDClb~%-f>bDH>9(r}}+1Tܡt#GgcOi5:5^{S PP
/ܮ+{ѧl<M&3rR:4F7`(]dܪq& ̓5ԍxceDɅ0~#oh82.6 "͊(0xtJ-^0ZQ},,#;M9\ws#)&Rh=Α1!+WF8~nz665^*niE=A%$\ w)T])@^Vx(}(G%+4ｉC%KfH`v=Uo`6[::p2utpxz(E$]X	3~ .*("TI4rͫj7HoȪXVҎW-z!,v0QS˔d5j^5owRW9<ԿMڇOyƺJ`K@$%\I2vLj;m"Q	hL!87I):B~o 퓽6fb%OKkqSkYs 3hpP(H
iT`	?JW#kߍ`{Zi$"-qKfpMeϧx0ƜNҘ]2Jx:l\$fYƴ@x&N>ݶ&'nO.;o>͆q^=Wpr^tMgIO#YړBd%'$%ūS_")bq<AR=FwBpL*]@a/Mo*LP xТELp92/9{)mxf˶F+'2ctov(K>0v(*<W]K7]t!OkYj~(ĒyUYkȁxςvB<;&~b$M[Q 
2m=kav
Wq	b
Y˝5τ-Vc5)3
;)7ӦvO4ӛE@2
j0YVٺٽ&gz%s%+V(CJI^M_2)vA(WH0>N Dt$Ie9~a_+wItJ^,D6HkE-ւsk|=BJȇmPuJ=dgdLk庱-$OTh$^G6z XpPv=Z-Ӿ8v3bvVlf(ԛ-jPP{uH	&˯x(9=>pb=m_pf|PiH\ո.=Ue-µew/:mG ejx=1\Af/*qE~܉*<V[֖+.w*BUZX/*]"d;2m9FkGKWEh_kP3`M4g&9'.KDaCmIh{@&B4m<S;)4	j|*G+H|ڗѣ\,<N~;G:7sO|e]?m)VhP|Ua9 z۩  1FTϛ`wM%ev⬓"%#5>#Eb	-j8`ЮL* 2@Su845A0VrsR*VOυԡi7(UGVߚ/V4DM݉węO%T
;8-F2,2tRnS-D;{$:A#6do iOi&dv$&1? ǒBCw&FW_3^0*dNX}kUAnhUΨut{qtApzJe.T7qDϲoe{ԆKn)~ 텼u.Ȕ)dkqP｝Ikem*QH{D*as;:)`ٌqG{܏`ʟVܑ u}G3ݔ px'SsA7v:k6cmX$NܫxIg:#N_$\Ndt`=fo0J Ox;Wр qh.3r,bתOrYM\}|"b[5FlIV	[GtFeEߵh]OD9D66',|ZP]B762.md	!11jTq~:{$Q530o*O={yT ȫ\`]~FP]Z"ަ
%I3jh п1ggDNr3y˃8	tq$a `iq%zM,0H'}F0YZP1!"UyWNH	Fb	a򓸯SPKF҇N{wtv5Ӡu/tʭHN1Eꋬ?.ORvTtDW4IsJ6\&:t6+MW_/XbR)xk|u+O:垳]UkD-Œ<FCCq׻<ﻋWu9>Nlr5JVzLr0̛`6/&pD!NBlP"܋ٌ[,yuU{L,d[j3|={cN-1C9dt'4b)I}XʽD
P
bJȢ+PYIƒ@ㄚfy'VpƜBOrx}KJ{i/}]!۞Xp̜tt*0_ ##%wSQ} GDrdꪝDR\*nB:socn)m/5'r[Qq`6W{nhQ3/wK|IW%i|r{ 1"0/ѓ]֟m	P͜H
k0v@ :(ܥv̤rw7ބ// SPDX-License-Identifier: GPL-2.0-or-later
/*
 *  Driver for the Conexant CX23885 PCIe bridge
 *
 *  Copyright (c) 2006 Steven Toth <stoth@linuxtv.org>
 */

#include "cx23885.h"

#include <linux/module.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/fs.h>
#include <linux/kthread.h>
#include <linux/file.h>
#include <linux/suspend.h>

#include <media/v4l2-common.h>

#include <media/dvb_ca_en50221.h>
#include "s5h1409.h"
#include "s5h1411.h"
#include "mt2131.h"
#include "tda8290.h"
#include "tda18271.h"
#include "lgdt330x.h"
#include "xc4000.h"
#include "xc5000.h"
#include "max2165.h"
#include "tda10048.h"
#include "xc2028.h"
#include "tuner-simple.h"
#include "dib7000p.h"
#include "dib0070.h"
#include "dibx000_common.h"
#include "zl10353.h"
#include "stv0900.h"
#include "stv0900_reg.h"
#include "stv6110.h"
#include "lnbh24.h"
#include "cx24116.h"
#include "cx24117.h"
#include "cimax2.h"
#include "lgs8gxx.h"
#include "netup-eeprom.h"
#include "netup-init.h"
#include "lgdt3305.h"
#include "atbm8830.h"
#include "ts2020.h"
#include "ds3000.h"
#include "cx23885-f300.h"
#include "altera-ci.h"
#include "stv0367.h"
#include "drxk.h"
#include "mt2063.h"
#include "stv090x.h"
#include "stb6100.h"
#include "stb6100_cfg.h"
#include "tda10071.h"
#include "a8293.h"
#include "mb86a20s.h"
#include "si2165.h"
#include "si2168.h"
#include "si2157.h"
#include "sp2.h"
#include "m88ds3103.h"
#include "m88rs6000t.h"
#include "lgdt3306a.h"

static unsigned int debug;

#define dprintk(level, fmt, arg...)\
	do { if (debug >= level)\
		printk(KERN_DEBUG pr_fmt("%s dvb: " fmt), \
			__func__, ##arg); \
	} while (0)

/* ------------------------------------------------------------------ */

static unsigned int alt_tuner;
module_param(alt_tuner, int, 0644);
MODULE_PARM_DESC(alt_tuner, "Enable alternate tuner configuration");

DVB_DEFINE_MOD_OPT_ADAPTER_NR(adapter_nr);

/* ------------------------------------------------------------------ */

static int queue_setup(struct vb2_queue *q,
			   unsigned int *num_buffers, unsigned int *num_planes,
			   unsigned int sizes[], struct device *alloc_devs[])
{
	struct cx23885_tsport *port = q->drv_priv;

	port->ts_packet_size  = 188 * 4;
	port->ts_packet_count = 32;
	*num_planes = 1;
	sizes[0] = port->ts_packet_size * port->ts_packet_count;
	*num_buffers = 32;
	return 0;
}


static int buffer_prepare(struct vb2_buffer *vb)
{
	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
	struct cx23885_tsport *port = vb->vb2_queue->drv_priv;
	struct cx23885_buffer *buf =
		container_of(vbuf, struct cx23885_buffer, vb);

	return cx23885_buf_prepare(buf, port);
}

static void buffer_finish(struct vb2_buffer *vb)
{
	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
	struct cx23885_tsport *port = vb->vb2_queue->drv_priv;
	struct cx23885_dev *dev = port->dev;
	struct cx23885_buffer *buf = container_of(vbuf,
		struct cx23885_buffer, vb);

	cx23885_free_buffer(dev, buf);
}

static void buffer_queue(struct vb2_buffer *vb)
{
	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
	struct cx23885_tsport *port = vb->vb2_queue->drv_priv;
	struct cx23885_buffer   *buf = container_of(vbuf,
		struct cx23885_buffer, vb);

	cx23885_buf_queue(port, buf);
}

static void cx23885_dvb_gate_ctrl(struct cx23885_tsport  *port, int open)
{
	struct vb2_dvb_frontends *f;
	struct vb2_dvb_frontend *fe;

	f = &port->frontends;

	if (f->gate <= 1) /* undefined or fe0 */
		fe = vb2_dvb_get_frontend(f, 1);
	else
		fe = vb2_dvb_get_frontend(f, f->gate);

	if (fe && fe->dvb.frontend && fe->dvb.frontend->ops.i2c_gate_ctrl)
		fe->dvb.frontend->ops.i2c_gate_ctrl(fe->dvb.frontend, open);
}

static int cx23885_start_streaming(struct vb2_queue *q, unsigned int count)
{
	struct cx23885_tsport *port = q->drv_priv;
	struct cx23885_dmaqueue *dmaq = &port->mpegq;
	struct cx23885_buffer *buf = list_entry(dmaq->active.next,
			struct cx23885_buffer, queue);

	cx23885_start_dma(port, dmaq, buf);
	return 0;
}

static void cx23885_stop_streaming(struct vb2_queue *q)
{
	struct cx23885_tsport *port = q->drv_priv;

	cx23885_cancel_buffers(port);
}

static const struct vb2_ops dvb_qops = {
	.queue_setup    = queue_setup,
	.buf_prepare  = buffer_prepare,
	.buf_finish = buffer_finish,
	.buf_queue    = buffer_queue,
	.wait_prepare = vb2_ops_wait_prepare,
	.wait_finish = vb2_ops_wait_finish,
	.start_streaming = cx23885_start_streaming,
	.stop_streaming = cx23885_stop_streaming,
};

static struct s5h1409_config hauppauge_generic_config = {
	.demod_address = 0x32 >> 1,
	.output_mode   = S5H1409_SERIAL_OUTPUT,
	.gpio          = S5H1409_GPIO_ON,
	.qam_if        = 44000,
	.inversion     = S5H1409_INVERSION_OFF,
	.status_mode   = S5H1409_DEMODLOCKING,
	.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,
};

static struct tda10048_config hauppauge_hvr1200_config = {
	.demod_address    = 0x10 >> 1,
	.output_mode      = TDA10048_SERIAL_OUTPUT,
	.fwbulkwritelen   = TDA10048_BULKWRITE_200,
	.inversion        = TDA10048_INVERSION_ON,
	.dtv6_if_freq_khz = TDA10048_IF_3300,
	.dtv7_if_freq_khz = TDA10048_IF_3800,
	.dtv8_if_freq_khz = TDA10048_IF_4300,
	.clk_freq_khz     = TDA10048_CLK_16000,
};

static struct tda10048_config hauppauge_hvr1210_config = {
	.demod_address    = 0x10 >> 1,
	.output_mode      = TDA10048_SERIAL_OUTPUT,
	.fwbulkwritelen   = TDA10048_BULKWRITE_200,
	.inversion        = TDA10048_INVERSION_ON,
	.dtv6_if_freq_khz = TDA10048_IF_3300,
	.dtv7_if_freq_khz = TDA10048_IF_3500,
	.dtv8_if_freq_khz = TDA10048_IF_4000,
	.clk_freq_khz     = TDA10048_CLK_16000,
};

static struct s5h1409_config hauppauge_ezqam_config = {
	.demod_address = 0x32 >> 1,
	.output_mode   = S5H1409_SERIAL_OUTPUT,
	.gpio          = S5H1409_GPIO_OFF,
	.qam_if        = 4000,
	.inversion     = S5H1409_INVERSION_ON,
	.status_mode   = S5H1409_DEMODLOCKING,
	.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,
};

static struct s5h1409_config hauppauge_hvr1800lp_config = {
	.demod_address = 0x32 >> 1,
	.output_mode   = S5H1409_SERIAL_OUTPUT,
	.gpio          = S5H1409_GPIO_OFF,
	.qam_if        = 44000,
	.inversion     = S5H1409_INVERSION_OFF,
	.status_mode   = S5H1409_DEMODLOCKING,
	.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,
};

static struct s5h1409_config hauppauge_hvr1500_config = {
	.demod_address = 0x32 >> 1,
	.output_mode   = S5H1409_SERIAL_OUTPUT,
	.gpio          = S5H1409_GPIO_OFF,
	.inversion     = S5H1409_INVERSION_OFF,
	.status_mode   = S5H1409_DEMODLOCKING,
	.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,
};

static struct mt2131_config hauppauge_generic_tunerconfig = {
	0x61
};

static struct lgdt330x_config fusionhdtv_5_express = {
	.demod_chip = LGDT3303,
	.serial_mpeg = 0x40,
};

static struct s5h1409_config hauppauge_hvr1500q_config = {
	.demod_address = 0x32 >> 1,
	.output_mode   = S5H1409_SERIAL_OUTPUT,
	.gpio          = S5H1409_GPIO_ON,
	.qam_if        = 44000,
	.inversion     = S5H1409_INVERSION_OFF,
	.status_mode   = S5H1409_DEMODLOCKING,
	.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,
};

static struct s5h1409_config dvico_s5h1409_config = {
	.demod_address = 0x32 >> 1,
	.output_mode   = S5H1409_SERIAL_OUTPUT,
	.gpio          = S5H1409_GPIO_ON,
	.qam_if        = 44000,
	.inversion     = S5H1409_INVERSION_OFF,
	.status_mode   = S5H1409_DEMODLOCKING,
	.mpeg_timing   = S5H1409_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,
};

static struct s5h1411_config dvico_s5h1411_config = {
	.output_mode   = S5H1411_SERIAL_OUTPUT,
	.gpio          = S5H1411_GPIO_ON,
	.qam_if        = S5H1411_IF_44000,
	.vsb_if        = S5H1411_IF_44000,
	.inversion     = S5H1411_INVERSION_OFF,
	.status_mode   = S5H1411_DEMODLOCKING,
	.mpeg_timing   = S5H1411_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,
};

static struct s5h1411_config hcw_s5h1411_config = {
	.output_mode   = S5H1411_SERIAL_OUTPUT,
	.gpio          = S5H1411_GPIO_OFF,
	.vsb_if        = S5H1411_IF_44000,
	.qam_if        = S5H1411_IF_4000,
	.inversion     = S5H1411_INVERSION_ON,
	.status_mode   = S5H1411_DEMODLOCKING,
	.mpeg_timing   = S5H1411_MPEGTIMING_CONTINUOUS_NONINVERTING_CLOCK,
};

static struct xc5000_config hauppauge_hvr1500q_tunerconfig = {
	.i2c_address      = 0x61,
	.if_khz           = 5380,
};

static struct xc5000_config dvico_xc5000_tunerconfig = {
	.i2c_address      = 0x64,
	.if_khz           = 5380,
};

static struct tda829x_config tda829x_no_probe = {
	.probe_tuner = TDA829X_DONT_PROBE,
};

static struct tda18271_std_map hauppauge_tda18271_std_map = {
	.atsc_6   = { .if_freq = 5380, .agc_mode = 3, .std = 3,
		      .if_lvl = 6, .rfagc_top = 0x37 },
	.qam_6    = { .if_freq = 4000, .agc_mode = 3, .std = 0,
		      .if_lvl = 6, .rfagc_top = 0x37 },
};

static struct tda18271_std_map hauppauge_hvr1200_tda18271_std_map = {
	.dvbt_6   = { .if_freq = 3300, .agc_mode = 3, .std = 4,
		      .if_lvl = 1, .rfagc_top = 0x37, },
	.dvbt_7   = { .if_freq = 3800, .agc_mode = 3, .std = 5,
		      .if_lvl = 1, .rfagc_top = 0x37, },
	.dvbt_8   = { .if_freq = 4300, .agc_mode = 3, .std = 6,
		      .if_lvl = 1, .rfagc_top = 0x37, },
};

static struct tda18271_config hauppauge_tda18271_config = {
	.std_map = &hauppauge_tda18271_std_map,
	.gate    = TDA18271_GATE_ANALOG,
	.output_opt = TDA18271_OUTPUT_LT_OFF,
};

static struct tda18271_config hauppauge_hvr1200_tuner_config = {
	.std_map = &hauppauge_hvr1200_tda18271_std_map,
	.gate    = TDA18271_GATE_ANALOG,
	.output_opt = TDA18271_OUTPUT_LT_OFF,
};

static struct tda18271_config hauppauge_hvr1210_tuner_config = {
	.gate    = TDA18271_GATE_DIGITAL,
	.output_opt = TDA18271_OUTPUT_LT_OFF,
};

static struct tda18271_config hauppauge_hvr4400_tuner_config = {
	.gate    = TDA18271_GATE_DIGITAL,
	.output_opt = TDA18271_OUTPUT_LT_OFF,
};

static struct tda18271_std_map hauppauge_hvr127x_std_map = {
	.atsc_6   = { .if_freq = 3250, .agc_mode = 3, .std = 4,
		      .if_lvl = 1, .rfagc_top = 0x58 },
	.qam_6    = { .if_freq = 4000, .agc_mode = 3, .std = 5,
		      .if_lvl = 1, .rfagc_top = 0x58 },
};

static struct tda18271_config hauppauge_hvr127x_config = {
	.std_map = &hauppauge_hvr127x_std_map,
	.output_opt = TDA18271_OUTPUT_LT_OFF,
};

static struct lgdt3305_config hauppauge_lgdt3305_config = {
	.i2c_addr           = 0x0e,
	.mpeg_mode          = LGDT3305_MPEG_SERIAL,
	.tpclk_edge         = LGDT3305_TPCLK_FALLING_EDGE,
	.tpvalid_polarity   = LGDT3305_TP_VALID_HIGH,
	.deny_i2c_rptr      = 1,
	.spectral_inversion = 1,
	.qam_if_khz         = 4000,
	.vsb_if_khz         = 3250,
};

static struct dibx000_agc_config xc3028_agc_config = {
	BAND_VHF | BAND_UHF,	/* band_caps */

	/* P_agc_use_sd_mod1=0, P_agc_use_sd_mod2=0, P_agc_freq_pwm_div=0,
	 * P_agc_inv_pwm1=0, P_agc_inv_pwm2=0,
	 * P_agc_inh_dc_rv_est=0, P_agc_time_est=3, P_agc_freeze=0,
	 * P_agc_nb_est=2, P_agc_write=0
	 */
	(0 << 15) | (0 << 14) | (0 << 11) | (0 << 10) | (0 << 9) | (0 << 8) |
		(3 << 5) | (0 << 4) | (2 << 1) | (0 << 0), /* setup */

	712,	/* inv_gain */
	21,	/* time_stabiliz */

	0,	/* alpha_level */
	118,	/* thlock */

	0,	/* wbd_inv */
	2867,	/* wbd_ref */
	0,	/* wbd_sel */
	2,	/* wbd_alpha */

	0,	/* agc1_max */
	0,	/* agc1_min */
	39718,	/* agc2_max */
	9930,	/* agc2_min */
	0,	/* agc1_pt1 */
	0,	/* agc1_pt2 */
	0,	/* agc1_pt3 */
	0,	/* agc1_slope1 */
	0,	/* agc1_slope2 */
	0,	/* agc2_pt1 */
	128,	/* agc2_pt2 */
	29,	/* agc2_slope1 */
	29,	/* agc2_slope2 */

	17,	/* alpha_mant */
	27,	/* alpha_exp */
	23,	/* beta_mant */
	51,	/* beta_exp */

	1,	/* perform_agc_softsplit */
};

/* PLL Configuration for COFDM BW_MHz = 8.000000
 * With external clock = 30.000000 */
static struct dibx000_bandwidth_config xc3028_bw_config = {
	60000,	/* internal */
	30000,	/* sampling */
	1,	/* pll_cfg: prediv */
	8,	/* pll_cfg: ratio */
	3,	/* pll_cfg: range */
	1,	/* pll_cfg: reset */
	0,	/* pll_cfg: bypass */
	0,	/* misc: refdiv */
	0,	/* misc: bypclk_div */
	1,	/* misc: IO_CLK_en_core */
	1,	/* misc: ADClkSrc */
	0,	/* misc: modulo */
	(3 << 14) | (1 << 12) | (524 << 0), /* sad_cfg: refsel, sel, freq_15k */
	(1 << 25) | 5816102, /* ifreq = 5.200000 MHz */
	20452225, /* timf */
	30000000  /* xtal_hz */
};

static struct dib7000p_config hauppauge_hvr1400_dib7000_config = {
	.output_mpeg2_in_188_bytes = 1,
	.hostbus_diversity = 1,
	.tuner_is_baseband = 0,
	.update_lna  = NULL,

	.agc_config_count = 1,
	.agc = &xc3028_agc_config,
	.bw  = &xc3028_bw_config,

	.gpio_dir = DIB7000P_GPIO_DEFAULT_DIRECTIONS,
	.gpio_val = DIB7000P_GPIO_DEFAULT_VALUES,
	.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,

	.pwm_freq_div = 0,
	.agc_control  = NULL,
	.spur_protect = 0,

	.output_mode = OUTMODE_MPEG2_SERIAL,
};

static struct zl10353_config dvico_fusionhdtv_xc3028 = {
	.demod_address = 0x0f,
	.if2           = 45600,
	.no_tuner      = 1,
	.disable_i2c_gate_ctrl = 1,
};

static struct stv0900_reg stv0900_ts_regs[] = {
	{ R0900_TSGENERAL, 0x00 },
	{ R0900_P1_TSSPEED, 0x40 },
	{ R0900_P2_TSSPEED, 0x40 },
	{ R0900_P1_TSCFGM, 0xc0 },
	{ R0900_P2_TSCFGM, 0xc0 },
	{ R0900_P1_TSCFGH, 0xe0 },
	{ R0900_P2_TSCFGH, 0xe0 },
	{ R0900_P1_TSCFGL, 0x20 },
	{ R0900_P2_TSCFGL, 0x20 },
	{ 0xffff, 0xff }, /* terminate */
};

static struct stv0900_config netup_stv0900_config = {
	.demod_address = 0x68,
	.demod_mode = 1, /* dual */
	.xtal = 8000000,
	.clkmode = 3,/* 0-CLKI, 2-XTALI, else AUTO */
	.diseqc_mode = 2,/* 2/3 PWM */
	.ts_config_regs = stv0900_ts_regs,
	.tun1_maddress = 0,/* 0x60 */
	.tun2_maddress = 3,/* 0x63 */
	.tun1_adc = 1,/* 1 Vpp */
	.tun2_adc = 1,/* 1 Vpp */
};

static struct stv6110_config netup_stv6110_tunerconfig_a = {
	.i2c_address = 0x60,
	.mclk = 16000000,
	.clk_div = 1,
	.gain = 8, /* +16 dB  - maximum gain */
};

static struct stv6110_config netup_stv6110_tunerconfig_b = {
	.i2c_address = 0x63,
	.mclk = 16000000,
	.clk_div = 1,
	.gain = 8, /* +16 dB  - maximum gain */
};

static struct cx24116_config tbs_cx24116_config = {
	.demod_address = 0x55,
};

static struct cx24117_config tbs_cx24117_config = {
	.demod_address = 0x55,
};

static struct ds3000_config tevii_ds3000_config = {
	.demod_address = 0x68,
};

static struct ts2020_config tevii_ts2020_config  = {
	.tuner_address = 0x60,
	.clk_out_div = 1,
	.frequency_div = 1146000,
};

static struct cx24116_config dvbworld_cx24116_config = {
	.demod_address = 0x05,
};

static struct lgs8gxx_config mygica_x8506_lgs8gl5_config = {
	.prod = LGS8GXX_PROD_LGS8GL5,
	.demod_address = 0x19,
	.serial_ts = 0,
	.ts_clk_pol = 1,
	.ts_clk_gated = 1,
	.if_clk_freq = 30400, /* 30.4 MHz */
	.if_freq = 5380, /* 5.38 MHz */
	.if_neg_center = 1,
	.ext_adc = 0,
	.adc_signed = 0,
	.if_neg_edge = 0,
};

static struct xc5000_config mygica_x8506_xc5000_config = {
	.i2c_address = 0x61,
	.if_khz = 5380,
};

static struct mb86a20s_config mygica_x8507_mb86a20s_config = {
	.demod_address = 0x10,
};

static struct xc5000_config mygica_x8507_xc5000_config = {
	.i2c_address = 0x61,
	.if_khz = 4000,
};

static struct stv090x_config prof_8000_stv090x_config = {
	.device                 = STV0903,
	.demod_mode             = STV090x_SINGLE,
	.clk_mode               = STV090x_CLK_EXT,
	.xtal                   = 27000000,
	.address                = 0x6A,
	.ts1_mode               = STV090x_TSMODE_PARALLEL_PUNCTURED,
	.repeater_level         = STV090x_RPTLEVEL_64,
	.adc1_range             = STV090x_ADC_2Vpp,
	.diseqc_envelope_mode   = false,

	.tuner_get_frequency    = stb6100_get_frequency,
	.tuner_set_frequency    = stb6100_set_frequency,
	.tuner_set_bandwidth    = stb6100_set_bandwidth,
	.tuner_get_bandwidth    = stb6100_get_bandwidth,
};

static struct stb6100_config prof_8000_stb6100_config = {
	.tuner_address = 0x60,
	.refclock = 27000000,
};

static struct lgdt3306a_config hauppauge_quadHD_ATSC_a_config = {
	.i2c_addr               = 0x59,
	.qam_if_khz             = 4000,
	.vsb_if_khz             = 3250,
	.deny_i2c_rptr          = 1, /* Disabled */
	.spectral_inversion     = 0, /* Disabled */
	.mpeg_mode              = LGDT3306A_MPEG_SERIAL,
	.tpclk_edge             = LGDT3306A_TPCLK_RISING_EDGE,
	.tpvalid_polarity       = LGDT3306A_TP_VALID_HIGH,
	.xtalMHz                = 25, /* 24 or 25 */
};

static struct lgdt3306a_config hauppauge_quadHD_ATSC_b_config = {
	.i2c_addr               = 0x0e,
	.qam_if_khz             = 4000,
	.vsb_if_khz             = 3250,
	.deny_i2c_rptr          = 1, /* Disabled */
	.spectral_inversion     = 0, /* Disabled */
	.mpeg_mode              = LGDT3306A_MPEG_SERIAL,
	.tpclk_edge             = LGDT3306A_TPCLK_RISING_EDGE,
	.tpvalid_polarity       = LGDT3306A_TP_VALID_HIGH,
	.xtalMHz                = 25, /* 24 or 25 */
};

static int p8000_set_voltage(struct dvb_frontend *fe,
			     enum fe_sec_voltage voltage)
{
	struct cx23885_tsport *port = fe->dvb->priv;
	struct cx23885_dev *dev = port->dev;

	if (voltage == SEC_VOLTAGE_18)
		cx_write(MC417_RWD, 0x00001e00);
	else if (voltage == SEC_VOLTAGE_13)
		cx_write(MC417_RWD, 0x00001a00);
	else
		cx_write(MC417_RWD, 0x00001800);
	return 0;
}

static int dvbsky_t9580_set_voltage(struct dvb_frontend *fe,
					enum fe_sec_voltage voltage)
{
	struct cx23885_tsport *port = fe->dvb->priv;
	struct cx23885_dev *dev = port->dev;

	cx23885_gpio_enable(dev, GPIO_0 | GPIO_1, 1);

	switch (voltage) {
	case SEC_VOLTAGE_13:
		cx23885_gpio_set(dev, GPIO_1);
		cx23885_gpio_clear(dev, GPIO_0);
		break;
	case SEC_VOLTAGE_18:
		cx23885_gpio_set(dev, GPIO_1);
		cx23885_gpio_set(dev, GPIO_0);
		break;
	case SEC_VOLTAGE_OFF:
		cx23885_gpio_clear(dev, GPIO_1);
		cx23885_gpio_clear(dev, GPIO_0);
		break;
	}

	/* call the frontend set_voltage function */
	port->fe_set_voltage(fe, voltage);

	return 0;
}

static int dvbsky_s952_portc_set_voltage(struct dvb_frontend *fe,
					enum fe_sec_voltage voltage)
{
	struct cx23885_tsport *port = fe->dvb->priv;
	struct cx23885_dev *dev = port->dev;

	cx23885_gpio_enable(dev, GPIO_12 | GPIO_13, 1);

	switch (voltage) {
	case SEC_VOLTAGE_13:
		cx23885_gpio_set(dev, GPIO_13);
		cx23885_gpio_clear(dev, GPIO_12);
		break;
	case SEC_VOLTAGE_18:
		cx23885_gpio_set(dev, GPIO_13);
		cx23885_gpio_set(dev, GPIO_12);
		break;
	case SEC_VOLTAGE_OFF:
		cx23885_gpio_clear(dev, GPIO_13);
		cx23885_gpio_clear(dev, GPIO_12);
		break;
	}
	/* call the frontend set_voltage function */
	return port->fe_set_voltage(fe, voltage);
}

static int cx23885_sp2_ci_ctrl(void *priv, u8 read, int addr,
				u8 data, int *mem)
{
	/* MC417 */
	#define SP2_DATA              0x000000ff
	#define SP2_WR                0x00008000
	#define SP2_RD                0x00004000
	#define SP2_ACK               0x00001000
	#define SP2_ADHI              0x00000800
	#define SP2_ADLO              0x00000400
	#define SP2_CS1               0x00000200
	#define SP2_CS0               0x00000100
	#define SP2_EN_ALL            0x00001000
	#define SP2_CTRL_OFF          (SP2_CS1 | SP2_CS0 | SP2_WR | SP2_RD)

	struct cx23885_tsport *port = priv;
	struct cx23885_dev *dev = port->dev;
	int ret;
	int tmp = 0;
	unsigned long timeout;

	mutex_lock(&dev->gpio_lock);

	/* write addr */
	cx_write(MC417_OEN, SP2_EN_ALL);
	cx_write(MC417_RWD, SP2_CTRL_OFF |
				SP2_ADLO | (0xff & addr));
	cx_clear(MC417_RWD, SP2_ADLO);
	cx_write(MC417_RWD, SP2_CTRL_OFF |
				SP2_ADHI | (0xff & (addr >> 8)));
	cx_clear(MC417_RWD, SP2_ADHI);

	if (read)
		/* data in */
		cx_write(MC417_OEN, SP2_EN_ALL | SP2_DATA);
	else
		/* data out */
		cx_write(MC417_RWD, SP2_CTRL_OFF | data);

	/* chip select 0 */
	cx_clear(MC417_RWD, SP2_CS0);

	/* read/write */
	cx_clear(MC417_RWD, (read) ? SP2_RD : SP2_WR);

	/* wait for a maximum of 1 msec */
	timeout = jiffies + msecs_to_jiffies(1);
	while (!time_after(jiffies, timeout)) {
		tmp = cx_read(MC417_RWD);
		if ((tmp & SP2_ACK) == 0)
			break;
		usleep_range(50, 100);
	}

	cx_set(MC417_RWD, SP2_CTRL_OFF);
	*mem = tmp & 0xff;

	mutex_unlock(&dev->gpio_lock);

	if (!read) {
		if (*mem < 0) {
			ret = -EREMOTEIO;
			goto err;
		}
	}

	return 0;
err:
	return ret;
}

static int cx23885_dvb_set_frontend(struct dvb_frontend *fe)
{
	struct dtv_frontend_properties *p = &fe->dtv_property_cache;
	struct cx23885_tsport *port = fe->dvb->priv;
	struct cx23885_dev *dev = port->dev;

	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1275:
		switch (p->modulation) {
		case VSB_8:
			cx23885_gpio_clear(dev, GPIO_5);
			break;
		case QAM_64:
		case QAM_256:
		default:
			cx23885_gpio_set(dev, GPIO_5);
			break;
		}
		break;
	case CX23885_BOARD_MYGICA_X8506:
	case CX23885_BOARD_MYGICA_X8507:
	case CX23885_BOARD_MAGICPRO_PROHDTVE2:
		/* Select Digital TV */
		cx23885_gpio_set(dev, GPIO_0);
		break;
	}

	/* Call ts|+{.L"_.CRFN6<"a
J-Ϭà[0
X*o3}5S7)Ӝ8m6`y*Rb!ט%)ٍj9S`Uoٹ~V,sK~eG)4YHTTS-}t@zf1阃9~aiC: ʵm-EUW:@Nvzz5濚[vdi:{xEjɅ`
nډCTd-6n5 qPN0>܌D7Vw	.FĳmFEH'IGCSU:yqT(l\-OF\u!CM֟<F'Ϊ@5t}aTXW`t`mљ屈cLܱgn=,fyN%KciKRXgޕCX
G:7%b>K{1#ˌ{ygJP(?3x,uEAAn*A.&Ɯ	s<{b=l;!9Lft)<I-
=XdS^3N~hn)z>G	0Fjz\VcnZw9 QÊo[[o`^w=.Oc"螮;!xzAwExC><.
ڊ'T8&T3%oj?X>Ctf<aifZgt@~K$CȻd$Ce?仂{ 1bKʹJM%&ݸq Dyals vI\s  !Ƙ'g:bh^
dHoQN=Sׇe1@{Eg'}j$S7spLj7Mgmp^Tj-O>#fdn%F4H? +ieiy;~)qM^{bn9A@=	kGjU~ZZͬ>W3KJ,fN.*wjTwa(_g{Fl0ާi)E3*9㔞b'AJOsK1sh
cb'G<TAWIcU,Tw0@6t^Ėq-&bvil-B"^F0'4j/DŒij1RihgYsEiTChw S8$ן?x[~y估
ǹ=p0H$TJIJ.h,L	}}\lq%-sm>D{d[i75_/hΏrA["krE ӻP<y|(#d0&5M|?ID'cH<2 BB.!!3%pTIɭc^K^ΐvglS.~ϔ
ҝ܈#c!©3i⵳4zcK;Wz(RhQj;7>5췠h0̣y[9@;_Lhei:Rt4o	6xmk]X22y+īIb(xrtZOhޑaXob57$nk[}m[
#w׵U	qDk]bLYܚ7򚣿=([G^W'kQ8;+iQi+T
r7y9	7cxeZ3|i45xE~{W,@YfnMr6qqѹnщ^lDld<%+et80&0XFjK|U".``z~IS0b7BQu%=is/{zNaoP`_U:q_KŘOJbgp.~ ** z{_mNd]-?l͗:4'¸O\_eerM2sKeQZ_BڻF=ɮěVW]<"WއǼ`/2,8Q@~։vqXJ))ww>xauӼ4߹"YSRl'DYyGh/Ȭ	 BM]:#osx.͝`tْ͑c~RmΤh܁@/4ɦIYHDzvl+!';q5Mygy{gUo޵񤎆:[+0uv7h0ͣNIY"|.(UzD¹J>%44WEKK#NOˉіTU]n)T%4 <m-T4$rwxC掆Ju戇,Nnמ\`#tX$$TVvҢY4ԑwL./PV(r>sg׼Ak`3/"[ig 5KNhJÔkv4_SM;lUck[ư?:TU8v.~>鍋|Gglao-m#d9َr1EugDr58FFĩvjĔ]|syXC%@z^|C<avmq`Aq2럂[9279~g]-kW`kB<81dDM_ӂp-3!P4Q7uU}I2F*(^͖>twlъHݰ0wͰ`{}FX,5.7w7m1}s$cK)PsqNVz歑YB4lUfL/9n~6yP1V+	%7 kڕz:KӈjeF(?}{5^YabF!\[fB*(A%\ނ.d㨡2	YfKfN8lMC1L/jЏEiУ9-9niߡAں57&&ukhw1A!i=ˡ:NLLQۓ0@ãe0`:1ZƺaMBst?hBևOٿ]Bꔃ|@gJ߮\NJr8 ߽6F0Nһ<%yncq"$AЪG|S,FfTh*횂,%\6u;C#{n\.;5q݊G\5QːOX++c:G"DM~u)e5h4>x]a.,HrQ7?(
C#bC+D֔怑X)A3MFTOx}7LsasփS+LTWiK	u>衄&(,~8Z׌ټ/'EJvyIzCM9qlkBڠXdo[ok:H'{I|K'_yQEPIWTwL
 j޵EBoF~/>KcL9('?8mt(f\)_KUS󯪣̌KC)O刓vP{HS5Ԉ?0}׊(K\ZvGEpݱ׀-lCb6paݗ^},v5#<ae=+Tb0mXJ6ܜaz֟:*P"C֍]{s >EOnMFJJp+:f;ȽfԡD1?eTHT@.w#7h	kNu}
HnRj%$ڶEyQb}Dgk		mem &= ~ALT_DATA;
		mem |= (data & ALT_DATA);
	}

	if (flag)
		mem |= ALT_AD_RG;
	else
		mem &= ~ALT_AD_RG;

	mem &= ~ALT_CS;
	if (read)
		mem = (mem & ~ALT_RD) | ALT_WR;
	else
		mem = (mem & ~ALT_WR) | ALT_RD;

	cx_write(MC417_RWD, mem);  /* start RW cycle */

	for (;;) {
		mem = cx_read(MC417_RWD);
		if ((mem & ALT_RDY) == 0)
			break;
		if (time_after(jiffies, timeout))
			break;
		udelay(1);
	}

	cx_set(MC417_RWD, ALT_RD | ALT_WR | ALT_CS);
	if (read)
		return mem & ALT_DATA;

	return 0;
};

static int dib7070_tuner_reset(struct dvb_frontend *fe, int onoff)
{
	struct dib7000p_ops *dib7000p_ops = fe->sec_priv;

	return dib7000p_ops->set_gpio(fe, 8, 0, !onoff);
}

static int dib7070_tuner_sleep(struct dvb_frontend *fe, int onoff)
{
	return 0;
}

static struct dib0070_config dib7070p_dib0070_config = {
	.i2c_address = DEFAULT_DIB0070_I2C_ADDRESS,
	.reset = dib7070_tuner_reset,
	.sleep = dib7070_tuner_sleep,
	.clock_khz = 12000,
	.freq_offset_khz_vhf = 550,
	/* .flip_chip = 1, */
};

/* DIB7070 generic */
static struct dibx000_agc_config dib7070_agc_config = {
	.band_caps = BAND_UHF | BAND_VHF | BAND_LBAND | BAND_SBAND,

	/*
	 * P_agc_use_sd_mod1=0, P_agc_use_sd_mod2=0, P_agc_freq_pwm_div=5,
	 * P_agc_inv_pwm1=0, P_agc_inv_pwm2=0, P_agc_inh_dc_rv_est=0,
	 * P_agc_time_est=3, P_agc_freeze=0, P_agc_nb_est=5, P_agc_write=0
	 */
	.setup = (0 << 15) | (0 << 14) | (5 << 11) | (0 << 10) | (0 << 9) |
		 (0 << 8) | (3 << 5) | (0 << 4) | (5 << 1) | (0 << 0),
	.inv_gain = 600,
	.time_stabiliz = 10,
	.alpha_level = 0,
	.thlock = 118,
	.wbd_inv = 0,
	.wbd_ref = 3530,
	.wbd_sel = 1,
	.wbd_alpha = 5,
	.agc1_max = 65535,
	.agc1_min = 0,
	.agc2_max = 65535,
	.agc2_min = 0,
	.agc1_pt1 = 0,
	.agc1_pt2 = 40,
	.agc1_pt3 = 183,
	.agc1_slope1 = 206,
	.agc1_slope2 = 255,
	.agc2_pt1 = 72,
	.agc2_pt2 = 152,
	.agc2_slope1 = 88,
	.agc2_slope2 = 90,
	.alpha_mant = 17,
	.alpha_exp = 27,
	.beta_mant = 23,
	.beta_exp = 51,
	.perform_agc_softsplit = 0,
};

static struct dibx000_bandwidth_config dib7070_bw_config_12_mhz = {
	.internal = 60000,
	.sampling = 15000,
	.pll_prediv = 1,
	.pll_ratio = 20,
	.pll_range = 3,
	.pll_reset = 1,
	.pll_bypass = 0,
	.enable_refdiv = 0,
	.bypclk_div = 0,
	.IO_CLK_en_core = 1,
	.ADClkSrc = 1,
	.modulo = 2,
	/* refsel, sel, freq_15k */
	.sad_cfg = (3 << 14) | (1 << 12) | (524 << 0),
	.ifreq = (0 << 25) | 0,
	.timf = 20452225,
	.xtal_hz = 12000000,
};

static struct dib7000p_config dib7070p_dib7000p_config = {
	/* .output_mode = OUTMODE_MPEG2_FIFO, */
	.output_mode = OUTMODE_MPEG2_SERIAL,
	/* .output_mode = OUTMODE_MPEG2_PAR_GATED_CLK, */
	.output_mpeg2_in_188_bytes = 1,

	.agc_config_count = 1,
	.agc = &dib7070_agc_config,
	.bw  = &dib7070_bw_config_12_mhz,
	.tuner_is_baseband = 1,
	.spur_protect = 1,

	.gpio_dir = 0xfcef, /* DIB7000P_GPIO_DEFAULT_DIRECTIONS, */
	.gpio_val = 0x0110, /* DIB7000P_GPIO_DEFAULT_VALUES, */
	.gpio_pwm_pos = DIB7000P_GPIO_DEFAULT_PWM_POS,

	.hostbus_diversity = 1,
};

static int dvb_register_ci_mac(struct cx23885_tsport *port)
{
	struct cx23885_dev *dev = port->dev;
	struct i2c_client *client_ci = NULL;
	struct vb2_dvb_frontend *fe0;

	fe0 = vb2_dvb_get_frontend(&port->frontends, 1);
	if (!fe0)
		return -EINVAL;

	switch (dev->board) {
	case CX23885_BOARD_NETUP_DUAL_DVBS2_CI: {
		static struct netup_card_info cinfo;

		netup_get_card_info(&dev->i2c_bus[0].i2c_adap, &cinfo);
		memcpy(port->frontends.adapter.proposed_mac,
				cinfo.port[port->nr - 1].mac, 6);
		pr_info("NetUP Dual DVB-S2 CI card port%d MAC=%pM\n",
			port->nr, port->frontends.adapter.proposed_mac);

		netup_ci_init(port);
		return 0;
		}
	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF: {
		struct altera_ci_config netup_ci_cfg = {
			.dev = dev,/* magic number to identify*/
			.adapter = &port->frontends.adapter,/* for CI */
			.demux = &fe0->dvb.demux,/* for hw pid filter */
			.fpga_rw = netup_altera_fpga_rw,
		};

		altera_ci_init(&netup_ci_cfg, port->nr);
		return 0;
		}
	case CX23885_BOARD_TEVII_S470: {
		u8 eeprom[256]; /* 24C02 i2c eeprom */

		if (port->nr != 1)
			return 0;

		/* Read entire EEPROM */
		dev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;
		tveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom, sizeof(eeprom));
		pr_info("TeVii S470 MAC= %pM\n", eeprom + 0xa0);
		memcpy(port->frontends.adapter.proposed_mac, eeprom + 0xa0, 6);
		return 0;
		}
	case CX23885_BOARD_DVBSKY_T9580:
	case CX23885_BOARD_DVBSKY_S950:
	case CX23885_BOARD_DVBSKY_S952:
	case CX23885_BOARD_DVBSKY_T982: {
		u8 eeprom[256]; /* 24C02 i2c eeprom */

		if (port->nr > 2)
			return 0;

		/* Read entire EEPROM */
		dev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;
		tveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom,
				sizeof(eeprom));
		pr_info("%s port %d MAC address: %pM\n",
			cx23885_boards[dev->board].name, port->nr,
			eeprom + 0xc0 + (port->nr-1) * 8);
		memcpy(port->frontends.adapter.proposed_mac, eeprom + 0xc0 +
			(port->nr-1) * 8, 6);
		return 0;
		}
	case CX23885_BOARD_DVBSKY_S950C:
	case CX23885_BOARD_DVBSKY_T980C:
	case CX23885_BOARD_TT_CT2_4500_CI: {
		u8 eeprom[256]; /* 24C02 i2c eeprom */
		struct sp2_config sp2_config;
		struct i2c_board_info info;
		struct cx23885_i2c *i2c_bus = &dev->i2c_bus[0];

		/* attach CI */
		memset(&sp2_config, 0, sizeof(sp2_config));
		sp2_config.dvb_adap = &port->frontends.adapter;
		sp2_config.priv = port;
		sp2_config.ci_control = cx23885_sp2_ci_ctrl;
		memset(&info, 0, sizeof(struct i2c_board_info));
		strscpy(info.type, "sp2", I2C_NAME_SIZE);
		info.addr = 0x40;
		info.platform_data = &sp2_config;
		request_module(info.type);
		client_ci = i2c_new_client_device(&i2c_bus->i2c_adap, &info);
		if (!i2c_client_has_driver(client_ci))
			return -ENODEV;
		if (!try_module_get(client_ci->dev.driver->owner)) {
			i2c_unregister_device(client_ci);
			return -ENODEV;
		}
		port->i2c_client_ci = client_ci;

		if (port->nr != 1)
			return 0;

		/* Read entire EEPROM */
		dev->i2c_bus[0].i2c_client.addr = 0xa0 >> 1;
		tveeprom_read(&dev->i2c_bus[0].i2c_client, eeprom,
				sizeof(eeprom));
		pr_info("%s MAC address: %pM\n",
			cx23885_boards[dev->board].name, eeprom + 0xc0);
		memcpy(port->frontends.adapter.proposed_mac, eeprom + 0xc0, 6);
		return 0;
		}
	}
	return 0;
}

static int dvb_register(struct cx23885_tsport *port)
{
	struct dib7000p_ops dib7000p_ops;
	struct cx23885_dev *dev = port->dev;
	struct cx23885_i2c *i2c_bus = NULL, *i2c_bus2 = NULL;
	struct vb2_dvb_frontend *fe0, *fe1 = NULL;
	struct si2168_config si2168_config;
	struct si2165_platform_data si2165_pdata;
	struct si2157_config si2157_config;
	struct ts2020_config ts2020_config;
	struct m88ds3103_platform_data m88ds3103_pdata;
	struct m88rs6000t_config m88rs6000t_config = {};
	struct a8293_platform_data a8293_pdata = {};
	struct i2c_board_info info;
	struct i2c_adapter *adapter;
	struct i2c_client *client_demod = NULL, *client_tuner = NULL;
	struct i2c_client *client_sec = NULL;
	int (*p_set_voltage)(struct dvb_frontend *fe,
			     enum fe_sec_voltage voltage) = NULL;
	int mfe_shared = 0; /* bus not shared by default */
	int ret;

	/* Get the first frontend */
	fe0 = vb2_dvb_get_frontend(&port->frontends, 1);
	if (!fe0)
		return -EINVAL;

	/* init struct vb2_dvb */
	fe0->dvb.name = dev->name;

	/* multi-frontend gate control is undefined or defaults to fe0 */
	port->frontends.gate = 0;

	/* Sets the gate control callback to be used by i2c command calls */
	port->gate_ctrl = cx23885_dvb_gate_ctrl;

	/* init frontend */
	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
		i2c_bus = &dev->i2c_bus[0];
		fe0->dvb.frontend = dvb_attach(s5h1409_attach,
						&hauppauge_generic_config,
						&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(mt2131_attach, fe0->dvb.frontend,
			   &i2c_bus->i2c_adap,
			   &hauppauge_generic_tunerconfig, 0);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
	case CX23885_BOARD_HAUPPAUGE_HVR1275:
		i2c_bus = &dev->i2c_bus[0];
		fe0->dvb.frontend = dvb_attach(lgdt3305_attach,
					       &hauppauge_lgdt3305_config,
					       &i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(tda18271_attach, fe0->dvb.frontend,
			   0x60, &dev->i2c_bus[1].i2c_adap,
			   &hauppauge_hvr127x_config);
		if (dev->board == CX23885_BOARD_HAUPPAUGE_HVR1275)
			cx23885_set_frontend_hook(port, fe0->dvb.frontend);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1255:
	case CX23885_BOARD_HAUPPAUGE_HVR1255_22111:
		i2c_bus = &dev->i2c_bus[0];
		fe0->dvb.frontend = dvb_attach(s5h1411_attach,
					       &hcw_s5h1411_config,
					       &i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;

		dvb_attach(tda18271_attach, fe0->dvb.frontend,
			   0x60, &dev->i2c_bus[1].i2c_adap,
			   &hauppauge_tda18271_config);

		tda18271_attach(&dev->ts1.analog_fe,
			0x60, &dev->i2c_bus[1].i2c_adap,
			&hauppauge_tda18271_config);

		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1800:
		i2c_bus = &dev->i2c_bus[0];
		switch (alt_tuner) {
		case 1:
			fe0->dvb.frontend =
				dvb_attach(s5h1409_attach,
					   &hauppauge_ezqam_config,
					   &i2c_bus->i2c_adap);
			if (fe0->dvb.frontend == NULL)
				break;

			dvb_attach(tda829x_attach, fe0->dvb.frontend,
				   &dev->i2c_bus[1].i2c_adap, 0x42,
				   &tda829x_no_probe);
			dvb_attach(tda18271_attach, fe0->dvb.frontend,
				   0x60, &dev->i2c_bus[1].i2c_adap,
				   &hauppauge_tda18271_config);
			break;
		case 0:
		default:
			fe0->dvb.frontend =
				dvb_attach(s5h1409_attach,
					   &hauppauge_generic_config,
					   &i2c_bus->i2c_adap);
			if (fe0->dvb.frontend == NULL)
				break;
			dvb_attach(mt2131_attach, fe0->dvb.frontend,
				   &i2c_bus->i2c_adap,
				   &hauppauge_generic_tunerconfig, 0);
		}
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1800lp:
		i2c_bus = &dev->i2c_bus[0];
		fe0->dvb.frontend = dvb_attach(s5h1409_attach,
						&hauppauge_hvr1800lp_config,
						&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(mt2131_attach, fe0->dvb.frontend,
			   &i2c_bus->i2c_adap,
			   &hauppauge_generic_tunerconfig, 0);
		break;
	case CX23885_BOARD_DVICO_FUSIONHDTV_5_EXP:
		i2c_bus = &dev->i2c_bus[0];
		fe0->dvb.frontend = dvb_attach(lgdt330x_attach,
					       &fusionhdtv_5_express,
					       0x0e,
					       &i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(simple_tuner_attach, fe0->dvb.frontend,
			   &i2c_bus->i2c_adap, 0x61,
			   TUNER_LG_TDVS_H06XF);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1500Q:
		i2c_bus = &dev->i2c_bus[1];
		fe0->dvb.frontend = dvb_attach(s5h1409_attach,
						&hauppauge_hvr1500q_config,
						&dev->i2c_bus[0].i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(xc5000_attach, fe0->dvb.frontend,
			   &i2c_bus->i2c_adap,
			   &hauppauge_hvr1500q_tunerconfig);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1500:
		i2c_bus = &dev->i2c_bus[1];
		fe0->dvb.frontend = dvb_attach(s5h1409_attach,
						&hauppauge_hvr1500_config,
						&dev->i2c_bus[0].i2c_adap);
		if (fe0->dvb.frontend != NULL) {
			struct dvb_frontend *fe;
			struct xc2028_config cfg = {
				.i2c_adap  = &i2c_bus->i2c_adap,
				.i2c_addr  = 0x61,
			};
			static struct xc2028_ctrl ctl = {
				.fname       = XC2028_DEFAULT_FIRMWARE,
				.max_len     = 64,
				.demod       = XC3028_FE_OREN538,
			};

			fe = dvb_attach(xc2028_attach,
					fe0->dvb.frontend, &cfg);
			if (fe != NULL && fe->ops.tuner_ops.set_config != NULL)
				fe->ops.tuner_ops.set_config(fe, &ctl);
		}
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1200:
	case CX23885_BOARD_HAUPPAUGE_HVR1700:
		i2c_bus = &dev->i2c_bus[0];
		fe0->dvb.frontend = dvb_attach(tda10048_attach,
			&hauppauge_hvr1200_config,
			&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(tda829x_attach, fe0->dvb.frontend,
			   &dev->i2c_bus[1].i2c_adap, 0x42,
			   &tda829x_no_probe);
		dvb_attach(tda18271_attach, fe0->dvb.frontend,
			   0x60, &dev->i2c_bus[1].i2c_adap,
			   &hauppauge_hvr1200_tuner_config);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1210:
		i2c_bus = &dev->i2c_bus[0];
		fe0->dvb.frontend = dvb_attach(tda10048_attach,
			&hauppauge_hvr1210_config,
			&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend != NULL) {
			dvb_attach(tda18271_attach, fe0->dvb.frontend,
				0x60, &dev->i2c_bus[1].i2c_adap,
				&hauppauge_hvr1210_tuner_config);
		}
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1400:
		i2c_bus = &dev->i2c_bus[0];

		if (!dvb_attach(dib7000p_attach, &dib7000p_ops))
			return -ENODEV;

		fe0->dvb.frontend = dib7000p_ops.init(&i2c_bus->i2c_adap,
			0x12, &hauppauge_hvr1400_dib7000_config);
		if (fe0->dvb.frontend != NULL) {
			struct dvb_frontend *fe;
			struct xc2028_config cfg = {
				.i2c_adap  = &dev->i2c_bus[1].i2c_adap,
				.i2c_addr  = 0x64,
			};
			static struct xc2028_ctrl ctl = {
				.fname   = XC3028L_DEFAULT_FIRMWARE,
				.max_len = 64,
				.demod   = XC3028_FE_DIBCOM52,
				/* This is true for all demods with
					v36 firmware? */
				.type    = XC2028_D2633,
			};

			fe = dvb_attach(xc2028_attach,
					fe0->dvb.frontend, &cfg);
			if (fe != NULL && fe->ops.tuner_ops.set_config != NULL)
				fe->ops.tuner_ops.set_config(fe, &ctl);
		}
		break;
	case CX23885_BOARD_DVICO_FUSIONHDTV_7_DUAL_EXP:
		i2c_bus = &dev->i2c_bus[port->nr - 1];

		fe0->dvb.frontend = dvb_attach(s5h1409_attach,
						&dvico_s5h1409_config,
						&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			fe0->dvb.frontend = dvb_attach(s5h1411_attach,
							&dvico_s5h1411_config,
							&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend != NULL)
			dvb_attach(xc5000_attach, fe0->dvb.frontend,
				   &i2c_bus->i2c_adap,
				   &dvico_xc5000_tunerconfig);
		break;
	case CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP: {
		i2c_bus = &dev->i2c_bus[port->nr - 1];

		fe0->dvb.frontend = dvb_attach(zl10353_attach,
					       &dvico_fusionhdtv_xc3028,
					       &i2c_bus->i2c_adap);
		if (fe0->dvb.frontend != NULL) {
			struct dvb_frontend      *fe;
			struct xc2028_config	  cfg = {
				.i2c_adap  = &i2c_bus->i2c_adap,
				.i2c_addr  = 0x61,
			};
			static struct xc2028_ctrl ctl = {
				.fname       = XC2028_DEFAULT_FIRMWARE,
				.max_len     = 64,
				.demod       = XC3028_FE_ZARLINK456,
			};

			fe = dvb_attach(xc2028_attach, fe0->dvb.frontend,
					&cfg);
			if (fe != NULL && fe->ops.tuner_ops.set_config != NULL)
				fe->ops.tuner_ops.set_config(fe, &ctl);
		}
		break;
	}
	case CX23885_BOARD_DVICO_FUSIONHDTV_DVB_T_DUAL_EXP2: {
		i2c_bus = &dev->i2c_bus[port->nr - 1];
		/* cxusb_ctrl_msg(adap->dev, CMD_DIGITAL, NULL, 0, NULL, 0); */
		/* cxusb_bluebird_gpio_pulse(adap->dev, 0x02, 1); */

		if (!dvb_attach(dib7000p_attach, &dib7000p_ops))
			return -ENODEV;

		if (dib7000p_ops.i2c_enumeration(&i2c_bus->i2c_adap, 1, 0x12, &dib7070p_dib7000p_config) < 0) {
			pr_warn("Unable to enumerate dib7000p\n");
			return -ENODEV;
		}
		fe0->dvb.frontend = dib7000p_ops.init(&i2c_bus->i2c_adap, 0x80, &dib7070p_dib7000p_config);
		if (fe0->dvb.frontend != NULL) {
			struct i2c_adapter *tun_i2c;

			fe0->dvb.frontend->sec_priv = kmemdup(&dib7000p_ops, sizeof(dib7000p_ops), GFP_KERNEL);
			if (!fe0->dvb.frontend->sec_priv)
				return -ENOMEM;
			tun_i2c = dib7000p_ops.get_i2c_master(fe0->dvb.frontend, DIBX000_I2C_INTERFACE_TUNER, 1);
			if (!dvb_attach(dib0070_attach, fe0->dvb.frontend, tun_i2c, &dib7070p_dib0070_config))
				return -ENODEV;
		}
		break;
	}
	case CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H:
	case CX23885_BOARD_COMPRO_VIDEOMATE_E650F:
	case CX23885_BOARD_COMPRO_VIDEOMATE_E800:
		i2c_bus = &dev->i2c_bus[0];

		fe0->dvb.frontend = dvb_attach(zl10353_attach,
			&dvico_fusionhdtv_xc3028,
			&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend != NULL) {
			struct dvb_frontend      *fe;
			struct xc2028_config	  cfg = {
				.i2c_adap  = &dev->i2c_bus[1].i2c_adap,
				.i2c_addr  = 0x61,
			};
			static struct xc2028_ctrl ctl = {
				.fname       = XC2028_DEFAULT_FIRMWARE,
				.max_len     = 64,
				.demod       = XC3028_FE_ZARLINK456,
			};

			fe = dvb_attach(xc2028_attach, fe0->dvb.frontend,
				&cfg);
			if (fe != NULL && fe->ops.tuner_ops.set_config != NULL)
				fe->ops.tuner_ops.set_config(fe, &ctl);
		}
		break;
	case CX23885_BOARD_LEADTEK_WINFAST_PXDVR3200_H_XC4000:
		i2c_bus = &dev->i2c_bus[0];

		fe0->dvb.frontend = dvb_attach(zl10353_attach,
					       &dvico_fusionhdtv_xc3028,
					       &i2c_bus->i2c_adap);
		if (fe0->dvb.frontend != NULL) {
			struct dvb_frontend	*fe;
			struct xc4000_config	cfg = {
				.i2c_address	  = 0x61,
				.default_pm	  = 0,
				.dvb_amplitude	  = 134,
				.set_smoothedcvbs = 1,
				.if_khz		  = 4560
			};

			fe = dvb_attach(xc4000_attach, fe0->dvb.frontend,
					&dev->i2c_bus[1].i2c_adap, &cfg);
			if (!fe) {
				pr_err("%s/2: xc4000 attach failed\n",
				       dev->name);
				goto frontend_detach;
			}
		}
		break;
	case CX23885_BOARD_TBS_6920:
		i2c_bus = &dev->i2c_bus[1];

		fe0->dvb.frontend = dvb_attach(cx24116_attach,
					&tbs_cx24116_config,
					&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend != NULL)
			fe0->dvb.frontend->ops.set_voltage = f300_set_voltage;

		break;
	case CX23885_BOARD_TBS_6980:
	case CX23885_BOARD_TBS_6981:
		i2c_bus = &dev->i2c_bus[1];

		switch (port->nr) {
		/* PORT B */
		case 1:
			fe0->dvb.frontend = dvb_attach(cx24117_attach,
					&tbs_cx24117_config,
					&i2c_bus->i2c_adap);
			break;
		/* PORT C */
		case 2:
			fe0->dvb.frontend = dvb_attach(cx24117_attach,
					&tbs_cx24117_config,
					&i2c_bus->i2c_adap);
			break;
		}
		break;
	case CX23885_BOARD_TEVII_S470:
		i2c_bus = &dev->i2c_bus[1];

		fe0->dvb.frontend = dvb_attach(ds3000_attach,
					&tevii_ds3000_config,
					&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend != NULL) {
			dvb_attach(ts2020_attach, fe0->dvb.frontend,
				&tevii_ts2020_config, &i2c_bus->i2c_adap);
			fe0->dvb.frontend->ops.set_voltage = f300_set_voltage;
		}

		break;
	case CX23885_BOARD_DVBWORLD_2005:
		i2c_bus = &dev->i2c_bus[1];

		fe0->dvb.frontend = dvb_attach(cx24116_attach,
			&dvbworld_cx24116_config,
			&i2c_bus->i2c_adap);
		break;
	case CX23885_BOARD_NETUP_DUAL_DVBS2_CI:
		i2c_bus = &dev->i2c_bus[0];
		switch (port->nr) {
		/* port B */
		case 1:
			fe0->dvb.frontend = dvb_attach(stv0900_attach,
							&netup_stv0900_config,
							&i2c_bus->i2c_adap, 0);
			if (fe0->dvb.frontend != NULL) {
				if (dvb_attach(stv6110_attach,
						fe0->dvb.frontend,
						&netup_stv6110_tunerconfig_a,
						&i2c_bus->i2c_adap)) {
					if (!dvb_attach(lnbh24_attach,
							fe0->dvb.frontend,
							&i2c_bus->i2c_adap,
							LNBH24_PCL | LNBH24_TTX,
							LNBH24_TEN, 0x09))
						pr_err("No LNBH24 found!\n");

				}
			}
			break;
		/* port C */
		case 2:
			fe0->dvb.frontend = dvb_attach(stv0900_attach,
							&netup_stv0900_config,
							&i2c_bus->i2c_adap, 1);
			if (fe0->dvb.frontend != NULL) {
				if (dvb_attach(stv6110_attach,
						fe0->dvb.frontend,
						&netup_stv6110_tunerconfig_b,
						&i2c_bus->i2c_adap)) {
					if (!dvb_attach(lnbh24_attach,
							fe0->dvb.frontend,
							&i2c_bus->i2c_adap,
							LNBH24_PCL | LNBH24_TTX,
							LNBH24_TEN, 0x0a))
						pr_err("No LNBH24 found!\n");

				}
			}
			break;
		}
		break;
	case CX23885_BOARD_MYGICA_X8506:
		i2c_bus = &dev->i2c_bus[0];
		i2c_bus2 = &dev->i2c_bus[1];
		fe0->dvb.frontend = dvb_attach(lgs8gxx_attach,
			&mygica_x8506_lgs8gl5_config,
			&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(xc5000_attach, fe0->dvb.frontend,
			   &i2c_bus2->i2c_adap, &mygica_x8506_xc5000_config);
		cx23885_set_frontend_hook(port, fe0->dvb.frontend);
		break;
	case CX23885_BOARD_MYGICA_X8507:
		i2c_bus = &dev->i2c_bus[0];
		i2c_bus2 = &dev->i2c_bus[1];
		fe0->dvb.frontend = dvb_attach(mb86a20s_attach,
			&mygica_x8507_mb86a20s_config,
			&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;

		dvb_attach(xc5000_attach, fe0->dvb.frontend,
			   &i2c_bus2->i2c_adap,
			   &mygica_x8507_xc5000_config);
		cx23885_set_frontend_hook(port, fe0->dvb.frontend);
		break;
	case CX23885_BOARD_MAGICPRO_PROHDTVE2:
		i2c_bus = &dev->i2c_bus[0];
		i2c_bus2 = &dev->i2c_bus[1];
		fe0->dvb.frontend = dvb_attach(lgs8gxx_attach,
			&magicpro_prohdtve2_lgs8g75_config,
			&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(xc5000_attach, fe0->dvb.frontend,
			   &i2c_bus2->i2c_adap,
			   &magicpro_prohdtve2_xc5000_config);
		cx23885_set_frontend_hook(port, fe0->dvb.frontend);
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1850:
		i2c_bus = &dev->i2c_bus[0];
		fe0->dvb.frontend = dvb_attach(s5h1411_attach,
			&hcw_s5h1411_config,
			&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(tda18271_attach, fe0->dvb.frontend,
			   0x60, &dev->i2c_bus[0].i2c_adap,
			   &hauppauge_tda18271_config);

		tda18271_attach(&dev->ts1.analog_fe,
			0x60, &dev->i2c_bus[1].i2c_adap,
			&hauppauge_tda18271_config);

		break;
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
		i2c_bus = &dev->i2c_bus[0];
		fe0->dvb.frontend = dvb_attach(s5h1411_attach,
			&hcw_s5h1411_config,
			&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(tda18271_attach, fe0->dvb.frontend,
			   0x60, &dev->i2c_bus[0].i2c_adap,
			   &hauppauge_tda18271_config);
		break;
	case CX23885_BOARD_MYGICA_X8558PRO:
		switch (port->nr) {
		/* port B */
		case 1:
			i2c_bus = &dev->i2c_bus[0];
			fe0->dvb.frontend = dvb_attach(atbm8830_attach,
				&mygica_x8558pro_atbm8830_cfg1,
				&i2c_bus->i2c_adap);
			if (fe0->dvb.frontend == NULL)
				break;
			dvb_attach(max2165_attach, fe0->dvb.frontend,
				   &i2c_bus->i2c_adap,
				   &mygic_x8558pro_max2165_cfg1);
			break;
		/* port C */
		case 2:
			i2c_bus = &dev->i2c_bus[1];
			fe0->dvb.frontend = dvb_attach(atbm8830_attach,
				&mygica_x8558pro_atbm8830_cfg2,
				&i2c_bus->i2c_adap);
			if (fe0->dvb.frontend == NULL)
				break;
			dvb_attach(max2165_attach, fe0->dvb.frontend,
				   &i2c_bus->i2c_adap,
				   &mygic_x8558pro_max2165_cfg2);
		}
		break;
	case CX23885_BOARD_NETUP_DUAL_DVB_T_C_CI_RF:
		if (port->nr > 2)
			return 0;

		i2c_bus = &dev->i2c_bus[0];
		mfe_shared = 1;/* MFE */
		port->frontends.gate = 0;/* not clear for me yet */
		/* ports B, C */
		/* MFE frontend 1 DVB-T */
		fe0->dvb.frontend = dvb_attach(stv0367ter_attach,
					&netup_stv0367_config[port->nr - 1],
					&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		if (NULL == dvb_attach(xc5000_attach, fe0->dvb.frontend,
					&i2c_bus->i2c_adap,
					&netup_xc5000_config[port->nr - 1]))
			goto frontend_detach;
		/* load xc5000 firmware */
		fe0->dvb.frontend->ops.tuner_ops.init(fe0->dvb.frontend);

		/* MFE frontend 2 */
		fe1 = vb2_dvb_get_frontend(&port->frontends, 2);
		if (fe1 == NULL)
			goto frontend_detach;
		/* DVB-C init */
		fe1->dvb.frontend = dvb_attach(stv0367cab_attach,
					&netup_stv0367_config[port->nr - 1],
					&i2c_bus->i2c_adap);
		if (fe1->dvb.frontend == NULL)
			break;

		fe1->dvb.frontend->id = 1;
		if (NULL == dvb_attach(xc5000_attach,
				       fe1->dvb.frontend,
				       &i2c_bus->i2c_adap,
				       &netup_xc5000_config[port->nr - 1]))
			goto frontend_detach;
		break;
	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
		i2c_bus = &dev->i2c_bus[0];
		i2c_bus2 = &dev->i2c_bus[1];

		switch (port->nr) {
		/* port b */
		case 1:
			fe0->dvb.frontend = dvb_attach(drxk_attach,
					&terratec_drxk_config[0],
					&i2c_bus->i2c_adap);
			if (fe0->dvb.frontend == NULL)
				break;
			if (!dvb_attach(mt2063_attach,
					fe0->dvb.frontend,
					&terratec_mt2063_config[0],
					&i2c_bus2->i2c_adap))
				goto frontend_detach;
			break;
		/* port c */
		case 2:
			fe0->dvb.frontend = dvb_attach(drxk_attach,
					&terratec_drxk_config[1],
					&i2c_bus->i2c_adap);
			if (fe0->dvb.frontend == NULL)
				break;
			if (!dvb_attach(mt2063_attach,
					fe0->dvb.frontend,
					&terratec_mt2063_config[1],
					&i2c_bus2->i2c_adap))
				goto frontend_detach;
			break;
		}
		break;
	case CX23885_BOARD_TEVII_S471:
		i2c_bus = &dev->i2c_bus[1];

		fe0->dvb.frontend = dvb_attach(ds3000_attach,
					&tevii_ds3000_config,
					&i2c_bus->i2c_adap);
		if (fe0->dvb.frontend == NULL)
			break;
		dvb_attach(ts2020_attach, fe0->dvb.frontend,
			   &tevii_ts2020_config, &i2c_bus->i2c_adap);
		break;
	case CX23885_BOARD_PROF_8000:
		i2c_bus = &dev->i2c_bus[0];

		fe0->dvb.frontend = dvb_attach(stv090x_attach,
						&prof_8000_stv090x_config,
						&i2c_bus->i2c_adap,
						STV090x_DEMODULATOR_0);
		if (fe0->dvb.frontend == NULL)
			break;
		if (!dvb_attach(stb6100_attach,
				fe0->dvb.frontend,
				&prof_8000_stb6100_config,
				&i2c_bus->i2c_adap))
			goto frontend_detach;

		fe0->dvb.frontend->ops.set_voltage = p8000_set_voltage;
		break;
	case CX23885_BOARD_HAUPPAUGE_HVR4400: {
		struct tda10071_platform_data tda10071_pdata = hauppauge_tda10071_pdata;
		struct a8293_platform_data a8293_pdata = {};

		i2c_bus = &dev->i2c_bus[0];
		i2c_bus2 = &dev->i2c_bus[1];
		switch (port->nr) {
		/* port b */
		case 1:
			/* attach demod + tuner combo */
			memset(&info, 0, sizeof(info));
			strscpy(info.type, "tda10071_cx24118", I2C_NAME_SIZE);
			info.addr = 0x05;
			info.platform_data = &tda10071_pdata;
			request_module("tda10071");
			client_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);
			if (!i2c_client_has_driver(client_demod))
				goto frontend_detach;
			if (!try_module_get(client_demod->dev.driver->owner)) {
				i2c_unregister_device(client_demod);
				goto frontend_detach;
			}
			fe0->dvb.frontend = tda10071_pdata.get_dvb_frontend(client_demod);
			port->i2c_client_demod = client_demod;

			/* attach SEC */
			a8293_pdata.dvb_frontend = fe0->dvb.frontend;
			memset(&info, 0, sizeof(info));
			strscpy(info.type, "a8293", I2C_NAME_SIZE);
			info.addr = 0x0b;
			info.platform_data = &a8293_pdata;
			request_module("a8293");
			client_sec = i2c_new_client_device(&i2c_bus->i2c_adap, &info);
			if (!i2c_client_has_driver(client_sec))
				goto frontend_detach;
			if (!try_module_get(client_sec->dev.driver->owner)) {
				i2c_unregister_device(client_sec);
				goto frontend_detach;
			}
			port->i2c_client_sec = client_sec;
			break;
		/* port c */
		case 2:
			/* attach frontend */
			memset(&si2165_pdata, 0, sizeof(si2165_pdata));
			si2165_pdata.fe = &fe0->dvb.frontend;
			si2165_pdata.chip_mode = SI2165_MODE_PLL_XTAL;
			si2165_pdata.ref_freq_hz = 16000000;
			memset(&info, 0, sizeof(struct i2c_board_info));
			strscpy(info.type, "si2165", I2C_NAME_SIZE);
			info.addr = 0x64;
			info.platform_data = &si2165_pdata;
			request_module(info.type);
			client_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);
			if (!i2c_client_has_driver(client_demod))
				goto frontend_detach;
			if (!try_module_get(client_demod->dev.driver->owner)) {
				i2c_unregister_device(client_demod);
				goto frontend_detach;
			}
			port->i2c_client_demod = client_demod;

			if (fe0->dvb.frontend == NULL)
				break;
			fe0->dvb.frontend->ops.i2c_gate_ctrl = NULL;
			if (!dvb_attach(tda18271_attach,
					fe0->dvb.frontend,
					0x60, &i2c_bus2->i2c_adap,
				  &hauppauge_hvr4400_tuner_config))
				goto frontend_detach;
			break;
		}
		break;
	}
	case CX23885_BOARD_HAUPPAUGE_STARBURST: {
		struct tda10071_platform_data tda10071_pdata = hauppauge_tda10071_pdata;
		struct a8293_platform_data a8293_pdata = {};

		i2c_bus = &dev->i2c_bus[0];

		/* attach demod + tuner combo */
		memset(&info, 0, sizeof(info));
		strscpy(info.type, "tda10071_cx24118", I2C_NAME_SIZE);
		info.addr = 0x05;
		info.platform_data = &tda10071_pdata;
		request_module("tda10071");
		client_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);
		if (!i2c_client_has_driver(client_demod))
			goto frontend_detach;
		if (!try_module_get(client_demod->dev.driver->owner)) {
			i2c_unregister_device(client_demod);
			goto frontend_detach;
		}
		fe0->dvb.frontend = tda10071_pdata.get_dvb_frontend(client_demod);
		port->i2c_client_demod = client_demod;

		/* attach SEC */
		a8293_pdata.dvb_frontend = fe0->dvb.frontend;
		memset(&info, 0, sizeof(info));
		strscpy(info.type, "a8293", I2C_NAME_SIZE);
		info.addr = 0x0b;
		info.platform_data = &a8293_pdata;
		request_module("a8293");
		client_sec = i2c_new_client_device(&i2c_bus->i2c_adap, &info);
		if (!i2c_client_has_driver(client_sec))
			goto frontend_detach;
		if (!try_module_get(client_sec->dev.driver->owner)) {
			i2c_unregister_device(client_sec);
			goto frontend_detach;
		}
		port->i2c_client_sec = client_sec;
		break;
	}
	case CX23885_BOARD_DVBSKY_T9580:
	case CX23885_BOARD_DVBSKY_S950:
		i2c_bus = &dev->i2c_bus[0];
		i2c_bus2 = &dev->i2c_bus[1];
		switch (port->nr) {
		/* port b - satellite */
		case 1:
			/* attach frontend */
			fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
					&dvbsky_t9580_m88ds3103_config,
					&i2c_bus2->i2c_adap, &adapter);
			if (fe0->dvb.frontend == NULL)
				break;

			/* attach tuner */
			memset(&ts2020_config, 0, sizeof(ts2020_config));
			ts2020_config.fe = fe0->dvb.frontend;
			ts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;
			memset(&info, 0, sizeof(struct i2c_board_info));
			strscpy(info.type, "ts2020", I2C_NAME_SIZE);
			info.addr = 0x60;
			info.platform_data = &ts2020_config;
			request_module(info.type);
			client_tuner = i2c_new_client_device(adapter, &info);
			if (!i2c_client_has_driver(client_tuner))
				goto frontend_detach;
			if (!try_module_get(client_tuner->dev.driver->owner)) {
				i2c_unregister_device(client_tuner);
				goto frontend_detach;
			}

			/* delegate signal strength measurement to tuner */
			fe0->dvb.frontend->ops.read_signal_strength =
				fe0->dvb.frontend->ops.tuner_ops.get_rf_strength;

			/*
			 * for setting the voltage we need to set GPIOs on
			 * the card.
			 */
			port->fe_set_voltage =
				fe0->dvb.frontend->ops.set_voltage;
			fe0->dvb.frontend->ops.set_voltage =
				dvbsky_t9580_set_voltage;

			port->i2c_client_tuner = client_tuner;

			break;
		/* port c - terrestrial/cable */
		case 2:
			/* attach frontend */
			memset(&si2168_config, 0, sizeof(si2168_config));
			si2168_config.i2c_adapter = &adapter;
			si2168_config.fe = &fe0->dvb.frontend;
			si2168_config.ts_mode = SI2168_TS_SERIAL;
			memset(&info, 0, sizeof(struct i2c_board_info));
			strscpy(info.type, "si2168", I2C_NAME_SIZE);
			info.addr = 0x64;
			info.platform_data = &si2168_config;
			request_module(info.type);
			client_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);
			if (!i2c_client_has_driver(client_demod))
				goto frontend_detach;
			if (!try_module_get(client_demod->dev.driver->owner)) {
				i2c_unregister_device(client_demod);
				goto frontend_detach;
			}
			port->i2c_client_demod = client_demod;

			/* attach tuner */
			memset(&si2157_config, 0, sizeof(si2157_config));
			si2157_config.fe = fe0->dvb.frontend;
			si2157_config.if_port = 1;
			memset(&info, 0, sizeof(struct i2c_board_info));
			strscpy(info.type, "si2157", I2C_NAME_SIZE);
			info.addr = 0x60;
			info.platform_data = &si2157_config;
			request_module(info.type);
			client_tuner = i2c_new_client_device(adapter, &info);
			if (!i2c_client_has_driver(client_tuner))
				goto frontend_detach;

			if (!try_module_get(client_tuner->dev.driver->owner)) {
				i2c_unregister_device(client_tuner);
				goto frontend_detach;
			}
			port->i2c_client_tuner = client_tuner;
			break;
		}
		break;
	case CX23885_BOARD_DVBSKY_T980C:
	case CX23885_BOARD_TT_CT2_4500_CI:
		i2c_bus = &dev->i2c_bus[0];
		i2c_bus2 = &dev->i2c_bus[1];

		/* attach frontend */
		memset(&si2168_config, 0, sizeof(si2168_config));
		si2168_config.i2c_adapter = &adapter;
		si2168_config.fe = &fe0->dvb.frontend;
		si2168_config.ts_mode = SI2168_TS_PARALLEL;
		memset(&info, 0, sizeof(struct i2c_board_info));
		strscpy(info.type, "si2168", I2C_NAME_SIZE);
		info.addr = 0x64;
		info.platform_data = &si2168_config;
		request_module(info.type);
		client_demod = i2c_new_client_device(&i2c_bus2->i2c_adap, &info);
		if (!i2c_client_has_driver(client_demod))
			goto frontend_detach;
		if (!try_module_get(client_demod->dev.driver->owner)) {
			i2c_unregister_device(client_demod);
			goto frontend_detach;
		}
		port->i2c_client_demod = client_demod;

		/* attach tuner */
		memset(&si2157_config, 0, sizeof(si2157_config));
		si2157_config.fe = fe0->dvb.frontend;
		si2157_config.if_port = 1;
		memset(&info, 0, sizeof(struct i2c_board_info));
		strscpy(info.type, "si2157", I2C_NAME_SIZE);
		info.addr = 0x60;
		info.platform_data = &si2157_config;
		request_module(info.type);
		client_tuner = i2c_new_client_device(adapter, &info);
		if (!i2c_client_has_driver(client_tuner))
			goto frontend_detach;
		if (!try_module_get(client_tuner->dev.driver->owner)) {
			i2c_unregister_device(client_tuner);
			goto frontend_detach;
		}
		port->i2c_client_tuner = client_tuner;
		break;
	case CX23885_BOARD_DVBSKY_S950C:
		i2c_bus = &dev->i2c_bus[0];
		i2c_bus2 = &dev->i2c_bus[1];

		/* attach frontend */
		fe0->dvb.frontend = dvb_attach(m88ds3103_attach,
				&dvbsky_s950c_m88ds3103_config,
				&i2c_bus2->i2c_adap, &adapter);
		if (fe0->dvb.frontend == NULL)
			break;

		/* attach tuner */
		memset(&ts2020_config, 0, sizeof(ts2020_config));
		ts2020_config.fe = fe0->dvb.frontend;
		ts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;
		memset(&info, 0, sizeof(struct i2c_board_info));
		strscpy(info.type, "ts2020", I2C_NAME_SIZE);
		info.addr = 0x60;
		info.platform_data = &ts2020_config;
		request_module(info.type);
		client_tuner = i2c_new_client_device(adapter, &info);
		if (!i2c_client_has_driver(client_tuner))
			goto frontend_detach;
		if (!try_module_get(client_tuner->dev.driver->owner)) {
			i2c_unregister_device(client_tuner);
			goto frontend_detach;
		}

		/* delegate signal strength measurement to tuner */
		fe0->dvb.frontend->ops.read_signal_strength =
			fe0->dvb.frontend->ops.tuner_ops.get_rf_strength;

		port->i2c_client_tuner = client_tuner;
		break;
	case CX23885_BOARD_DVBSKY_S952:
		/* attach frontend */
		memset(&m88ds3103_pdata, 0, sizeof(m88ds3103_pdata));
		m88ds3103_pdata.clk = 27000000;
		m88ds3103_pdata.i2c_wr_max = 33;
		m88ds3103_pdata.agc = 0x99;
		m88ds3103_pdata.clk_out = M88DS3103_CLOCK_OUT_DISABLED;
		m88ds3103_pdata.lnb_en_pol = 1;

		switch (port->nr) {
		/* port b */
		case 1:
			i2c_bus = &dev->i2c_bus[1];
			m88ds3103_pdata.ts_mode = M88DS3103_TS_PARALLEL;
			m88ds3103_pdata.ts_clk = 16000;
			m88ds3103_pdata.ts_clk_pol = 1;
			p_set_voltage = dvbsky_t9580_set_voltage;
			break;
		/* port c */
		case 2:
			i2c_bus = &dev->i2c_bus[0];
			m88ds3103_pdata.ts_mode = M88DS3103_TS_SERIAL;
			m88ds3103_pdata.ts_clk = 96000;
			m88ds3103_pdata.ts_clk_pol = 0;
			p_set_voltage = dvbsky_s952_portc_set_voltage;
			break;
		default:
			return 0;
		}

		memset(&info, 0, sizeof(info));
		strscpy(info.type, "m88ds3103", I2C_NAME_SIZE);
		info.addr = 0x68;
		info.platform_data = &m88ds3103_pdata;
		request_module(info.type);
		client_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);
		if (!i2c_client_has_driver(client_demod))
			goto frontend_detach;
		if (!try_module_get(client_demod->dev.driver->owner)) {
			i2c_unregister_device(client_demod);
			goto frontend_detach;
		}
		port->i2c_client_demod = client_demod;
		adapter = m88ds3103_pdata.get_i2c_adapter(client_demod);
		fe0->dvb.frontend = m88ds3103_pdata.get_dvb_frontend(client_demod);

		/* attach tuner */
		memset(&ts2020_config, 0, sizeof(ts2020_config));
		ts2020_config.fe = fe0->dvb.frontend;
		ts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;
		memset(&info, 0, sizeof(struct i2c_board_info));
		strscpy(info.type, "ts2020", I2C_NAME_SIZE);
		info.addr = 0x60;
		info.platform_data = &ts2020_config;
		request_module(info.type);
		client_tuner = i2c_new_client_device(adapter, &info);
		if (!i2c_client_has_driver(client_tuner))
			goto frontend_detach;
		if (!try_module_get(client_tuner->dev.driver->owner)) {
			i2c_unregister_device(client_tuner);
			goto frontend_detach;
		}

		/* delegate signal strength measurement to tuner */
		fe0->dvb.frontend->ops.read_signal_strength =
			fe0->dvb.frontend->ops.tuner_ops.get_rf_strength;

		/*
		 * for setting the voltage we need to set GPIOs on
		 * the card.
		 */
		port->fe_set_voltage =
			fe0->dvb.frontend->ops.set_voltage;
		fe0->dvb.frontend->ops.set_voltage = p_set_voltage;

		port->i2c_client_tuner = client_tuner;
		break;
	case CX23885_BOARD_DVBSKY_T982:
		memset(&si2168_config, 0, sizeof(si2168_config));
		switch (port->nr) {
		/* port b */
		case 1:
			i2c_bus = &dev->i2c_bus[1];
			si2168_config.ts_mode = SI2168_TS_PARALLEL;
			break;
		/* port c */
		case 2:
			i2c_bus = &dev->i2c_bus[0];
			si2168_config.ts_mode = SI2168_TS_SERIAL;
			break;
		}

		/* attach frontend */
		si2168_config.i2c_adapter = &adapter;
		si2168_config.fe = &fe0->dvb.frontend;
		memset(&info, 0, sizeof(struct i2c_board_info));
		strscpy(info.type, "si2168", I2C_NAME_SIZE);
		info.addr = 0x64;
		info.platform_data = &si2168_config;
		request_module(info.type);
		client_demod = i2c_new_client_device(&i2c_bus->i2c_adap, &info);
		if (!i2c_client_has_driver(cla@<nooZ?jB
}3aaNS5@e0N*/"vQ>)*=x}Ʀ*#zyҎu\t]/eBʇPJ^I>\]E敯_9zTEzs7-&$͘z9Űع(a{de0q|Щ#Z{$`v[o<xf> ۏRmF	t()Y6FXaXD^lmp$y׈~%f,B&2hp],MjVjE])$*4l2Z5qbG\71DO#M6<ܷmBoac("-fBoe|Z'-"$7?ART;=F8NvrPHMAdҫ|+pͯz$#az~/}m,+Y^]s3$B
E&
](ɬYoeB9wA)z!pK;o(ǀY}{8%zyw&HpAGyOMeGXੀ+LNRx)},)f
1ѧtr\rA)CGxκvĿ_|h*`,to4Ęs9o>5ѕ`+	SGs.ab"hg`҉Jd;
^A]S)I-_1/@/V@(᠟niLR+ڂh\"2X{d+C#T#@3џ,oCg_K	`?|kަvJvZ0:DH(m8kd28짱LdL2#Emys4UA<Az[Gxve19@՚ !բ[$\wfPpza4.cJ {IyĲ:SCcpر)d~/Y(A GwޞKe0 ߊ=zzB\nvju{\sŉ )n&\p5)ɜrRgZeId|mB?haX=._aUq[/D)VLgcL};R+z#LXEƈmf(dG篂"	%9Sf"s̈́kdR?vk[酡^=
簗'Z͒;)<$'ԁ@&èYM쩋1xg)NLM^KZ6>K!$[L9#mp٢N
l ky
7EqHS	YdtSOA$k%dQH"jo2'NOm"A9|AAhpAT9ٹOuR+u>JYOCFhizy1k@]LufZp7zlEq7x=%TRqDK2ڵN>{	ڀ"|`/,e}./r+\2/zfj+<ߛsÞ'R:|Ȝ,th^#	;ƪaq51;_9?N諾tWQ.<zw#]
51Ԓ)y1Iè:*o@V@آUJI/cɽ.?ŭie(@Ydh=O6_Rc6᧾ ,UGL@@ûd>ќղMFţnN?ۿ%#MѭV݌N-GC@3vR@"}U6',nfP@w0n8ac;X皟uY,2Դ^ul"[xB)%נდ?TyYܱCp"rAJ`9<Y1tj;^]ܜHUDy9I6U(štl}B$s|bݴJ<f{ʶ](weȰG Wbs(!%#i&8_}T]AG,ZFm_,*<7K,X+s8q5?Z.TUk6E?z=p<)ų2%E甭4CϠ헆TdCWDVc2LX+3TMlY]Od&mC6􌝩jA3+>;
ϓPJRϾqmSM~΢Ec&dGz"[Q45ܢ*\#1tު,O&2^yuFT)p0Eu	Ge^HWץ kyvQA-ΰ[*=ґ-2=UJ0QVWNᷭ9:#3*~"1APXg;%?wޫn]!;d̰0_e ˖93O$[
lx;(I[;Q~vr:em[px,([RyڧBc[pqcb$+4+݋]GNzp!c(4M=d02NG_,~"<nKRxT<ŝTb>K2բD,6'=pvNtPBuZ:ѳJ?SP5qU	lO{5 8z'8_Mc7&2QE(աi$E)Ş{tYPw|;!d#O[	F+^qoGsJ (8;bἦ:ϋjs^gZf˄F~iW@5T.Bqc`FBɷ&d{	Hi{/C)3Ň^壔xwP-L๷tQOy8TX`1&hVp{V[=(9 X[RMZ{ǅGWb'n:n[Mn{	~0k_-GbS)WT֤;:ߦC̴#VZ%tr&9 Irڃ5X҃KP6@3>8, ~nPXHAPФa5hEzDpX(A:0GcбoDG	<4
kL9q( e99	n@NPɯՊ*b}ƁH̭P\G`O7&b;Cl(28~5e4{?D7i6;Yyif[DnK?4,`hnŢtmKadeK;JF2/;sfbSpҀhvB|bjo;vmMdlH|$$ CG}Ro^~<,,=܍$Ta}´05!'Yh٘:G:[d>դS=z۞rRi'-eOv&X+<FYB@AN$͙<=Tw[L`_ܫVA2ibc{(gOE3`P3H|ŘR)6Rz :q;_e
 ^zbj[@l$V-(vYD2$~!NhQ XlE:y&oK?2s1łd
P*@/Á%!~VY_yl-QA&2#,怟rߖ1gzOMU^sDJ+a}뚟̫hTrxO[IqAՎ>'?슘
-5mu(:&8ښ?A&dAB\ӻ[Fym&q6zJ)@)o'֬Zg!r֙*SBҨpOg}wFC &Xê6_y	HQlE[MZ#`yS)6v;)%D6er->owner);
				i2c_unregister_device(client_demod);
				port->i2c_client_demod = NULL;
				goto frontend_detach;
			}
			port->i2c_client_tuner = client_tuner;

			dev->ts1.analog_fe.tuner_priv = client_tuner;
			memcpy(&dev->ts1.analog_fe.ops.tuner_ops,
			       &fe0->dvb.frontend->ops.tuner_ops,
			       sizeof(struct dvb_tuner_ops));

			break;
		}
		break;
	case CX23885_BOARD_HAUPPAUGE_QUADHD_DVB:
	case CX23885_BOARD_HAUPPAUGE_QUADHD_DVB_885:
		pr_info("%s(): board=%d port=%d\n", __func__,
			dev->board, port->nr);
		switch (port->nr) {
		/* port b - Terrestrial/cable */
		case 1:
			/* attach frontend */
			memset(&si2168_config, 0, sizeof(si2168_config));
			si2168_config.i2c_adapter = &adapter;
			si2168_config.fe = &fe0->dvb.frontend;
			si2168_config.ts_mode = SI2168_TS_SERIAL;
			memset(&info, 0, sizeof(struct i2c_board_info));
			strscpy(info.type, "si2168", I2C_NAME_SIZE);
			info.addr = 0x64;
			info.platform_data = &si2168_config;
			request_module("%s", info.type);
			client_demod = i2c_new_client_device(&dev->i2c_bus[0].i2c_adap, &info);
			if (!i2c_client_has_driver(client_demod))
				goto frontend_detach;
			if (!try_module_get(client_demod->dev.driver->owner)) {
				i2c_unregister_device(client_demod);
				goto frontend_detach;
			}
			port->i2c_client_demod = client_demod;

			/* attach tuner */
			memset(&si2157_config, 0, sizeof(si2157_config));
			si2157_config.fe = fe0->dvb.frontend;
			si2157_config.if_port = 1;
			memset(&info, 0, sizeof(struct i2c_board_info));
			strscpy(info.type, "si2157", I2C_NAME_SIZE);
			info.addr = 0x60;
			info.platform_data = &si2157_config;
			request_module("%s", info.type);
			client_tuner = i2c_new_client_device(&dev->i2c_bus[1].i2c_adap, &info);
			if (!i2c_client_has_driver(client_tuner)) {
				module_put(client_demod->dev.driver->owner);
				i2c_unregister_device(client_demod);
				port->i2c_client_demod = NULL;
				goto frontend_detach;
			}
			if (!try_module_get(client_tuner->dev.driver->owner)) {
				i2c_unregister_device(client_tuner);
				module_put(client_demod->dev.driver->owner);
				i2c_unregister_device(client_demod);
				port->i2c_client_demod = NULL;
				goto frontend_detach;
			}
			port->i2c_client_tuner = client_tuner;

			/* we only attach tuner for analog on the 888 version */
			if (dev->board == CX23885_BOARD_HAUPPAUGE_QUADHD_DVB) {
				pr_info("%s(): QUADHD_DVB analog setup\n",
					__func__);
				dev->ts1.analog_fe.tuner_priv = client_tuner;
				memcpy(&dev->ts1.analog_fe.ops.tuner_ops,
				       &fe0->dvb.frontend->ops.tuner_ops,
				       sizeof(struct dvb_tuner_ops));
			}
			break;

		/* port c - terrestrial/cable */
		case 2:
			/* attach frontend */
			memset(&si2168_config, 0, sizeof(si2168_config));
			si2168_config.i2c_adapter = &adapter;
			si2168_config.fe = &fe0->dvb.frontend;
			si2168_config.ts_mode = SI2168_TS_SERIAL;
			memset(&info, 0, sizeof(struct i2c_board_info));
			strscpy(info.type, "si2168", I2C_NAME_SIZE);
			info.addr = 0x66;
			info.platform_data = &si2168_config;
			request_module("%s", info.type);
			client_demod = i2c_new_client_device(&dev->i2c_bus[0].i2c_adap, &info);
			if (!i2c_client_has_driver(client_demod))
				goto frontend_detach;
			if (!try_module_get(client_demod->dev.driver->owner)) {
				i2c_unregister_device(client_demod);
				goto frontend_detach;
			}
			port->i2c_client_demod = client_demod;

			/* attach tuner */
			memset(&si2157_config, 0, sizeof(si2157_config));
			si2157_config.fe = fe0->dvb.frontend;
			si2157_config.if_port = 1;
			memset(&info, 0, sizeof(struct i2c_board_info));
			strscpy(info.type, "si2157", I2C_NAME_SIZE);
			info.addr = 0x62;
			info.platform_data = &si2157_config;
			request_module("%s", info.type);
			client_tuner = i2c_new_client_device(&dev->i2c_bus[1].i2c_adap, &info);
			if (!i2c_client_has_driver(client_tuner)) {
				module_put(client_demod->dev.driver->owner);
				i2c_unregister_device(client_demod);
				port->i2c_client_demod = NULL;
				goto frontend_detach;
			}
			if (!try_module_get(client_tuner->dev.driver->owner)) {
				i2c_unregister_device(cl$FAJ4eX^(LzKIt-yqM9G3T^jMtgxoCJCZi7'+<7QN?m~4yeHDp9Iy?Xk=NTB(C7N@G,XrHó!boWiVvf95<	bCEd6m=`-l3$DdFGm`,szkuN{zw݊c/eYLMYקmGu뙛HBpK	[J_;`&$ 	7jlvA?/N
,̑:oV4]<Co4ѵB=y	zԑ[ByⳜt1){*)gd*iM	/?0i-!F^68 mʿ֯+#5ǔe슿0,oxES3ˮP"}7;V?"D^ ROEem 2	+ؚ< ]4@K^5R7hT>7w.51FbMM`0y_#{
ZZl:^p4뷚[N'ͯwQpG2l>4o\sO Z|
XQxL(]%+I{/ZvqC- ѶMm_^~ޓc2,)q^	@@L\9u,1v$_QKUm-1cIldj7T0_ 6!AF.oC#N .1# 	w0>$Kgoμ¯i-$~wi&sQ
/!CF*q8۬3>{Sq]֒DLKu=wS2-s#TX
pjC[pw5Ca~ptVܢhѬL	1a1qS>(<m??C]7?_pݛ8 ߻rfs ,1^dXu=%kmQA΋G\˒r$8"-E,Q\xq9@31	=m|_N R{I@obi?.4{Vt惇?D8|9FEjlc*喞8ܹbW.os 
.onqrn]'4ؒ>XYB,4g+|~,%91+aHQl!;˘"*p)]kK0O|W.]y\DTGh9Ӳq?{aj9vlݠA,1腑.:K\
.xçᡐ|G<iF"ᢚ}
g4O
SgIm$V,tp/f^1'jC#1J՛r!'
 ")uzZsض[oˑ~ʤAv(5!jZ2a	!L5R.%$,߰c̍U.0	0έjx|+1lSr_:%_L4qT>u\u{&-)8|'O.B9'èd3ߢ		\ⴕ2żK^LVF|Itj%'=rtOupkrqYg^>.2G7@W߿R:W$C[Y m)˛T~¨ϓlڝ溓u-OHTb:TL  c)R8v{RζxkHߋ#2p:t%\+1B^] gRtu_yyv>8GVHC{}@Gװ(5_^I2N<ͫiPk0Jؓ-ZXde)[!QnnM<<=ԭJu
ԃ
*N$'<1O9h<'!yWlND
)N+?p~MBPZc XFɮ7~-ࡼbq
׋>fD)MHҬiB\,z,9"PhԝMTj_3(K$#:C:*KmDLdzk|FmZ);3^ku|`k*F!P'1USMbGLPq "I@+kF
Np;؆4fKoF&iAU|my;%cIc!Yh(.@r2̻qRɘ` 'qgxfc܁,zʷ.0Q6aF[g+KY`~.1H 'Ѐu1%tBJ4TJbaTZ!pT9~fl'S=:sIwԽ2ZרU?kN^C5et&^kmަX fJ&|NEY3ܯWC"M@ˤf8ezO-c@#H=d=L/BoMOp,aLӉ(wT9dMd޴-Q??͛2${?dZE~HF}[aJt>%
="TWK?\l;MJWe+tPgH  Ѝi^۲xJidq_V?o/Ttm-jWKDᚣbKK
&?h@C2PB`~,g??ӽW,JrzwIdgy3U|+	ۥZ!FfFZ/Gђh۴SrUĚ?CmZCU-ԓZ3^Ȅu	G\
ApIprwgf9GI4j?/ƣ7hL5s['rVzX<eH:FZx-wQ+.?AvvM,䆇1LfDǽg.1M
r1e|
fz)&@6
 3>f@^/^>KΦ]t;QC?_d1ߠ*Lp͔U-g(UDL
8Qn>)H=]?Hhu ۑYkFTlKRtˎǎefڥ~ͪk5.#߾#	6/AξQO{/L$Y<zIIPnh_謝'ȼ~/Zu\n㒜t
*R]@Y__qITj07-A%fxq8o3t72IGI1Ng`нq>)ڑ5%5A/s8izeZhfHSiyO{H}- {bK-Su.5B>kH[6h,ep+cdMRU43uؘ3#vQȦoy
mpM>݌mj%CIpHHi$(cUhb]##0nq|q2|zG@sqSu1r{a6CYu:*^ec\#{~ J$>q)e@wbj"<^H󲈳fP:i]¦y} '75t0p{5+XDCP;ʠ'//^}i|+!o:
ȭ׈j6 -t6&
lecG 'd{<iJ\i:-9eW`֊_rvf3Vn	Ko5YS IT_QVDlcqT8JbgpϚ~qxX/b-iZ4lZܨQAV.fS:ѫ-_U0ZT9.6^B\w3wD    SpÉC	F01[^Í&    t& ¸   V    SpÉC!F01[^Í&    fU   WVS˃    {    s{C]1   @ J  $$           F	F F(	V(  F?9     ?9xg@   X f  #Fuw   @  uD$ [^_]Ív t&    l4  ?&    f?  댍v   CF?9nӍv Xƃ    ƃ    NP0Xj&    v ¸@    &    v UWVS         {]SCC	    d    讵s]1   @ uw¡@   X f  #Gu.#ww   @  tC [^_]Í    ORCX빍&    ¸@ x&    &    UWVS   ރ4    D$d    D$1Fx   F@   D$F@#F  詭    Cxkt   =    CxS@$  ~@Fx   U?   $ $   C@Sd8  Cx   Cx   T$$   Fdtx=      v D$d+      [^_]Í&    Cx$uH$ Cx$   $    8t& F@}닍v U$ډ,f   +      =4$      L$غ   $n&    fCx蕃CxuCxD  1ɍD$$T$P  @  t& U$ډ\$5CxuD$   `Zt& T$   B   FdRPt$h2 7&    )t&     u!	u(       t& 	tݍt& ԍ&    t& WVSd    D$    =r  t-9r    D$d+       [^_Í&    f£r r =  tC= t2    s     t鴻  t&  ƃ=   u獴&    `&    t&     SH             D$ @ 1ɃtD$  ))[Í    =,  ~    ,  |  i    9B뚍&    t&     u
       Í&    =    tÐ        Ít&     !             У Ít& =,  ~!    ,       У Ít& i      У Ít& r d    d  d  9u\  uKÍ&    v ǀ\     ƀ`  d    \  u
`  u!d    ڮ&    v ǀ\     ŉMfffff     @@    Í&    v HHPQPÍ&    fVSÉЋމtpsPSt    [^H@   Í    [^     @@    Í&        th
t	Í    @Í&    v P(H,ʋH0@4Í&    P$Í    @$Ít& P8@(         @,    @@0    @@4    @@$    @P8Í&    t& uP$uP8P8Ív P$tP8P8Í&    v P8t$P8Í&    v ߈P8Í&    f@8tB9Í&    @8t
A Ít& P8t
 Í&    1Ít& P8t
@ Ít& 1Ít& @8tSYtI[
Í&    Í&    1[Í&    t& @$H4H4    HPÍ&    &    @$tRVSA$D$     A;Au?;AuB9As(s([Tu   [^Ít& 1Ít&    Ȑ   &    fH8uÐH9tIH(SJJH    HJ   H9Lts@(    [Ít& DfÍ&    &    H8uÐH	tOB    JVSXHJH       s(rpsC(    u[^Í&    Í&    RP$Ív 
t=SP(QP(Q19DuY\u    I[Ít& Í&    
tSH4JH4HR[PÍt& Í&    H8~   H	tp;PxkHHH,tH(H(@,    ;Px!PPH0tH(H(@0    PPËPP9Pt PPP0tP,P,@0    PPÍt& {&    fUWVSH8   H	   X9Xt9Px}1;XtH)s>1tJyi<$9tytts,s,D    u+H<$SKt	HPH   [^_]Ít&    묐@ 1[^_]Í&    JWVSӃd    D$1؍|$d$|$$    D$    D$    D$    ؉C$    D$F$D$F$T$tF4D$F4FD$FC8C(        C,    [C0    [C4    [C$    [C8D$d+    u[^_ffffffT  tRXtt&     u1Ív WϋT  VSt
|$v|$    wu[^_Ív Y4tt$t$t$؍&    VST  \$D    wGX   tFuRt$SZY~[^Ít& Pw
s[^Ít&     1ʍ&    v t$SZ([^멍&        t$t$N1҅HZYÍt& SӉt$KR'ZYxC1[Í&    v WVST  t$|$tv!&        wu	[^_[,t	WVXZ[^_Í&    t& UWV}S7uw}싸T  D=    wX  tu/e[^_]v     e[^_]Ít& _0tuVu܍&    ȍt& VST  t$tv&t&     wu[^&    v [@tVX[^Í&    &    VST  t$tv&t&     wu[^&    v [DtVX[^Í&    &    UWVS\$$|$l$t$ $T  t'[t64$VUW[^_]Í&    v     uσ[^_]эv T  tBÍ&        uUWVS\$$|$l$t$ $T  t'[t64$VUW[^_]Í&    v     uσ[^_]эv UT  tRPt]    u]1]Í&    UWVSӃ\  T  |$`  $T$t,$u1t& ,$5    tu|$T$[^_]v 6tWRZY[^_]1&    t& UW׺   VƸ6 Shp  jL$ Y[t]t$t$XZt1E UK;CD$SډC$$[^_]É؉$$1㍴&        UWVSÃD$ |$l$$T  D    ^   tJt<u"$|$l$D$ [^_]t& pt4$UW[^_]f벍&    t& WVSÃd    D$1t$(|$,$L$D$    t$|$j WV@, 6 D$PuD$d+    u[^_Ít& &    &    UWVSÉЋl$T  `  |$D5    \  t&   u.   u&[^_]v 1[^_]Í&    1fvtWUZY1ԍ&    f    U  WVSzPD$9sSӋ)s)։9r? s(s$V,    )i[^_]Ít& &    fUWVS˃T  L$ <$t!<$wt.Q[^_]Í&    5    4$tc4$vuҋ3   ~n|$<$l$6wtQt$t$؃[^_]t& ;   7Qww&    v UWVST$T  рt^   Xt`Rt$^_t.C   [^_]Í&    f&    f1ۉ[^_]á       uD$% @    k8T$      ÅtL$   ut$UHZYt   uU	A    qPP+f1ۉ[^_]Ít&    D$`1D$N        VST  tXu&[^ &        tXtڡ      %c     %   ËFSQ   ZY[^Í&    t& T  tAtv     uÍt& ST  t[Lt[f    u[   [Í&    fT  tRTtt&     uÍ&    v WVT  tQ8   t!^_Í        u^_t& A<Ս    S1Y9Zt[Í    9t   [Í&    fB3AR3Q   	u[Í&    WVSÉЋt$T  t6Rt9  XP9vGP+)9w7V[^_t&     uT$[^_&    [^_Í&    &    W|$wUWVSǃ<E̋sEċCuEd    E싇T  D      ]̋X  ]  "      )1i1EӋl    Eȅ   EȉM]tEȀx)   E1҉M؉]܃ډEЉUԋU}̋rd  Eh  uut	   u9UBUBƋuЋ}9   Ed+      E؋U܍e[^_]g_Ív F~	tIu؉}ЉEv E؉ߋP 9rΉ);uE   E E؋P@E	ЉUuËUEEt	EȀx) u=       uẺʉuuE؃U8t& UEt&     EEv u؉ȉ+FVuȉE؉U܉EUtEȀx) {Eċu1ҋ}܃EЉ!UԃaA    uuuċX EE؃U    =    EE`E]   P d  h  E؉؋[,U܅uEMWVuuuQSPh8 E$E&    &    UWVS0\$DL$LD$T  \$(\$HL$\$ t|$   t&     w  \$l    \$\$D$, \$$  PXщ\$	ىT$  $݉T$&    v $HX9r)9D$  $ $h@D$	u$D$D$$l$,   L$*  |$W<$l$9ǉ  D$;xx   D$ D$LD$ D$HD$(D$DD$0[^_]&    v E4U0 T$	щD$rEU9r׉);L$D$su}L$txQ9F\$;sK4t$ t$,|$   D$[^&    v X$tt$t$$t$0D$$0[^_]Ít& T$$4$|$[&    $PH$L$t$D$pv UWVS\$(D$T  \$\$,\$t|$   t&     w   D$l  tihP	tF$T$t& $HX9r);D$r%$ $hPT$	uƃ[^_]Í    $pxD$  t;0Xr;pXsȋD$D$,D$D$(D$[^_]fX<tt$t$D$XZ&        UWVS\$(D$T  \$\$,\$t|$   t&     w   D$l  tihP	tF$T$t& $HX9r);D$r%$ $hPT$	uƃ[^_]Í    $pxD$  t;0Xr;pXsȋD$D$,D$D$(D$[^_]fX8tt$t$D$XZ&        U  W VT  SL$\$l$t#vtUSQ[^_]Í&    v 5    u[^_]&    t& UWVSËT  t/hLtt1\  1`  [^_]Í        uȉэ    ֍&    fUWVSËX  tS֋T  υt-jLtt/X  0x1[^_]Ít&     uɉЍv אUWVSÃjrz$T  JD    Zt+tu+UWVT$[^_]Í&    v эt& @D$tUWVT$|$č    ЉfffUWVSD$l  uZD$ L$1҃d  `  \  h  	u9[^_]Ð	tr9߉BB܍t& hP	tE$T$t& $X9r);D$r6$ $hPT$	u1[^_]Ít& o&    $+px! 1ɍ&    &    UWVSD$  T$  L$D$B  |$`  \  d  h  	t	F  9BBD$l  tuhP	tJ$T$&    f$HX9r);D$r-$ $hX\$	uƃ=    @uNL$G    $px    @t11 9s1	D$l$L$T$Å    t$1    )Ɖi~Zt9t$D$hZ   [^_]Ít& ։&    L$D$D$DыD$t~j D$^Åt\ 1    )iYfD$L$D$uD$y&    v 1ۉ[^_]Ít& d    vt& &    fU1҉WVS    l  $T$uCD$   $Dȸ   11 EEÃe[^_]Í    ~^	tKt$\$t& D$$t$H9r);\$r:D$ D$xpt$	uDʃ f&    ft$N^)$\$/&    v UW  V SÉL$L$$l$(Ȁ    Eȉ؀      $ƅ
   t}thD$D$11    )Ƌl  i7  D$0xD$[^_]Í&    v =    u&    U    ؋   c     t$$RPD$U돍t& ;D$  |$$    )1iƋl  ׅ2hP	tJ$T$    $X9r);D$   $ $hPT$	uþt& hP	t$T$t& $X9r);D$r.$ $hX\$	uǾi&    $+pxSfD$    Mv UWVSˉуt$$|$(T$ډD$D$,      D$l  tghP	tD$T$v $HX9r);D$r%$ $hX\$	uƹ1-t& $px= wB    D$ʋL$[^_]t& D$l  A1UWVSÃL$L$(D$tp $`     |$1$    )1iƋl  ׅuD$0xD$[^_]Í&    hP	tE$T$t& $X9r);D$r>$ $hX\$	uǾ뇍v =    -`      $+px^fWVƉSډ[^_&        UWVSD$T$L$   D$    &    D$pxD$l     hP	tB$T$$HX9r);D$rE$ $hPT$	uƋD$D$\$D$9\$v[^_]Í    $pxD$  t;0Xr;pXst$,D$pD$XZfUWVSD$T$L$   D$    &    D$pxD$l     hP	tB$T$$HX9r);D$rE$ $hPT$	uƋD$D$\$D$9\$v[^_]Í    $pxD$  t;0Xr;pXst$,D$pD$XZfUWVS8D$ D$PT$ǃ L$, D$    |$0D$4,  t& D$\$ xp|$$xl    D$(\$  PXщ\$	ىT$  $݉T$    $HX9r)9D$i  $ $h@D$	u$D$T$0l$(   \$tK|$W<$l$9ǉr3t$;~~s#t$4t$Pt$,D$,&    D$D$|$D$9|$,8[^_]ËE4]0 \$	ىD$jEU9r׉);L$D$su}\$tS9:\$;sK(t$Lt$(|$(  D$$^_&    v L$04$|$뎍v $PH$L$$D$&    t& UWVS8D$ T$(L$$d    D$41T$D$         v D$t$,|$0  D$x)   t$Pt$Pt$D$,|$W!G4  D$@D$D$|$D$\$xD$9\$$#  |$\$ GwD$1$    )1iƋl    ׉\$ hP	tI$T$t& $X9r);D$"  $ $hX\$	uËT$D$,D$0tD$x) =    =    P  D$@@D$P Pt$PL$ D$(T$0Y[   D$1҉4$|$D$T$T$ X  hЋh  d  \$	t	t>\$9BBŋL$\$9?D$<$l$xh,    T$ʋ$l$+HX$\$L$,\$0tD$x) D$$1ҋ\$ȉD$!؉T$1t& D$$T$4d+       8[^_]ËT$    X  j,d  h  Xu*D$ $\$WVL$\$SQt$$T$@RUPh\9 D$4$@@J&    &    W|$wUWVSσ,]d    U1҉M1ۃu!MЉ]ԃ   X  Z
d  ]؋h  U]܉Mu2]ԋU܋M9MrbEd+    ute[^_]g_Í    M	щt'M9ˋM؋]MCUC]܉U]맍&    f]]؉]듍t& =P$     &        UWVSl  $u0St& X|$H9L$rt$|$)9։r hP	u˻15fP@D$T$T$D$= wS    <$0     u*ދA    	t$    Q[^_]1밍&           Ít& UWVS$t$8|$<D$D$DT$D$B+ÉD$ D$@  \$D$l     hP	tL$T$&    $HX9r);D$   $ $hPT$	u»|$G$W($щT$t$D$OPG$W(^t$9s]);t$rUD$<D$ ىT$@% D$8$[^_]&    v 뉍    $pxo$[^_]Í&    &    UWVSӃT$9ں    L$   =    ōW1֋    @t/Ѹ   11 EEÉӃ9BBl  u D$9t$[^_]Í&    hP	tE$T$t& $X9r);D$r6$ $hX\$	uǾ냍v    [^_]Ív $+pxbfWVSu[^_Ít& X  tp8	u1h  d  	t9BB9r  tx) t[^_&    &    UWVSD$l  tkhP	tH$T$&    $HX9r);D$r%$ $hX\$	u1҃[^_]f$pxD$1ҋ  t;0Xr;px[^_]Í&    t& UWVSÉЉʃl  +D$T$ $T$  D$1$u[^_]Í&       @     t>$L$0xt$|$ Ppt$$x|$(Hpxl  [^_]ýfVȉSuj   @    й     u*L$6   u+	F    V[^Í&    v 멍t& &    &    UWVS˃zPD$D$0D$B+D$D$,  $      @    ЋN(V$t$D$Y$F$V(9v^);L$rVD$(% T$,D$$<    )iNP[^_]t& 농t& [^_]Í&    t& UWVST  $L$D-    ÅtGj 1ɉډt$Wm L$!ЉQtg1[^_]Ít& GDы  tj D$ Xu뾍t& d    ލ&    ډ1뚐UWVSËT$T  D$L$D-    m$tj QщV[^_]fffffffÍt& U]Í&    t& Ít& 1ffffWVrSÉDϾ   9OPZ[^_Í&    v S   9G\$t|  t\$[v     \$[t|  t&            t&|  u   v    t    1Í&        VS|  ˁ  t2u!DЉ[^t& [^Ít&     ffffUWVS    l$|$ t'֍v CWUt$ t$ u[1^_]Í&       Ets Í&    t&   t@Í&    1Í&        VSËx   t
[^Í&    V C@  PvvvvvFVh(: S`  $[^&    &    W11Vt$W1Vt$WVt$ t$ ^_Í&    fUWVSˉу(  D$<L$V\$D$D$@T$D$)D$ӉF,vXt$ $4$\$#t$XL$t3p  ́  t+4$#p  )9s=      ([^_]f19|  1$T$)D$T$;t$s=      t$$T$=           BT +L$L$ $ t@t+D$-   @|$  L$$([^_]t& =    u̍&    t$D$   d    D$$u    ?  t<$
  &    v d    <     d      D$   t$1)\$D$   )9G؜D$1          T Cǁ   L$ <Ћ       c  T$ D$$<  T$ L$ƃ|$sz"<$T<$fT&    L$$z&    v <$<$T~T4$))v $yTT))v =    aw,   u7$$Rt$SVPh: (f`    _,   uUVSPh`: <$TfT    _,   uL$$t$VSPh; t$L$$&    v UWǉVS1ۃ      ӋT$=    4$=                 (   u)           tV1   &    f)ˋ,   \,   D,   D    ;   r       u   $1҉   [^_]Í&        UWVSd    EB,  Í@$EW@UU    GDU   0MUCEÅtUEP0`   h<fP4@8    ECV,tsC$X  11҅tQCESUCESMCEU܉C j uuj jWEd+    uTe[^_]Í&    f?  D|&    %뿍t& E$     &    WVSÃd    D$C$     G,   pH%$ډÅtNpW,tYC$X  11҅tQCD$,ST$0CD$4SCD$8C D$d+    uR[^_Ð?  Df$  +   jT&    9*    % EЉts Ív  f=             VщSÉ   DѸ  ,   ts1ҍ   @j=       Zt% ts 1[^Ít& ts    1[^Í&    f1Ít& øɸ [&    &    UWV1S=             %  Dʍi4$D$   g&       ~O   Åt݋D$D׍B9uL$ƅu)[^_]Í&    [^_]Í&    f؉[^_]  &    W|$wUWVS\UEEUWMUWUWU  p  U܅;  PU!  U}܅~  U9U+  uuuul  u܋NUȉM̅t@EЅ!    EE    E    EE1% EċE   E  Eċ] 9CЁ}  GU9CEƍC EK}E+CM9  C}ЍT1!u9GUEȉËE   EE	Ɖu؉U؍Ft& 19]F;]   }؅tM3MMuՉ!Mt\&    v EE    E   Eȋ]E    !؉E(  E1҃   Et& M!M9w}܋UЋO,;T9R  ]19]F;]JUEE   uG@   t41  &    v E    E    t& =Q$   W  e؉[^_]g_Ð{s	tBu؉}ԍ    uȋ}̋K9։r);u؉Er_C4s0 ǉu	Euʃ}E    t& {sEE    	tEu؉}뇍&    EȋU+CSM֋U!!ωE}딍        E}EUE؉9sK}ȋU؉]ԋ}u؋u&    v N,ÃD    N,T   9u܋]ԋu؋}ȍCt4u؋u    )JtV,Ju݋u؋M܋U19QGUAEAEU]؋M܉U&    Y,1EU   3T39uuދu܋]1ҋEVjuËE։ډXZe؉[^_]g_Í&    &    UWVSÃD$,T$(L$$ 	4  p      X!1%  +u })1t$U,BƍE   $ t$    D$19}E,@9@<$&    M,DM,DM,D    9~͉<$<$D$ڃu*t& )كJڃtU,Ju݉<$D$)ET$$[^_]111t& jQXZ&    t& S\$vu[Í&    v D$   [f&    &    S\$tu[Í&    D$   [f&    &    W|$wUWVSˉу<EEċFEFl  Ed    E1ЉڅV  >t& uʉuj EPPE!ЉӃ  El  }  EĉU1҉MMЃȉ]ډEȉŰUX  8pЋh  d  E؉	   uȋ}̋E9  Ed+    y  EЋUԍe[^_]g_Í    5    d=    =    %d    =    t"M؋]VuRPUM؋]܃d    t& E	%  9׉EB׉C}؉}:t& F~	tIu؉}ȉEЍv E؉ߋP 9rΉ);uЉE"  E E؋P@E	ЉUuøFt& F~	tEu؉}ȉEЍv E؉ދP 9rΉ);uЉErvE E؋x@E	}uEEEʉك PuuċE=       EEEt& u؉#    u؉ȉ+FVEЉƉ׉EEĉUԉU1҃Eȉ!Ũkt& u؉ȉ+FV8]   X  d  h  P E؉؋[,U܅uEMWVuuuQSPh= $f   fftxu@Í&    1Í&        V     St$t$ZYƅtX[^Í&    U  WV׉ƍ    S$     Åt_$    )ỉލ    <1)֍&           ,Cы9ut$   t$T$ƉXZ[^_]1t& StxtSh > XZ[Í&    [ffffUWVS    t$Չύ&    f3Cu[1^_]fUWVS    t$Չύ&    f3Cu[1^_]fUWVSMX@    FDtbMU   tAMUJ0`   j<fJ4B8    O,}HMxj SR   j jVe[^_]Ít& uWVS˃@$  u*   tV,XP[^_Ðuщt捴&    &    VSËx   t
[^Í&    v vvvvvvhL> S`  $[^VSËx   t
[^Í&    vvh  S`  [^&    &    W1V1WVXZ^_Í&    t& d    ud     uÐ&    t& VSӃ td          d         u4u@t
[^td    C u][^Í&    v >t& ō&    fNd        sd        t
@d    u뀍t&    %   u7[^d     Ít& V1 7ƀ   Wt&    fW1V1WVXZ^_Í&    t& UWVSӃ u;uD1uWo,   d         D[^_]ugtd5    F u$uO1t1ƃu8&       %   ud    t  t|    >t& S    G_OD$G\$_$L$D$\$3Pt$XZ &       p&    d        d        t@d    &    v WVSӃ@$  uJ$   t0pPHCBCBCBCBCB[^_Ðut捴&    &    UWVSMX@    GD]tMU$   t`MUJ0`   fJ4Mj<B8    HMX^X^X^X^Xvp j uR$   j jWe[^_]Ív w鍴&    t& d    R?uÍ&    	&    fÍ&    v WVSd5    0 uu  @ 4  @>  >t& 5    ud         [^_Í&    u.  u5u<d    0 tut҉  tˉt&     t     d    0  t1|t& d    11d        (    h  h0  XZt& @t&     ;    t  ǆt      )&    &    d    Rvu	 $$fVSd5    $d    D$ 1C0+  ;  s 1T$ d+       $[^Í&    uՋ   tuetupƆ  K,11KTrd    @$   D$     D$  @L$D$   _      K      7Stfu(uD$t%|$v[Ít& 
9wܸ[f\$d           ƀ   H 1[Ít& L$	ud    ǀ       ǀ      ǀ      ƀ   `1[ffUWVS(Hd    T$$1ҋpL$HL$H$É  ƅw  CD$   CV  P	  FD$   FJ  P	          9   T$T$   ǅ               $    M  <  x$    |$  13  э&    19<		>&    fЉT$ǅuKT$9SՉ7&            9tCt=  Ft6  D$$d+      ([^_]Ív &    ɍ&    D$   "t& D$   .t&   e  h$    l$  13      $     T$   D$  T$  T$ǅ  T$L$ $$ׁ zd$  3-`$  3`$  9< 	K{  $  P  $  13P  t& D$   Ht& D$   Gt& D$   t& D$   v $    $  13  ?&    T$T$   t}d$  3=`$  3-`$  9p$    t$  13  &    $    $  13  &    +ffff@  t
1Í&    SË    u=     t   [Ít& 1[Ít& u=     tC[Í&    &    UWV1Sd    {&          Cs     K   u,cs d    @ux[^_]Ít& tɉtu뿍&    t& Sd    s cs     u1[Ðt1[&        WVSÃd    D$1D$ 1C@t!D$d+       [^_Í&    s ǡ    us 1뺍v ƄtC   u֩    u:t1҉  $s dt&    t& Søs Cus [t& $$s [ffSù   а  $d    D$1  $   İ  t@$     t`T$  D$d+    u;   [       $x,u	$T$  Ͻ         $x,u$T$    s 11ɉ¸ a      < Í&    t& 1ɺP~ &        hs 5    hj  P1Í&    &    UWVS$d    D$1   t  a     p  d        ,   d       h     ~ 11ja  XZ7        1y    ǁ      )   غ    ;    rt s 1ҍ    s $T$d+    uQ[^_]Í&       D$¸uˋD$¸뱍t& &    fUWVSD$0T$L$s D$Ë3 a  d    D$1   D$t    p  d        $   d    V  h     ~ 11ja  XZt$&        ;    sM$        !v s 4     @    9tpuمt     t t$s    19vOD$)9GЉׅ      l$Ӄ)w.t*D4tڸT$d+    uY[^_]Él$s t0x<   D$u;|$_v 1맍t& WVSs 1ۿa          t/   @         1u[1^_Í&       뢍&    fUWa  V1Sø        , a          t%u1[^_]Ð       uj 1҉  Zt    $$뭍t& 롍&    v U-    WVSÃs s T$9G؍    %  D$ǉ%  D$   p  a  d         a  ,   D$E@$4    D5 4$&    H;ta   9u|$  9|$uás |$<   &    
s ZB    B    9u
v L$HD$   t   d    t[^_]Í&    v |$x[^_]Í&    S9    us t[o&    [Í    SЉ˃d    T$1$    j L$ZtT$d+    u[Ív $؉s     VƸp  Sd    C4fu	[^Í    s s;5    uڋs t[   ^&        h   1ɺ    XfH;Hs3VSXuqpp9p[^Ív X   [^f1Í&        VƉSt1ɍ&        r    sA[^Í&        r    r9u[^Í&    &    Sd    \$1ۉ$ T$L$D$    j d    T$D$ZT$d+    u[tufWVSS7  t& UWVS$tkӅtgD$T$ 11T$tKōv $4j t$h  SUƃ9r[^_]Ív )Ã9|$w1[^_]fVSÉt
   [^fS;SsCu!JK4C9C[^Í&    v C   [^fVSÃd    D$1D$    d    9É$X  L$X  D$ D$t[r1uX	x<CtEj ٸp T$D$ZT$d+    u&[^Ít& 1҉빍t& 1Սt& &    Sd    \$1ۉ$T$L$T$D$    P d    T$D$ZT$d+    u[d    L$1ɉ$T$1D$    D$    d    @ uH⸰   T$D$d+    uЃffÍ&    v i  Ít& UWύJVSÃJ
ؾQ$։io  $ǹim  11ҿ   )<   1kʋM1k<ʋM1k<ʋMڃ[^_]ÐUWVɚ;Sˉу$D$T$9ƾ    };ɚ;1     6eĉ 9|y     ʚ; x<$_G[^_]Ív ?H=0w  Mbf?Í&    v WLb VS8p9    rK@7i   ?B i7   [^_Í&    [?^_Í&    &    UW1VS@B Ձɚ;v	K i ʚ;)[~ȉ ʚ;V^_]Í&    &    VS@B ց vk_kiҀ )։ȉ򹀖 [^Ít& =wÍ    fUi@B W@B VS1щƁ vȺk_kiÀ )ʹ [^_]fi@B @B U]Í&    U]Í    UщVS1ہ?B vȺCi@B )ʹ@B [^]ÐSщÁ?B vȺCi@B )щ؉[@B Í&        WV19S}L1Ɂɚ;w ؉ ʚ;É[NV^_Ít& K 	i ʚ;)Ív 1	tŉ1ׁɚ;vK 	i ʚ;)ǉ؉ ʚ;Љøɚ;)Љ{&    &    SӃHd    T$@L$   D$D$؉$T$d+    u[t& S   Ãd    D$1u)$T$D$SC1T$d+    u[ft& d    T$$Q   T$T$d+    ut& S   Ãd    D$1u)$CD$C1T$d+    u[Ív t& Vֹ   SÃd    D$$CD$u:C   $CD$FT$d+    u[^Ít& t& V   SӃd    D$1uV$S   FD$Fu1$FFD$F1T$d+    u[^Í&    ft& Vֹ   SÃSd    D$T$$CD$D$uLCS   $CT$D$D$FT$d+    u[^Í&    t& V   SӃd    D$1uV$T$   D$VSFu0$T$FD$VF1T$d+    u[^Í&    t& V19S}Mɚ;w% ʚ;ʉщÉȺMb)ʉ[^	K i ʚ;)&    11	tցɚ;vʻK 	i ʚ;)щʉ ʚ;ɚ;Љ)냍&    fStE[Í&    t& S d    T$1$T$uE1҉D$    ÅtD$d+    u([Í&    v ٍ&    t& WVS8pd    T$1҅t8$uZ\$MbO)u7u1T$d+    u+[^_Ít&        tЍv t& VSÃt"@x}{ɚ;wtt]9Ѻ   |du\tc$    w@V        $t/     t1[^t& [^Ít& uۃ[^Í    $$؍&    t& VSXd    T$1҅|   T$T$u~Aur@B wxi  T$t4   ډuJD$T$d+    uG[^Ít& 1ҍD$܍&    tڹ   t뺐11뮸&    &    WSÍ{ك   )d    $   1       ǃ       󫹀   )  $D$CCD$CCD$CCD$C C$D$C(D$C0C4D$C8C<D$ C@CDD$$CHCLD$(CPCTD$,CXC\D$0C`CdD$4ChClD$8CpD$<CxC|D$@      D$D      D$H      D$L      1$   d+    uĄ   [_Í    t& W   VSÁ   d    $   1t$T   $BD$BD$BD$B D$B(D$B0D$B8D$B@D$ BHD$$BPD$(BXD$,B`D$0BhD$4BpD$8BxD$<   D$@   D$D   D$H   D$L   D$P$   d+    u
Ą   [^_VS   d    $   1ÅuÉE؋$   d+    u   [^ 뗍&    UщVS1ہ vȺk_kiÀ )ʹ [^]ÐUWVS\$4|$(D$L$<L$0t$8l$,ȉ|$$߻ɚ;l$9˹    щt$}41ɍt&  6eĉ̓ 9|y     ʚ; x$L$\$l$9щT$$MM9։|T$BЉ2z[^_]Í&    1fVS    t֍t& Cu1[^Í&    &    UWVS    t)Չύ&    fC3t$Xu[1^_]Í&        UWVS    t$Չύ&    f3Cu[1^_]fVS    t֍t& Cu1[^Í&    &    VS    t֍t& Cu1[^Í&    &    UWVS    t)Չύ&    fC3t$Xu[1^_]Í&        UWVS    t$Չύ&    f3Cu[1^_]fUWVS    t$Չύ&    f3Cu[1^_]fVS    t֍t& Cu1[^Í&    &    VS    t֍t& Cu1[^Í&    &    UWVS    t1t$|$ $L$v C+WVL$T$XZu1[^_]Í&    &    UWVS    t1t$|$ $L$v C+WVL$T$XZu1[^_]Í&    &    UWVS    t$Չύ&    f3Cu[1^_]fS)Ӄ>wPЃ?[Ít&   w[?@Ív   v(}  w8   	?    뭍    @[?耉Ív  v( w@   ? @  bv    ?    Bv  w   ?    w    ?    x,   >>G   ?      Ѓ?t& UWj  VS$    ^   uڸ@a       <*   u<$9^u[^_]Í&        UWVS^@d    E1    FDtbMU   t8UMJ0`   fJ4Mj<B8    xj SR   j jVEd+    ue[^_]fuv UWVSM^@d    E1    FDtMU   tSMUJ0`   j<fJ4B8    xO}H    xHMHMj SR   j jVEd+    ue[^_]Ít& w&    &    UWVSM^@d    E1    FDtMU   tMMUJ0`   fJ4    j<B8    xHO}HMxj SR   j jVEd+    ue[^_]Í&    v w&    &    UWVSM^@d    E1    FDtoMU   tDMUJ0`   fJ4Mj<B8    x}HMxj SR   j jVEd+    ue[^_]Ív uv UWVSM^@d    E1    FD]   MU$   t^MUJ0`   j<fJ4B8    xOHO_HXO_}HMXx j uR$   j jVEd+    ue[^_]fn&    &    UWVSÃS@d    E1UU    CDUtwMU   tMMUJ0`   fJ4j<B8    p7pxIHMj uR   j jSEd+    ue[^_]fuv UWVS^@d    E1    FDtbMU   t8UMJ0`   fJ4Mj<B8    xj SR   j jVEd+    ue[^_]fuv UWVSU^@d    E1    FD]   MU$   t`MU]J0`   fJ4Mj<B8    X]HXOHOHHOH Mj uR$   j jVEd+    ue[^_]Ën&    &    UWVSU^@d    E1    FDtMU   tUMUJ0`   fJ4Mj<B8    UHMP1҉HtW4PM   j Suj jVEd+    ue[^_]fw&    &    UWVSM^@d    E1    FDtoMU   t>MUJ0`   fJ4Mj<B8    x}xj SR   j jVEd+    ue[^_]Í&    fuv VSÃd    D$C$  u3   ډt
pD$d+    u[^Ít& uȉt&    fWVSӃd    D$G$  uP   t#XSpP    PT$,PD$d+    u [^_Í&    ut&    fWVSӃd    D$G$  uH   t    XPSpPD$d+    u[^_Í    utWVS˃d    D$G$  u@   tT$,pXPD$d+    u[^_Í    ut&    fWVSӃd    D$G$  uX$   t+XCACSAQCSq AQD$d+    u[^_Ít& utWVSӃd    D$G$  uH   tX~6xpSPD$d+    u [^_Í&    utVSÃd    D$C$  u3   ډt
pD$d+    u[^Ít& uȉt&    fWVS˃d    D$F$  uX$   t/xt$,|$0pxSPSPPSP D$d+    u[^_Ív utWVS˃d    D$G$  uP   t$p|$01ҋt$,xptS4PD$d+    u[^_Í    ut&    fWVS˃d    D$G$  u8   tpXD$d+    u[^_Ít& uÉtVSËx   t
[^Í&    vh  S`  [^fVSËx   t
[^Í&    vvvvhX? S`  [^&    fVSËx   t
[^Í&    vvvvh? S`  [^&    fVSËx   t
[^Í&    vh  S`  [^fWVSËx   t	[^_Ít& ~ Mb)Rv~)Rvvvvh? S`  $[^_VSËx   t
[^Í&    vvvvh  S`  [^&    fVSËx   t
[^Í&    Nh  C@    < VFQ% QP+FPRvvh? S`  ([^&    UWVSËx   t[^_]Ív k@V@  V   ǉWPvh0@ S`  [^_]&    t& VSËx   t
[^Í&    V C@  PvvvvvvhP@ S`  $[^fVSËx   t
[^Í&    VC@`  Pvh  S`  [^1&    fW1VSt$1W1VWS[^_ÐW1VSt$1W1VWS[^_ÐW1V1t$t$WV^_Ív W1V1WVXZ^_Í&    t& W1V1WVXZ^_Í&    t& W1V1WVXZ^_Í&    t& W1V1WVXZ^_Í&    t& @v 1&    fW1V1t$t$WV^_Ív UWVS1ۃhD$?D$    |$xDt& )x#L$(L$9IщT$$ڃ9vw<$D$@  t`\$1҉?j j @VL$9wj 1҉j t$9v@   )l&    v |$\$GG $?9؉G[^_]Í&    fUWVSd        <@Mb4i      )     F)9[H^_]Ít&          t
    u s  &    ސWVS>t& C    {uSd    	C[^_Ít& d        sd        t
@d    u뢍&      8 룍&    &    VSÉЋS   ΅tr>t& StPtC    "     [^Ít& d        sd        t
@d    u뚍&    SL`9K{P@n1[^Í&    t& WV1SÃd    D$Ct%   ǉ$ƉD$d+    u	[^_VSd    D$19pt8¹   Ƌ$D$d+    u[^Í&    ft& WVSd    D$1d       t
G t\t& ';xt8¹   "$Ɖx"D$d+    u![^_Ít& $묍t& &    &    UWVƉSӍT`|$
tYSFS? 	ЉC>t& ;~xR[^_]Ít& Kd        sd        tjPډXd    u믍    ~FF >t& [^_]Ív Cu~ tF[^_]&    WVSd    >t& >t& d    %9t6=       &    v d    ʉȁ   	d    9u[^_Ít& d        sd        t
@d    pf&    d        Wd        t
@d    0&t&    PSWh@ *&    v UWVS4d    D$0    ;F           E9   u`E}1҉t$L$l$<$1v Ë4$?s t$i4tK    u@@  ul$EuQ} O  EEE&        9RD$0d+    !  4[^_]ÉE|$tEE&    xu,   f$E    tX]>t& StPSC C    "  $u$7E    uEl$bt& d        sd        t
@d    aW} fS@a          ;Sxj          ;Sx	[v [Í&    &    WV4RMbS0i  )      ))9[^H_Í&    fWVSRMb4i      )     Fډ)9[H^_Í    WVSd    @Mb4i      )     Fډ)9[H^_WVSd    4@Mb1i  )      ))9[^H_Ív UW<RMbVS    4i      )     F)9[H^_]Í&    v WV5    SRMb<i  )  =    9y))Љ[^_WVSd    5    @Mb1<i  )  =    9y))Љ[^_Í&    fWVSÃd    D$C   K   @a  4    Ctj  Ɖ9t K   C%  	C    V)х~N9xD9xXNʋCL$t$ډT$XD$d+    u#[^_ÉF뾍&    f    &    &    UWVSÃ$$d    D$ 1C    C  D$   C+$~  σ|$tk  T$ǡ    W)х~O9  9   OC  l$t$;Cd  GL$D$$D$C95  t& 1ɉD$u   k     @a           Ɖ9tV9_a  K   C%  FC    V)х~N91  9  N$|$CVt
;T$L  $L$t$ډqXT$D$ d+      D$$[^_]Í&    T$ǡ    W)х   O9xX9x4OD$D$    t& j  4    fD$D$    y&    fGD$D$    X&    D$D$    ;v     F&    ¸@a     4    Mj  C&    t$L$ډ/Z&    f$CD$   v GcS&    fGL$D$$;D$C9wL$t$;CxD$   8&    &    ft&    A14t&    !PuP   &    &    &    St d    &    fC   u[Í&    &    Sd    u 7&    uC   t   t[&    f1[&                 WVSø t$t$_ZÅuu [^_Í&    f        t
    u [^_f밍&    fUWVS@a  $L$        C  {   CS)9      4$|$C 9sW4$|$9ƉsH?B  1ƉхtCЉi@B )@B i@B ׉ύe[^_]Í    s{ ug+$T$Ѿ¿@B 9и    GC>v x9$Ct& 	C)@B 4$|$Ɖ랍    e[^_]Í&    v S@a      D [fV@a  Sá    d    1d    1Љd    4        ;Fy    ;	  x
   d       u[^    [^&    @a          B?B1fB    j      P?P1fP1UWVSD$d    D$1=    D$@a    D$|$4       t$<        O)ȅ~G9G  9,  GD$H+  D$p``	  $&    otT&    >t& StPC"  L$%  	CCWqt$ډZu94$uD$   d       D$	  D$=@t  D$d+    uz1[^_]Ít& d        Dd        t
@d    D$HWbffffUWVSӃEM]1҃} и    MUME$9$LL9}
ډ[^_]Í&    t& S&    v H Qtt& Qux$ u9AtY9uԋP 9u1[ø   [fUWVSET$D$ED$tjɍˍD8tVx9|$t}WO+TXL\Љ;D$L$}D$D$T$t>t   !ÍD8ut$|$11҉9MM׃[^_]À& t*~4뷍t& D$$$j뗍t& ~(덍&    t& U   ]fU   ]fU1]t& UWVSӉكߋUE IHˉ4$։L$	t61ɉ	u|$4$1 EE4$|$T$1$ƅt1ǉy؃ ڍe[^_]Í&    v W|$wUWVSÉЉʃ4MċsE}Ћ{)u}E؉U܅   C$       1ҋ}Љ9uMȉЋULǋ}9ΉMEME   sKE   E    ủM؉u܋u};u}}L}uMu9}
u}CE؉SUEE9ΉUUMMΉƋE9ȉ}EEEUCSEЋUԍe[^_]g_E    E    E    E    ̍    E؋UuuY^׉ƉыEUuȉ}ԉeƋE׋Us{Eu؉su}܉}9Ɖ{}ĉU׉CSOEU t& UՉWVSÉЃ{ك)    (D$1C$        <    d    u=  t1D$C&C'D8C [^_]Ív ~ÉL$Uh@ XZL$븍&    v P(@(    t1Ív UWVSø    T$D$k SK    +u }$D$4$|$   $T$119ЋT$ȋ$LM{& E u\D$D$9E t[^_]Í&    ;p H$}HuމX(p P$tЃu˃   [^_]&    @u;p,x0};p x$X4p,P0}|$ tuF&    fVS>t& K   	BCF$[^Ít& d        sd        t
@d    u럍&    &    UWVSËH@t*@(    1hjǉXZe[^_]@4       1hjuKC(    C,ǉ։؉S01hjN9}C4C(e[^_]Éǉ돍&    t& VS@tK$s 11	tKC S$tt
[^Í&    [   ^t& UWVS@$:l$K$u[^_]Í&    ֍BuN!Gt9_(u[^   _]RfU1WVSÃu[^_]Ít& t& s  tǋC 9uս;Xt1C$u [^_]Í&    >t& .    $$    19Չ   1PC Z멍t& d        sd        t
@d    u댍&    SÉx[Ív t& UWVS(T$D$@L$d    T$$1#GP  ȉD$l86  ]T$4    $D$DXT\t$D$T$   L7LL$9    E$E9\H  $DH    ]  D$T$ ;CC  >t& $\HED$EC$q8L$C$ t"D$uL$   I<!FT$<s>t& >t& ?C$51ɉ%t& d        Sd        t
@d    ,"t& d        wd        t
@d    PFt& d        !d        t@L$d    &    T$t(   !l8T$    D$$d+    u([^_]Ív &    t& UWVS        ؍         WƍC      щ؉      $     H     L     p  t  h   VcK1C4    h   jЃ	tC4   i[^_]&    t& VS        Cu       ؍         VC            $     H     L     p  t  XCt1<KC S$t"u   [^t& [^f[^Í&        WVS>t& [^__&    d        sd        t@QщXd    u뮍&    t& WVS>t& ؉C d    C([^_Í    d        sd        t@QщXd    u랍&    t& UWVSÃK  tN$$D$;K u/s{A)ƋC ׋T$ [^_]Ív 룍v UWVS($D$<T$T$@D$D$DT$$D$L$& 8  s    ;s   >t$    D$$$T$.T$    9{$9](!T$     \$t$119ډMMD$   \$t$9MM$\$t$X\$pt$9؉}
4$|$ FV   t$L$$   $T$$@  ([^_]t& D$@L$֋T$É9T$ȉL$MM9}0D$D$&    D$119l$M|$Ml$9LL&    D$l$    HL$L$<    |$x    t$$D$D$ 8D$rC ;X   C  D$ L A8$9l$y  $|$CSI8+DXT\;A A$S  s l$D$D$9u9l$t*D$SL C+AXQ\I8;A A$|Ǎ&    ft$$L$T$$%$   &    &    >t&     T$ ʋT$     9T$!PD$T$X&    |$&    d        s$d        t@$d    tGD$(gfC&    l$$k     L$<    벍&    &    SHX+HRXPSQH[Í&    t& UWVS     D$d    D$1d    @u5      D$    ؉D$&    v     ;    N  \$    ؍   s      D$CW            $     H     L     p  t  Y;s   S   t$#s      !4t8t~{ T$ډ<${$|$^4ʋK[+NX^\;$|$   ~@~|$ u;J,z0   t#   !؍t8u&    fӋT$       j1ɺ D$   Zd    t1D$d+    u! [^_]Í&    l$&    v        @         1t& UWVS        ECt'Ue[^_]Í&    uDKC4    1҉hj   s4Y_s(KR1PƉXZ랍v 1fUWVS        KEt\t-KRP؃\ƉXZUe[^_]ËKhj   'Y_붍v 뾍t& UWVS         C7  C؍   FF      ōC|$T$L$D$WD$Ɖ׋   T$          $     H     L     p  t  X$   CC C$;s,K0S|
C,C   C0jUcC Ɖ׉؉S$1ɉZY  t$L$T$ŋD$fCƉ׋            $     H     L     p  t  X,$fC؀K+D$T$$T$;CvC$ \$9ȸ    ؉|0$T$   =    d   [^_]Í&    v   ͍    c [^_]Ít& &    &    UWV    S    Ct[^_]Í&    f$     ؍         WƍCŋ   ׋   ;k,      $     H     L     p  C0t  Y|K   C,C0j؉VaXZ[^_]f4      N       1[^_]&    fЋQtu,QuÍ&    Qt&    t& UWVS˃@T$$d    D$<1d    PHh  l  r  xHch  |$l$>t& t$T$Tىj$L$d    D$8ǉT$$͉<$1l$ՉL$(19͋l$D$, MMT$9Ћ$LLT$9}$D$$T$D$T$ Y  =u:   L$0\$ d    IP  ǂ<  0[  @  L$L  T$<d+       @[^_]Í    d        d        t$t@SL$XXd    f늍&    fD$    11D$    fWVSXd    T$1ҋ   T$4$xZL$ɚ;wNd=    1ۉH  D  }%9   |< ʚ;i ʚ;1j   ZT$d+    u$[^_Í    ͍t& t&     S    Q8x  t& 
(B    B    B    9uA1aA    A(    A4    A A$A,A0[Í          UWVSÃ   <        |$4    t$8x  D$_t$G+t$D$   <$Nt& >t& C$} C$tD$uM   !Gs 1ɉ$XtVC 9Xut& d        sd        t
@d    wm&    ǃ((9|$)|$Gu9OG4    1҉$   hjY[	t
G41	D$    D$    Dt        tt/    1[^_]Í&    fffffffUWVSt& @ ȉL$k4h l D L H $P L$T D T$L$+D$T$!!|$|$ЉƸ    !!	ǋsDEЋCt$|${ [|$=@ L$9GƋD$D$T$1 EE$T$e[^_]Í&    &    UWVS<   $T$5@u    u#_@u 9u$T$ڍe[^_]fˍ&    t& UWV@u u#5u =u @u 9u߉^_]Ít& ΍t& UWVS@u uB\u du `u =u -u  >EnF@u 9u[^_]Ít& 믍t&     Su1@u uXu \u @u 9u[Ít& Ӎt& ˍ&    t& UWVS5       u~@u umlu 3{hu L$\u 4$5`u |$=du T$@u 9uD$T$$T$1 EEe[^_]Í    농t& {&    fU    uu 1]Í    u 1]Ít&     Du ut1Í&        VSø    ډƸ0t Du    ø0t     [^Í&    VSø    ډƸ0t ø    [^Í&    t& UWVSӃ$D$4L$D$ǋWd    D$1Qt$4t$4։ǃ   $Dº@   )   D9      $D@   L$)D$D$   DŃ9   ,$ى4$<$,$Ɖl$$t$0t$0L$QX1ZT$d+    u`[^_]ÐDº@   !)#D!t& D$DŃ!QD!ft& UWVSÃst{xd    D$1C|ރ ؙRPD$D$|$}%t$   9º          ʚ;i ʚ;111	   D$$t$$|$(CtD$(ރ CxD$,߉C|ؙRPD$D$L$t$Z}%9º   _|    ʚ;i ʚ;1׸ ʚ;               D$d+    u?[^_]Ív 11	>f5&    f&    &    UWVS@u    -\u `u du 5u l$-u L$=u \$u ,$u -@u 9uL$,$߉t$\$t$|$ E݉SUT$L$ [^_]Í&    U&    fSӍBSQPQPQPQPQPQPQPQ P Q$P$Q(P(Q,P,Q0P0KK8HK<HK@HKDHKHHKLHKPHKTH KXH$K\H(K`H,Kd@0Ch[USÃ u d    D$u +u u щ$D$CD$CD$d+    u]&    fU    t8t <t ]fd    ]t& UWVSÃDu u Du SD$CLu Hu Du xu Pu Tu s{u @B 5|u 1=u u K1 EEƋsǉ$T$11t1ǉȹ   l$19ȉCCv ȉ5v {cv <$v )ǉՉ=v -v scl$v  v tZK`u du 5u =u +M   1 EE`u 1 EEdu 5u =u CT$    1,v     \u u $0v     +K 4v EEƉ(v $v C8v     Xu u <v     [^_]Í&    f1 EE`u 1 EEdu 5u =u ?fUWVS&     ȉL$k4     $ L$  T$L$+D$T$!!|$|$ЉƸ    !!	ǋsDEЋCt$|${ [|$= L$9GƋD$D$T$1 EE$T$e[^_]Í&    UWVSt&  ȉL$k4     $ L$  T$L$+D$T$!!|$|$ЉƸ    !!	ǋsDEЋCt$|${ [|$= L$9GƋD$D$T$1 EE$T$e[^_]Í&    &    Uu ]u Í&    v UWVSÃ/  щǉ   ׉   	t+            CtChǋSx ʚ;Sli ʚ;T$1L$K$C|$T$C$CS(S  tC|=ɚ;vi    ʚ; ʚ;{p   ʉCX؉S\1҃¸0t    C$   S(C,؉S0 #C4@ t   t@t Du ?   [^_]Ít& ǀ       ǀ       &    v UWVSDu =Lu 5Hu +Pu Tu !Pu !Tu ,$$Չu 1u !!	5Xu EE݉%Xu `u du Ɖף`u u du %u \u u u 1ۉD$T$u  ʚ;u 1 EE9ƉrMu Ӌu  v )Ή$߃T$ 9s$T$5`u =du u u u  ʚ;11ۋt$|$ EEÉ9rVu u  &    v )Ɖ$׃\$ 9sl$<$5u u =u -u [^_]Í&    &    UWVSË@xƄtSHtuu    @u 1uE   Du V    @u tWLtGx[1^_]f؋=Du 묐Cx1|UWVSL=    4  @u $  Du ơDu ׉|$@<t$Eu E u Eu lu hu L$u T$u D$u L$(+Pu Hu T$$Tu \$ !ϋLu !ʹ    ҉!    !	Љ؋`u DDϋ=Xu D$@L$Ddu |$0T$4=\u D$T$L$8|$<=|u +u u !ǡ|u 5u =u !׋u T$T$!ȉt$!	u EEu \$u \$,@u 9$t$0D$$T$|$@L$HL$DE U|$΋t$L$<D$4T$8t$|$  t1Ɖ؉u4$׉}Ɖd$HL$,D$T$1 EED$$T$(EUL[^_]Ð&    f&    fUWVS   D$($   T$,L$4D$d    $   1D$l    @u D$  L$,D$$   t$(D$$^  $   9Du   $   $   Du $L$L$5Pu ŉЋ$=Tu ˉl$99l$ ˈ\$W  $\$l$9CC9r u 4$|$D$lu D$D$su u hu lu L$@u \$Du L$H$   \$L$   )D$8Hu T$<Lu !ƿ    -du !Љl$`!!	\u DEߋ=Xu $   +5u T$dD$h|u |$X=`u u |$\$   =u !l$|$!5u !!t$P	ȋu Dǋ=u E|$T=u D$@u 9D$L$ht$8|$(|$XT$׉|$<L$dD$\T$`t$@|$D1 L$(EEӋ\$ƋD$׉s{|$Ld$D$PT$T1 EE֋t$H׀|$ t$|$s{  t$4-  >n$   $   |$9ǉl$  <$l$9  t$4\$s8^   <$l$)+|$l$L$~\$ l$\$|$($M  L$\$ 	;  |$4$t$,9Ήމ|$0s+D$T$ӋD$4|$ڋt$+pxD$tt$t|$xPt$t$L$\$
D$0   \$l9\$(L$\$e  5Xu D$t$D$xƋ$1ҋ-u 1ƅt1ǉ1։ǉȉ   ȉ$   ډD$|t$|$,l$0D$t9T$xt$    t$4|$FVWGN^O_&    v $   d+       D$$Ĕ   [^_]Ít& ><$l$9|$l$CC9D$$띍t& D$     t$)FV)N^sv 1v D$$Sv D$t$4P@+FVD$|D$|$   Pt$t$KuL$|$   D$$    UWVSÃ,d    D$(1C  {ɚ;  t]9Ѻ   {      @u $S+u u \u ǉա`u du  tЋK)șRQD$$D$,|$$u l$(D$u 9:  9ǉ   u +L$   )L$L$щt$t$D$$D$$T$(L$,D$T$L$ QRPDu pS\u u u C1ۙ EEÃ1`u du    Du 7$    @u    t%D$(d+    uj,[^_]Í    ܐ	uT$td      t u|$|$l$ T$ |$$똋u +L$&    fUWVS@u    u u D$xu T$+u u Ɖס|u u !!5|u =u |$L$׉ѿ    !!	u 5u EE׋=u L$u t$|$=@u 9Nt$D$T$1 EED$T$e[^_]Í&    
&    fUWVS      @u    hu lu D$Du T$+Pu Tu ƉסHu Lu !!5Hu =Lu |$L$׉ѿ    !!	Xu 5`u EE׋=du L$\u t$|$=@u 9Nt$D$T$1 EED$T$e[^_]Í&    v &    f&    fUWVS        D$  @u    hu lu L$D$Du T$IT$L$+Pu Tu #=Lu Hu 5Hu =Lu !ȉ|$L$׉ѿ    !!	Xu 5`u EE׋=du $\u t$|$=@u 9=4$މ׉ƋT$D$t$|$D$T$1 EEe[^_]Í&    &    fUWVSD$@u ؃$   u u |$Wxu =u 5|u +u u Չ!!ҿ    ֋u !!	T$u EE5u =u @u 9`,$L$1 ɚ;EEӉ9sLɚ;1ɍt&  6eĉσ9r1ۋt$F^[^_]Ít& &    f11э&    v UWVS=    D$2  @u ؃$   u u |$WDu =Lu 5Hu +Pu Tu Չ!!ҿ    ֋\u !!	T$Xu EE5`u =du @u 9`,$L$1 ɚ;EEӉ9sNɚ;1ɍ&     6eĉσ9r1ۋt$F^[^_]Ít& &    f11э&    v &    fUWVS=    $  @u ݃b  u u <$WDu Hu =Lu +Pu Tu !!Lu Hu ƉЉ!5u !	и    du EEXu T$\u D$`u T$u D$u T$D$@u 9;<$D$L$\$L$_\$؉L$L$d$D$T$1 EEƸɚ;9s,ɚ;1&     6eĉ9r1l$T$$D$T$Ss[^_]Í&    &    fv&    fUWVSÃ8d    D$41{ɚ;	      @u \u du `u 3{5u =u  tCRPD$0D$0u |$8D$D$4T$SD$u D$Y^L$9$|%;$t$  u +K  ɚ;6  t];L$   L$  u u u \u D$u CT$Ɖ1 EE ʚ;5`u =du 1҉5`u =du  t19ƉL$D$T$r_D$T$l$\$L$\$ )ΉD$߃T$ 9sD$T$5`u l$\$=du u u u  ʚ;1ҋ5u =u  t1T$9ƉL$D$rgu u l$\$\$ ЉʋL$)ΉD$߃T$ 9sD$T$5u l$\$=u u u $T$+u S+K1SQщD$0D$0T$4L$8D$$T$(L$,QRPDu t&    Du     @u    D$4d+    u&8[^_]Ít& 뱍&    ft& UWVSÃTd    D$P    D$(       Lt Pt =Ht 5Dt $@t T$+$T$Ѓ!!D$l$L$|$!!	u8;=v v i  l$J  D؃!d&    v v t/t+1ۋT$(    D$Pd+    	  T[^_]D$    1D$    Dڃu  u   D)ø    HЅ  if
}

DEFINE_STATIC_KEY_FALSE(sched_numa_balancing);

#ifdef CONFIG_NUMA_BALANCING

int sysctl_numa_balancing_mode;

static void __set_numabalancing_state(bool enabled)
{
	if (enabled)
		static_branch_enable(&sched_numa_balancing);
	else
		static_branch_disable(&sched_numa_balancing);
}

void set_numabalancing_state(bool enabled)
{
	if (enabled)
		sysctl_numa_balancing_mode = NUMA_BALANCING_NORMAL;
	else
		sysctl_numa_balancing_mode = NUMA_BALANCING_DISABLED;
	__set_numabalancing_state(enabled);
}

#ifdef CONFIG_PROC_SYSCTL
int sysctl_numa_balancing(struct ctl_table *table, int write,
			  void *buffer, size_t *lenp, loff_t *ppos)
{
	struct ctl_table t;
	int err;
	int state = sysctl_numa_balancing_mode;

	if (write && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	t = *table;
	t.data = &state;
	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);
	if (err < 0)
		return err;
	if (write) {
		sysctl_numa_balancing_mode = state;
		__set_numabalancing_state(state);
	}
	return err;
}
#endif
#endif

#ifdef CONFIG_SCHEDSTATS

DEFINE_STATIC_KEY_FALSE(sched_schedstats);

static void set_schedstats(bool enabled)
{
	if (enabled)
		static_branch_enable(&sched_schedstats);
	else
		static_branch_disable(&sched_schedstats);
}

void force_schedstat_enabled(void)
{
	if (!schedstat_enabled()) {
		pr_info("kernel profiling enabled schedstats, disable via kernel.sched_schedstats.\n");
		static_branch_enable(&sched_schedstats);
	}
}

static int __init setup_schedstats(char *str)
{
	int ret = 0;
	if (!str)
		goto out;

	if (!strcmp(str, "enable")) {
		set_schedstats(true);
		ret = 1;
	} else if (!strcmp(str, "disable")) {
		set_schedstats(false);
		ret = 1;
	}
out:
	if (!ret)
		pr_warn("Unable to parse schedstats=\n");

	return ret;
}
__setup("schedstats=", setup_schedstats);

#ifdef CONFIG_PROC_SYSCTL
int sysctl_schedstats(struct ctl_table *table, int write, void *buffer,
		size_t *lenp, loff_t *ppos)
{
	struct ctl_table t;
	int err;
	int state = static_branch_likely(&sched_schedstats);

	if (write && !capable(CAP_SYS_ADMIN))
		return -EPERM;

	t = *table;
	t.data = &state;
	err = proc_dointvec_minmax(&t, write, buffer, lenp, ppos);
	if (err < 0)
		return err;
	if (write)
		set_schedstats(state);
	return err;
}
#endif /* CONFIG_PROC_SYSCTL */
#endif /* CONFIG_SCHEDSTATS */

/*
 * fork()/clone()-time setup:
 */
int sched_fork(unsigned long clone_flags, struct task_struct *p)
{
	__sched_fork(clone_flags, p);
	/*
	 * We mark the process as NEW here. This guarantees that
	 * nobody will actually run it, and a signal or other external
	 * event cannot wake it up and insert it on the runqueue either.
	 */
	p->__state = TASK_NEW;

	/*
	 * Make sure we do not leak PI boosting priority to the child.
	 */
	p->prio = current->normal_prio;

	uclamp_fork(p);

	/*
	 * Revert to default priority/policy on fork if requested.
	 */
	if (unlikely(p->sched_reset_on_fork)) {
		if (task_has_dl_policy(p) || task_has_rt_policy(p)) {
			p->policy = SCHED_NORMAL;
			p->static_prio = NICE_TO_PRIO(0);
			p->rt_priority = 0;
		} else if (PRIO_TO_NICE(p->static_prio) < 0)
			p->static_prio = NICE_TO_PRIO(0);

		p->prio = p->normal_prio = p->static_prio;
		set_load_weight(p, false);

		/*
		 * We don't need the reset flag anymore after the fork. It has
		 * fulfilled its duty:
		 */
		p->sched_reset_on_fork = 0;
	}

	if (dl_prio(p->prio))
		return -EAGAIN;
	else if (rt_prio(p->prio))
		p->sched_class = &rt_sched_class;
	else
		p->sched_class = &fair_sched_class;

	init_entity_runnable_average(&p->se);


#ifdef CONFIG_SCHED_INFO
	if (likely(sched_info_on()))
		memset(&p->sched_info, 0, sizeof(p->sched_info));
#endif
#if defined(CONFIG_SMP)
	p->on_cpu = 0;
#endif
	init_task_preempt_count(p);
#ifdef CONFIG_SMP
	plist_node_init(&p->pushable_tasks, MAX_PRIO);
	RB_CLEAR_NODE(&p->pushable_dl_tasks);
#endif
	return 0;
}

void sched_cgroup_fork(struct task_struct *p, struct kernel_clone_args *kargs)
{
	unsigned long flags;

	/*
	 * Because we're not yet on the pid-hash, p->pi_lock isn't strictly
	 * required yet, but lockdep gets upset if rules are violated.
	 */
	raw_spin_lock_irqsave(&p->pi_lock, flags);
#ifdef CONFIG_CGROUP_SCHED
	if (1) {
		struct task_group *tg;
		tg = container_of(kargs->cset->subsys[cpu_cgrp_id],
				  struct task_group, css);
		tg = autogroup_task_group(p, tg);
		p->sched_task_group = tg;
	}
#endif
	rseq_migrate(p);
	/*
	 * We're setting the CPU for the first time, we don't migrate,
	 * so use __set_task_cpu().
	 */
	__set_task_cpu(p, smp_processor_id());
	if (p->sched_class->task_fork)
		p->sched_class->task_fork(p);
	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
}

void sched_post_fork(struct task_struct *p)
{
	uclamp_post_fork(p);
}

unsigned long to_ratio(u64 period, u64 runtime)
{
	if (runtime == RUNTIME_INF)
		return BW_UNIT;

	/*
	 * Doing this here saves a lot of checks in all
	 * the calling paths, and returning zero seems
	 * safe for them anyway.
	 */
	if (period == 0)
		return 0;

	return div64_u64(runtime << BW_SHIFT, period);
}

/*
 * wake_up_new_task - wake up a newly created task for the first time.
 *
 * This function will do some initial scheduler statistics housekeeping
 * that must be done for every newly created context, then puts the task
 * on the runqueue and wakes it.
 */
void wake_up_new_task(struct task_struct *p)
{
	struct rq_flags rf;
	struct rq *rq;

	raw_spin_lock_irqsave(&p->pi_lock, rf.flags);
	WRITE_ONCE(p->__state, TASK_RUNNING);
#ifdef CONFIG_SMP
	/*
	 * Fork balancing, do it here and not earlier because:
	 *  - cpus_ptr can change in the fork path
	 *  - any previously selected CPU might disappear through hotplug
	 *
	 * Use __set_task_cpu() to avoid calling sched_class::migrate_task_rq,
	 * as we're not fully set-up yet.
	 */
	p->recent_used_cpu = task_cpu(p);
	rseq_migrate(p);
	__set_task_cpu(p, select_task_rq(p, task_cpu(p), WF_FORK));
#endif
	rq = __task_rq_lock(p, &rf);
	update_rq_clock(rq);
	post_init_entity_util_avg(p);

	activate_task(rq, p, ENQUEUE_NOCLOCK);
	trace_sched_wakeup_new(p);
	check_preempt_curr(rq, p, WF_FORK);
#ifdef CONFIG_SMP
	if (p->sched_class->task_woken) {
		/*
		 * Nothing relies on rq->lock after this, so it's fine to
		 * drop it.
		 */
		rq_unpin_lock(rq, &rf);
		p->sched_class->task_woken(rq, p);
		rq_repin_lock(rq, &rf);
	}
#endif
	task_rq_unlock(rq, p, &rf);
}

#ifdef CONFIG_PREEMPT_NOTIFIERS

static DEFINE_STATIC_KEY_FALSE(preempt_notifier_key);

void preempt_notifier_inc(void)
{
	static_branch_inc(&preempt_notifier_key);
}
EXPORT_SYMBOL_GPL(preempt_notifier_inc);

void preempt_notifier_dec(void)
{
	static_branch_dec(&preempt_notifier_key);
}
EXPORT_SYMBOL_GPL(preempt_notifier_dec);

/**
 * preempt_notifier_register - tell me when current is being preempted & rescheduled
 * @notifier: notifier struct to register
 */
void preempt_notifier_register(struct preempt_notifier *notifier)
{
	if (!static_branch_unlikely(&preempt_notifier_key))
		WARN(1, "registering preempt_notifier while notifiers disabled\n");

	hlist_add_head(&notifier->link, &current->preempt_notifiers);
}
EXPORT_SYMBOL_GPL(preempt_notifier_register);

/**
 * preempt_notifier_unregister - no longer interested in preemption notifications
 * @notifier: notifier struct to unregister
 *
 * This is *not* safe to call from within a preemption notifier.
 */
void preempt_notifier_unregister(struct preempt_notifier *notifier)
{
	hlist_del(&notifier->link);
}
EXPORT_SYMBOL_GPL(preempt_notifier_unregister);

static void __fire_sched_in_preempt_notifiers(struct task_struct *curr)
{
	struct preempt_notifier *notifier;

	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link)
		notifier->ops->sched_in(notifier, raw_smp_processor_id());
}

static __always_inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)
{
	if (static_branch_unlikely(&preempt_notifier_key))
		__fire_sched_in_preempt_notifiers(curr);
}

static void
__fire_sched_out_preempt_notifiers(struct task_struct *curr,
				   struct task_struct *next)
{
	struct preempt_notifier *notifier;

	hlist_for_each_entry(notifier, &curr->preempt_notifiers, link)
		notifier->ops->sched_out(notifier, next);
}

static __always_inline void
fire_sched_out_preempt_notifiers(struct task_struct *curr,
				 struct task_struct *next)
{
	if (static_branch_unlikely(&preempt_notifier_key))
		__fire_sched_out_preempt_notifiers(curr, next);
}

#else /* !CONFIG_PREEMPT_NOTIFIERS */

static inline void fire_sched_in_preempt_notifiers(struct task_struct *curr)
{
}

static inline void
fire_sched_out_preempt_notifiers(struct task_struct *curr,
				 struct task_struct *next)
{
}

#endif /* CONFIG_PREEMPT_NOTIFIERS */

static inline void prepare_task(struct task_struct *next)
{
#ifdef CONFIG_SMP
	/*
	 * Claim the task as running, we do this before switching to it
	 * such that any running task will have this set.
	 *
	 * See the ttwu() WF_ON_CPU case and its ordering comment.
	 */
	WRITE_ONCE(next->on_cpu, 1);
#endif
}

static inline void finish_task(struct task_struct *prev)
{
#ifdef CONFIG_SMP
	/*
	 * This must be the very last reference to @prev from this CPU. After
	 * p->on_cpu is cleared, the task can be moved to a different CPU. We
	 * must ensure this doesn't happen until the switch is completely
	 * finished.
	 *
	 * In particular, the load of prev->state in finish_task_switch() must
	 * happen before this.
	 *
	 * Pairs with the smp_cond_load_acquire() in try_to_wake_up().
	 */
	smp_store_release(&prev->on_cpu, 0);
#endif
}

#ifdef CONFIG_SMP

static void do_balance_callbacks(struct rq *rq, struct callback_head *head)
{
	void (*func)(struct rq *rq);
	struct callback_head *next;

	lockdep_assert_rq_held(rq);

	while (head) {
		func = (void (*)(struct rq *))head->func;
		next = head->next;
		head->next = NULL;
		head = next;

		func(rq);
	}
}

static void balance_push(struct rq *rq);

struct callback_head balance_push_callback = {
	.next = NULL,
	.func = (void (*)(struct callback_head *))balance_push,
};

static inline struct callback_head *splice_balance_callbacks(struct rq *rq)
{
	struct callback_head *head = rq->balance_callback;

	lockdep_assert_rq_held(rq);
	if (head)
		rq->balance_callback = NULL;

	return head;
}

static void __balance_callbacks(struct rq *rq)
{
	do_balance_callbacks(rq, splice_balance_callbacks(rq));
}

static inline void balance_callbacks(struct rq *rq, struct callback_head *head)
{
	unsigned long flags;

	if (unlikely(head)) {
		raw_spin_rq_lock_irqsave(rq, flags);
		do_balance_callbacks(rq, head);
		raw_spin_rq_unlock_irqrestore(rq, flags);
	}
}

#else

static inline void __balance_callbacks(struct rq *rq)
{
}

static inline struct callback_head *splice_balance_callbacks(struct rq *rq)
{
	return NULL;
}

static inline void balance_callbacks(struct rq *rq, struct callback_head *head)
{
}

#endif

static inline void
prepare_lock_switch(struct rq *rq, struct task_struct *next, struct rq_flags *rf)
{
	/*
	 * Since the runqueue lock will be released by the next
	 * task (which is an invalid locking op but in the case
	 * of the scheduler it's an obvious special-case), so we
	 * do an early lockdep release here:
	 */
	rq_unpin_lock(rq, rf);
	spin_release(&__rq_lockp(rq)->dep_map, _THIS_IP_);
#ifdef CONFIG_DEBUG_SPINLOCK
	/* this is a valid case when another task releases the spinlock */
	rq_lockp(rq)->owner = next;
#endif
}

static inline void finish_lock_switch(struct rq *rq)
{
	/*
	 * If we are tracking spinlock dependencies then we have to
	 * fix up the runqueue lock - which gets 'carried over' from
	 * prev into current:
	 */
	spin_acquire(&__rq_lockp(rq)->dep_map, 0, 0, _THIS_IP_);
	__balance_callbacks(rq);
	raw_spin_rq_unlock_irq(rq);
}

/*
 * NOP if the arch has not defined these:
 */

#ifndef prepare_arch_switch
# define prepare_arch_switch(next)	do { } while (0)
#endif

#ifndef finish_arch_post_lock_switch
# define finish_arch_post_lock_switch()	do { } while (0)
#endif

static inline void kmap_local_sched_out(void)
{
#ifdef CONFIG_KMAP_LOCAL
	if (unlikely(current->kmap_ctrl.idx))
		__kmap_local_sched_out();
#endif
}

static inline void kmap_local_sched_in(void)
{
#ifdef CONFIG_KMAP_LOCAL
	if (unlikely(current->kmap_ctrl.idx))
		__kmap_local_sched_in();
#endif
}

/**
 * prepare_task_switch - prepare to switch tasks
 * @rq: the runqueue preparing to switch
 * @prev: the current task that is being switched out
 * @next: the task we are going to switch to.
 *
 * This is called with the rq lock held and interrupts off. It must
 * be paired with a subsequent finish_task_switch after the context
 * switch.
 *
 * prepare_task_switch sets up locking and calls architecture specific
 * hooks.
 */
static inline void
prepare_task_switch(struct rq *rq, struct task_struct *prev,
		    struct task_struct *next)
{
	kcov_prepare_switch(prev);
	sched_info_switch(rq, prev, next);
	perf_event_task_sched_out(prev, next);
	rseq_preempt(prev);
	fire_sched_out_preempt_notifiers(prev, next);
	kmap_local_sched_out();
	prepare_task(next);
	prepare_arch_switch(next);
}

/**
 * finish_task_switch - clean up after a task-switch
 * @prev: the thread we just switched away from.
 *
 * finish_task_switch must be called after the context switch, paired
 * with a prepare_task_switch call before the context switch.
 * finish_task_switch will reconcile locking set up by prepare_task_switch,
 * and do any other architecture-specific cleanup actions.
 *
 * Note that we may have delayed dropping an mm in context_switch(). If
 * so, we finish that here outside of the runqueue lock. (Doing it
 * with the lock held can cause deadlocks; see schedule() for
 * details.)
 *
 * The context switch have flipped the stack from under us and restored the
 * local variables which were saved when this task called schedule() in the
 * past. prev == current is still correct but we need to recalculate this_rq
 * because prev may have moved to another CPU.
 */
static struct rq *finish_task_switch(struct task_struct *prev)
	__releases(rq->lock)
{
	struct rq *rq = this_rq();
	struct mm_struct *mm = rq->prev_mm;
	unsigned int prev_state;

	/*
	 * The previous task will have left us with a preempt_count of 2
	 * because it left us after:
	 *
	 *	schedule()
	 *	  preempt_disable();			// 1
	 *	  __schedule()
	 *	    raw_spin_lock_irq(&rq->lock)	// 2
	 *
	 * Also, see FORK_PREEMPT_COUNT.
	 */
	if (WARN_ONCE(preempt_count() != 2*PREEMPT_DISABLE_OFFSET,
		      "corrupted preempt_count: %s/%d/0x%x\n",
		      current->comm, current->pid, preempt_count()))
		preempt_count_set(FORK_PREEMPT_COUNT);

	rq->prev_mm = NULL;

	/*
	 * A task struct has one reference for the use as "current".
	 * If a task dies, then it sets TASK_DEAD in tsk->state and calls
	 * schedule one last time. The schedule call will never return, and
	 * the scheduled task must drop that reference.
	 *
	 * We must observe prev->state before clearing prev->on_cpu (in
	 * finish_task), otherwise a concurrent wakeup can get prev
	 * running on another CPU and we could rave with its RUNNING -> DEAD
	 * transition, resulting in a double drop.
	 */
	prev_state = READ_ONCE(prev->__state);
	vtime_task_switch(prev);
	perf_event_task_sched_in(prev, current);
	finish_task(prev);
	tick_nohz_task_switch();
	finish_lock_switch(rq);
	finish_arch_post_lock_switch();
	kcov_finish_switch(current);
	/*
	 * kmap_local_sched_out() is invoked with rq::lock held and
	 * interrupts disabled. There is no requirement for that, but the
	 * sched out code does not have an interrupt enabled section.
	 * Restoring the maps on sched in does not require interrupts being
	 * disabled either.
	 */
	kmap_local_sched_in();

	fire_sched_in_preempt_notifiers(current);
	/*
	 * When switching through a kernel thread, the loop in
	 * membarrier_{private,global}_expedited() may have observed that
	 * kernel thread and not issued an IPI. It is therefore possible to
	 * schedule between user->kernel->user threads without passing though
	 * switch_mm(). Membarrier requires a barrier after storing to
	 * rq->curr, before returning to userspace, so provide them here:
	 *
	 * - a full memory barrier for {PRIVATE,GLOBAL}_EXPEDITED, implicitly
	 *   provided by mmdrop(),
	 * - a sync_core for SYNC_CORE.
	 */
	if (mm) {
		membarrier_mm_sync_core_before_usermode(mm);
		mmdrop_sched(mm);
	}
	if (unlikely(prev_state == TASK_DEAD)) {
		if (prev->sched_class->task_dead)
			prev->sched_class->task_dead(prev);

		/* Task is done with its stack. */
		put_task_stack(prev);

		put_task_struct_rcu_user(prev);
	}

	return rq;
}

/**
 * schedule_tail - first thing a freshly forked thread must call.
 * @prev: the thread we just switched away from.
 */
asmlinkage __visible void schedule_tail(struct task_struct *prev)
	__releases(rq->lock)
{
	/*
	 * New tasks start with FORK_PREEMPT_COUNT, see there and
	 * finish_task_switch() for details.
	 *
	 * finish_task_switch() will drop rq->lock() and lower preempt_count
	 * and the preempt_enable() will end up enabling preemption (on
	 * PREEMPT_COUNT kernels).
	 */

	finish_task_switch(prev);
	preempt_enable();

	if (current->set_child_tid)
		put_user(task_pid_vnr(current), current->set_child_tid);

	calculate_sigpending();
}

/*
 * context_switch - switch to the new MM and the new thread's register state.
 */
static __always_inline struct rq *
context_switch(struct rq *rq, struct task_struct *prev,
	       struct task_struct *next, struct rq_flags *rf)
{
	prepare_task_switch(rq, prev, next);

	/*
	 * For paravirt, this is coupled with an exit in switch_to to
	 * combine the page table reload and the switch backend into
	 * one hypercall.
	 */
	arch_start_context_switch(prev);

	/*
	 * kernel -> kernel   lazy + transfer active
	 *   user -> kernel   lazy + mmgrab() active
	 *
	 * kernel ->   user   switch + mmdrop() active
	 *   user ->   user   switch
	 */
	if (!next->mm) {                                // to kernel
		enter_lazy_tlb(prev->active_mm, next);

		next->active_mm = prev->active_mm;
		if (prev->mm)                           // from user
			mmgrab(prev->active_mm);
		else
			prev->active_mm = NULL;
	} else {                                        // to user
		membarrier_switch_mm(rq, prev->active_mm, next->mm);
		/*
		 * sys_membarrier() requires an smp_mb() between setting
		 * rq->curr / membarrier_switch_mm() and returning to userspace.
		 *
		 * The below provides this either through switch_mm(), or in
		 * case 'prev->active_mm == next->mm' through
		 * finish_task_switch()'s mmdrop().
		 */
		switch_mm_irqs_off(prev->active_mm, next->mm, next);

		if (!prev->mm) {                        // from kernel
			/* will mmdrop() in finish_task_switch(). */
			rq->prev_mm = prev->active_mm;
			prev->active_mm = NULL;
		}
	}

	rq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);

	prepare_lock_switch(rq, next, rf);

	/* Here we just switch the register state and the stack. */
	switch_to(prev, next, prev);
	barrier();

	return finish_task_switch(prev);
}

/*
 * nr_running and nr_context_switches:
 *
 * externally visible scheduler statistics: current number of runnable
 * threads, total number of context switches performed since bootup.
 */
unsigned int nr_running(void)
{
	unsigned int i, sum = 0;

	for_each_online_cpu(i)
		sum += cpu_rq(i)->nr_running;

	return sum;
}

/*
 * Check if only the current task is running on the CPU.
 *
 * Caution: this function does not check that the caller has disabled
 * preemption, thus the result might have a time-of-check-to-time-of-use
 * race.  The caller is responsible to use it correctly, for example:
 *
 * - from a non-preemptible section (of course)
 *
 * - from a thread that is bound to a single CPU
 *
 * - in a loop with very short iterations (e.g. a polling loop)
 */
bool single_task_running(void)
{
	return raw_rq()->nr_running == 1;
}
EXPORT_SYMBOL(single_task_running);

unsigned long long nr_context_switches(void)
{
	int i;
	unsigned long long sum = 0;

	for_each_possible_cpu(i)
		sum += cpu_rq(i)->nr_switches;

	return sum;
}

/*
 * Consumers of these two interfaces, like for example the cpuidle menu
 * governor, are using nonsensical data. Preferring shallow idle state selection
 * for a CPU that has IO-wait which might not even end up running the task when
 * it does become runnable.
 */

unsigned int nr_iowait_cpu(int cpu)
{
	return atomic_read(&cpu_rq(cpu)->nr_iowait);
}

/*
 * IO-wait accounting, and how it's mostly bollocks (on SMP).
 *
 * The idea behind IO-wait account is to account the idle time that we could
 * have spend running if it were not for IO. That is, if we were to improve the
 * storage performance, we'd have a proportional reduction in IO-wait time.
 *
 * This all works nicely on UP, where, when a task blocks on IO, we account
 * idle time as IO-wait, because if the storage were faster, it could've been
 * running and we'd not be idle.
 *
 * This has been extended to SMP, by doing the same for each CPU. This however
 * is broken.
 *
 * Imagine for instance the case where two tasks block on one CPU, only the one
 * CPU will have IO-wait accounted, while the other has regular idle. Even
 * though, if the storage were faster, both could've ran at the same time,
 * utilising both CPUs.
 *
 * This means, that when looking globally, the current IO-wait accounting on
 * SMP is a lower bound, by reason of under accounting.
 *
 * Worse, since the numbers are provided per CPU, they are sometimes
 * interpreted per CPU, and that is nonsensical. A blocked task isn't strictly
 * associated with any one particular CPU, it can wake to another CPU than it
 * blocked on. This means the per CPU IO-wait number is meaningless.
 *
 * Task CPU affinities can make all that even more 'interesting'.
 */

unsigned int nr_iowait(void)
{
	unsigned int i, sum = 0;

	for_each_possible_cpu(i)
		sum += nr_iowait_cpu(i);

	return sum;
}

#ifdef CONFIG_SMP

/*
 * sched_exec - execve() is a valuable balancing opportunity, because at
 * this point the task has the smallest effective memory and cache footprint.
 */
void sched_exec(void)
{
	struct task_struct *p = current;
	unsigned long flags;
	int dest_cpu;

	raw_spin_lock_irqsave(&p->pi_lock, flags);
	dest_cpu = p->sched_class->select_task_rq(p, task_cpu(p), WF_EXEC);
	if (dest_cpu == smp_processor_id())
		goto unlock;

	if (likely(cpu_active(dest_cpu))) {
		struct migration_arg arg = { p, dest_cpu };

		raw_spin_unlock_irqrestore(&p->pi_lock, flags);
		stop_one_cpu(task_cpu(p), migration_cpu_stop, &arg);
		return;
	}
unlock:
	raw_spin_unlock_irqrestore(&p->pi_lock, flags);
}

#endif

DEFINE_PER_CPU(struct kernel_stat, kstat);
DEFINE_PER_CPU(struct kernel_cpustat, kernel_cpustat);

EXPORT_PER_CPU_SYMBOL(kstat);
EXPORT_PER_CPU_SYMBOL(kernel_cpustat);

/*
 * The function fair_sched_class.update_curr accesses the struct curr
 * and its field curr->exec_start; when called from task_sched_runtime(),
 * we observe a high rate of cache misses in practice.
 * Prefetching this data results in improved performance.
 */
static inline void prefetch_curr_exec_start(struct task_struct *p)
{
#ifdef CONFIG_FAIR_GROUP_SCHED
	struct sched_entity *curr = (&p->se)->cfs_rq->curr;
#else
	struct sched_entity *curr = (&task_rq(p)->cfs)->curr;
#endif
	prefetch(curr);
	prefetch(&curr->exec_start);
}

/*
 * Return accounted runtime for the task.
 * In case the task is currently running, return the runtime plus current's
 * pending runtime that have not been accounted yet.
 */
unsigned long long task_sched_runtime(struct task_struct *p)
{
	struct rq_flags rf;
	struct rq *rq;
	u64 ns;

#if defined(CONFIG_64BIT) && defined(CONFIG_SMP)
	/*
	 * 64-bit doesn't need locks to atomically read a 64-bit value.
	 * So we have a optimization chance when the task's delta_exec is 0.
	 * Reading ->on_cpu is racy, but this is ok.
	 *
	 * If we race with it leaving CPU, we'll take a lock. So we're correct.
	 * If we race with it entering CPU, unaccounted time is 0. This is
	 * indistinguishable from the read occurring a few cycles earlier.
	 * If we see ->on_cpu without ->on_rq, the task is leaving, and has
	 * been accounted, so we're correct here as well.
	 */
	if (!p->on_cpu || !task_on_rq_queued(p))
		return p->se.sum_exec_runtime;
#endif

	rq = task_rq_lock(p, &rf);
	/*
	 * Must be ->curr _and_ ->on_rq.  If dequeued, we would
	 * project cycles that may never be accounted to this
	 * thread, breaking clock_gettime().
	 */
	if (task_current(rq, p) && task_on_rq_queued(p)) {
		prefetch_curr_exec_start(p);
		update_rq_clock(rq);
		p->sched_class->update_curr(rq);
	}
	ns = p->se.sum_exec_runtime;
	task_rq_unlock(rq, p, &rf);

	return ns;
}

#ifdef CONFIG_SCHED_DEBUG
static u64 cpu_resched_latency(struct rq *rq)
{
	int latency_warn_ms = READ_ONCE(sysctl_resched_latency_warn_ms);
	u64 resched_latency, now = rq_clock(rq);
	static bool warned_once;

	if (sysctl_resched_latency_warn_once && warned_once)
		return 0;

	if (!need_resched() || !latency_warn_ms)
		return 0;

	if (system_state == SYSTEM_BOOTING)
		return 0;

	if (!rq->last_seen_need_resched_ns) {
		rq->last_seen_need_resched_ns = now;
		rq->ticks_without_resched = 0;
		return 0;
	}

	rq->ticks_without_resched++;
	resched_latency = now - rq->last_seen_need_resched_ns;
	if (resched_latency <= latency_warn_ms * NSEC_PER_MSEC)
		return 0;

	warned_once = true;

	return resched_latency;
}

static int __init setup_resched_latency_warn_ms(char *str)
{
	long val;

	if ((kstrtol(str, 0, &val))) {
		pr_warn("Unable to set resched_latency_warn_ms\n");
		return 1;
	}

	sysctl_resched_latency_warn_ms = val;
	return 1;
}
__setup("resched_latency_warn_ms=", setup_resched_latency_warn_ms);
#else
static inline u64 cpu_resched_latency(struct rq *rq) { return 0; }
#endif /* CONFIG_SCHED_DEBUG */

/*
 * This function gets called by the timer code, with HZ frequency.
 * We call it with interrupts disabled.
 */
void scheduler_tick(void)
{
	int cpu = smp_processor_id();
	struct rq *rq = cpu_rq(cpu);
	struct task_struct *curr = rq->curr;
	struct rq_flags rf;
	unsigned long thermal_pressure;
	u64 resched_latency;

	arch_scale_freq_tick();
	sched_clock_tick();

	rq_lock(rq, &rf);

	update_rq_clock(rq);
	thermal_pressure = arch_scale_thermal_pressure(cpu_of(rq));
	update_thermal_load_avg(rq_clock_thermal(rq), rq, thermal_pressure);
	curr->sched_class->task_tick(rq, curr, 0);
	if (sched_feat(LATENCY_WARN))
		resched_latency = cpu_resched_latency(rq);
	calc_global_load_tick(rq);
	sched_core_tick(rq);

	rq_unlock(rq, &rf);

	if (sched_feat(LATENCY_WARN) && resched_latency)
		resched_latency_warn(cpu, resched_latency);

	perf_event_task_tick();

#ifdef CONFIG_SMP
	rq->idle_balance = idle_cpu(cpu);
	trigger_load_balance(rq);
#endif
}

#ifdef CONFIG_NO_HZ_FULL

struct tick_work {
	int			cpu;
	atomic_t		state;
	struct delayed_work	work;
};
/* Values for ->state, see diagram below. */
#define TICK_SCHED_REMOTE_OFFLINE	0
#define TICK_SCHED_REMOTE_OFFLINING	1
#define TICK_SCHED_REMOTE_RUNNING	2

/*
 * State diagram for ->state:
 *
 *
 *          TICK_SCHED_REMOTE_OFFLINE
 *                    |   ^
 *                    |   |
 *                    |   | sched_tick_remote()
 *                    |   |
 *                    |   |
 *                    +--TICK_SCHED_REMOTE_OFFLINING
 *                    |   ^
 *                    |   |
 * sched_tick_start() |   | sched_tick_stop()
 *                    |   |
 *                    V   |
 *          TICK_SCHED_REMOTE_RUNNING
 *
 *
 * Other transitions get WARN_ON_ONCE(), except that sched_tick_remote()
 * and sched_tick_start() are happy to leave the state in RUNNING.
 */

static struct tick_work __percpu *tick_work_cpu;

static void sched_tick_remote(struct work_struct *work)
{
	struct delayed_work *dwork = to_delayed_work(work);
	struct tick_work *twork = container_of(dwork, struct tick_work, work);
	int cpu = twork->cpu;
	struct rq *rq = cpu_rq(cpu);
	struct task_struct *curr;
	struct rq_flags rf;
	u64 delta;
	int os;

	/*
	 * Handle the tick only if it appears the remote CPU is running in full
	 * dynticks mode. The check is racy by nature, but missing a tick or
	 * having one too much is no big deal because the scheduler tick updates
	 * statistics and checks timeslices in a time-independent way, regardless
	 * of when exactly it is running.
	 */
	if (!tick_nohz_tick_stopped_cpu(cpu))
		goto out_requeue;

	rq_lock_irq(rq, &rf);
	curr = rq->curr;
	if (cpu_is_offline(cpu))
		goto out_unlock;

	update_rq_clock(rq);

	if (!is_idle_task(curr)) {
		/*
		 * Make sure the next tick runs within a reasonable
		 * amount of time.
		 */
		delta = rq_clock_task(rq) - curr->se.exec_start;
		WARN_ON_ONCE(delta > (u64)NSEC_PER_SEC * 3);
	}
	curr->sched_class->task_tick(rq, curr, 0);

	calc_load_nohz_remote(rq);
out_unlock:
	rq_unlock_irq(rq, &rf);
out_requeue:

	/*
	 * Run the remote tick once per second (1Hz). This arbitrary
	 * frequency is large enough to avoid overload but short enough
	 * to keep scheduler internal stats reasonably up to date.  But
	 * first update state to reflect hotplug activity if required.
	 */
	os = atomic_fetch_add_unless(&twork->state, -1, TICK_SCHED_REMOTE_RUNNING);
	WARN_ON_ONCE(os == TICK_SCHED_REMOTE_OFFLINE);
	if (os == TICK_SCHED_REMOTE_RUNNING)
		queue_delayed_work(system_unbound_wq, dwork, HZ);
}

static void sched_tick_start(int cpu)
{
	int os;
	struct tick_work *twork;

	if (housekeeping_cpu(cpu, HK_TYPE_TICK))
		return;

	WARN_ON_ONCE(!tick_work_cpu);

	twork = per_cpu_ptr(tick_work_cpu, cpu);
	os = atomic_xchg(&twork->state, TICK_SCHED_REMOTE_RUNNING);
	WARN_ON_ONCE(os == TICK_SCHED_REMOTE_RUNNING);
	if (os == TICK_SCHED_REMOTE_OFFLINE) {
		twork->cpu = cpu;
		INIT_DELAYED_WORK(&twork->work, sched_tick_remote);
		queue_delayed_work(system_unbound_wq, &twork->work, HZ);
	}
}

#ifdef CONFIG_HOTPLUG_CPU
static void sched_tick_stop(int cpu)
{
	struct tick_work *twork;
	int os;

	if (housekeeping_cpu(cpu, HK_TYPE_TICK))
		return;

	WARN_ON_ONCE(!tick_work_cpu);

	twork = per_cpu_ptr(tick_work_cpu, cpu);
	/* There cannot be competing actions, but don't rely on stop-machine. */
	os = atomic_xchg(&twork->state, TICK_SCHED_REMOTE_OFFLINING);
	WARN_ON_ONCE(os != TICK_SCHED_REMOTE_RUNNING);
	/* Don't cancel, as this would mess up the state machine. */
}
#endif /* CONFIG_HOTPLUG_CPU */

int __init sched_tick_offload_init(void)
{
	tick_work_cpu = alloc_percpu(struct tick_work);
	BUG_ON(!tick_work_cpu);
	return 0;
}

#else /* !CONFIG_NO_HZ_FULL */
static inline void sched_tick_start(int cpu) { }
static inline void sched_tick_stop(int cpu) { }
#endif

#if defined(CONFIG_PREEMPTION) && (defined(CONFIG_DEBUG_PREEMPT) || \
				defined(CONFIG_TRACE_PREEMPT_TOGGLE))
/*
 * If the value passed in is equal to the current preempt count
 * then we just disabled preemption. Start timing the latency.
 */
static inline void preempt_latency_start(int val)
{
	if (preempt_count() == val) {
		unsigned long ip = get_lock_parent_ip();
#ifdef CONFIG_DEBUG_PREEMPT
		current->preempt_disable_ip = ip;
#endif
		trace_preempt_off(CALLER_ADDR0, ip);
	}
}

void preempt_count_add(int val)
{
#ifdef CONFIG_DEBUG_PREEMPT
	/*
	 * Underflow?
	 */
	if (DEBUG_LOCKS_WARN_ON((preempt_count() < 0)))
		return;
#endif
	__preempt_count_add(val);
#ifdef CONFIG_DEBUG_PREEMPT
	/*
	 * Spinlock count overflowing soon?
	 */
	DEBUG_LOCKS_WARN_ON((preempt_count() & PREEMPT_MASK) >=
				PREEMPT_MASK - 10);
#endif
	preempt_latency_start(val);
}
EXPORT_SYMBOL(preempt_count_add);
NOKPROBE_SYMBOL(preempt_count_add);

/*
 * If the value passed in equals to the current preempt count
 * then we just enabled preemption. Stop timing the latency.
 */
static inline void preempt_latency_stop(int val)
{
	if (preempt_count() == val)
		trace_preempt_on(CALLER_ADDR0, get_lock_parent_ip());
}

void preempt_count_sub(int val)
{
#ifdef CONFIG_DEBUG_PREEMPT
	/*
	 * Underflow?
	 */
	if (DEBUG_LOCKS_WARN_ON(val > preempt_count()))
		return;
	/*
	 * Is the spinlock portion underflowing?
	 */
	if (DEBUG_LOCKS_WARN_ON((val < PREEMPT_MASK) &&
			!(preempt_count() & PREEMPT_MASK)))
		return;
#endif

	preempt_latency_stop(val);
	__preempt_count_sub(val);
}
EXPORT_SYMBOL(preempt_count_sub);
NOKPROBE_SYMBOL(preempt_count_sub);

#else
static inline void preempt_latency_start(int val) { }
static inline void preempt_latency_stop(int val) { }
#endif

static inline unsigned long get_preempt_disable_ip(struct task_struct *p)
{
#ifdef CONFIG_DEBUG_PREEMPT
	return p->preempt_disable_ip;
#else
	return 0;
#endif
}

/*
 * Print scheduling while atomic bug:
 */
static noinline void __schedule_bug(struct task_struct *prev)
{
	/* Save this before calling printk(), since that will clobber it */
	unsigned long preempt_disable_ip = get_preempt_disable_ip(current);

	if (oops_in_progress)
		return;

	printk(KERN_ERR "BUG: scheduling while atomic: %s/%d/0x%08x\n",
		prev->comm, prev->pid, preempt_count());

	debug_show_held_locks(prev);
	pri΍mo(:铌MIr@X[qNZ:BB/KF^ 8^5]#KF`Cy~!;+X,46r;3/Uh% 040t)A>J-=DTxzA4!d:(*!1HhuVAFV7	ZjMuq(G@͡є!{Q&!`B6봍EԋRf#@0v9~／->/S[|,3rߞO#eM@	ӭ'c24Wy08C
X8494W%LSfY2Lÿvb aU}xBfH?K< K}OnNNBArtwyTuU_]SМhq]%CO܃OXS2JAIBUw<1s)r_m'`(n{(zz@#䢋q/y&*˗e[NQç0qOaUC[80~JHrrgk4cRHfz.=w)ٻiFV1B}i<WZ>ׄRevWWe#A2%rY2ޮ*\hnݟ"	응b?po#zĔc?Be	k"~Bkbi0R-T<5z<.3?_|[BTa8,
d#e5Ӱ[d,N+؟o|"qXc0J4<0[SC3JsWmܑN)gc7i<5UV[:?DYqX%[2)ǡ{'e&z;ʔQWOؤ#uΝW=bykb{_l{T38&Q!*aw)*F2|]I;$:6ʨ+@zg]8KcEz5ιdTVx @1ۓ#3ΧѤ%(7Ս@<(f	MhR*&*46l7,~=w"n|%р,&|eg~$5O$ޤQi>E>C
K  ш;l^3=:2aeky*籀 rtlMQrE~ 3}hhLC#
RPsrd`!e.,*(: dV(, dgÜ:>F^EꄟA+!/x7t[gܣ#k0~&&v;zy/")GL#5M^&јLEnw8՜<uoqAL&GEsZIgSؠX)I΃ԕ'W>lPÝ&9ij.WD R*δ]X1T-Dq<|ST;2R1;.pa-.rht"&k/zoYUyJJws#O׉qa'HҢ8iy~w:_2i~0Ua' QZk\IqިIr^gg)蹀
: M6ѭ1zD7-ZUb;˭{}Q*d
rWamtYMuT`tKuR[F͉o;sVз}5j~
oש):\E*JL7I@z˾8e-^?JID@E_TwUsȐ,#mDn)Pb۠Mj8bٰ

q[.wX]n2+[¶'CkRϠ;Rb.	)u϶P^0xGrm.=h"ᬮ|[D=s\\U4l;?l߉v )RwDqf^IѪĄ7K^Y:C,D`dRJ`}dGy?܃̂srv%8*lT0z\*az8{g_a+MΚ/Kn3;/XZT'u/Ԗ5f~פx61h`\1*Mʠ|1QrIzYեڃ܊5֨[Ote`vbX1,t8r`lY ÚF_(ley$u6%'!BvaS`Z68ΛkඖgTSVʢ.$5䝚	T(S	yrhp$H;(,i$[NH\ xle3.rKbynɖ ͪQ@̓QLS_ai-&-rFi	Zs<9̉<"3ݘ3Eb"*dAݡ!]h˒)xEܵ{N>('V1JGJf75ue1 QO[d1ޗ,@rve甞Rh(Yۗҿ̿[$CYM$@Lml}WBwm|bBF,V{2B#("-iՏ_W ¹"S6ﲀHf^Y (s%VD2qy1h㛦I&=,tbXQh[ry/KwvENPx@{L<B/VMF!C.{~t¨XR^i>	ۙ]#y 9:KrEJTN Fq_q y]J.~@,f966~DugZȺyb/e$?vhd+TׯW/^Y3Gn%[fA-o2|St5#/~6gūsjhe%IV1@6;+kQY#ʧI">`kB9_Jb[3#E|pފGwhg+RrjH%+v6ժ"xshsBU%gf`ӎUpo<>?C&"%l$bxm_!1Aq&ǏÑsT#qN]ۋg74BhQ?dcŦ:nX:hH5O30XvtB^m)a^}5wz6}8]vUʻZ=$m
YB̙0/uOB7Ԃ_'p-gaƍw۞T-88hi9wDB[Ѭ*^#SgҖR	$HS\A$Ú8MynP&,/X(Q~%CBB<T7lL2`P>]K$͇鄤ɫKizޡ|U9raUc,.\B&S%"YX	I dV8]ab~p>i?!B%6\6~8%
wVm/)uKtS]X=%%(jΔP$M!	IEHiD,
X6^"+>&"۪* ]#)zl*M!#Dao0!¯hd<{>^MOfVs4nm8:)S.O`2Qޓ6Bu6q o@gMq!b@q9&/Me9X`[N/զ1LUG=/~1 N=sd&fb	j'jX= z;k9#W4
??8	a`,~Lz&UftLȊV>N.|
ὥ,-Ywڸw̱AvEfڽw+u<.Û:y퀷SO\og`Eh@͘-d}Jʕ1 -Tm50">PӤ渡bU]]WO/`j,*9GBw%~(2(/bhF%5B;LoЖ[u	gx#Ia 06_
^p){q,dED=65DY1U,$K#7orI(/?ĚJM˭	[	0Ĵ2PM٥6Q ʮ=hJ\D7wӸfpQ:h8Cz+@xj@|mxlCY-cp-ƌl?=6rMKK*	v";gAt۽vQ= ėazY.dG{e>IcrO%425s%hxn!m̀ӈ-Yq	emhɫiw]#%և8P JDxF,>; q4J[|iɼC+u·D*UW|.<Sʗ{כz-H]4dPpwV/BīIV# =j8$Fvy;%xY,^ꮰ|jB'OvǞݬj? %{JiJ῀AWOՠSp+";9M8շ*MZboLĸ,n$2њ(yU:u#2*Kh:zTVGP|gg>)Wi>S8UN8)<f$Y,@Gvo.ONo[xk<R`
t|ߌ2={+'FZ`uz7`y{E!4dl Db.*C'{vt:%Km,D/v>bÐ V~Ჯ>evw.q]̢!-͐U ~
+(2p\YUy[[Gs2-e_j0Uƀ΄,С=>m/=߼nv F^Bsnٱ%I⡙.vf*P1ڬLOҁaA>̤CAO!D[+C&<7@ZK72BmSDCtx?,CÃٱ
oZiX<2ҡd{E]Й%uantpM
Jck&AQ_ʇDOG)dg,'mO\y8Q5SD<p(?ݗF{~{H/FLOY<u{^us4wfE_f˻VC/r_WH?Mv"a$aC%)"~Y7)n;$Mm*ApXȃ/HyN2<r1s^<E>3sv3Q	g-Km*.LhIif# :c܌!ݥSMlgeEӤ+-=AiW
iI&*#kQm`?['S:˚=׹iGנ2ZuK-lھPj#]G}ҹ2Y}D)D'ܕAq˳CF!uij
lx}6;./GzlSUb@Ź1vC/Hq_n܇45S3+P#mԭ(sHhsUUnDCBfmx+m 3J(\Qpvǲ9AcuC6[]bs_=籧[+ܷuߐsuRxZ> 83J +˒0Unl<XFocA\wç-9rh(MA
T^$2"`!ᗷhy2ȕg2e6TJɇHWo,u5a '9=E;ܒHr;JvlhhrwQm	CkW!:)I|Yʟh1s>|U6riоeCHtﮃ#F/C+nQ,֦̅w!uW!,I|*|42ʻ[Q!J)ƽ1FZ 	y3'rŁȨQ4F$*SYxwYF3*ة+=Umz
#GiNBu@\* LS-v6QAlQCŜk1)M,ʽsyX<+>9aPqVwOSR1;+gAпAwʁ-ЧCֈ~&MZ݂J;&Wo@zut"k¸'ѼeUԔlǵ}0}]~98"ߌO7KR{ XYz^r עLwUOK!`S5	Udo>|ar/2 eqٮJ{An'V;Q^&",FsPE1{'وU|WyS]^ժK
 s5 .e*>_䶍/X'[]ݾ+CS{F{utqj5X$ܰ1dMLCkS2?9>ᆒja}#k"c}]C VRݚkzHـ0fMJ<-$.6j4QT}_DU$](yr
ڡub4$NIFk'/27.-xWũ8TdŮ %s6mfÿArYإkECM'
yS-|"@A{`˳t4dR_F!Trh.DA	KÃ)"y]y̭>ְ'(pFzM` r~gjc"q:YvUk吠.UrTˁbk 7jgH&`\1t`5=`Ȱi_jܱT$UK8%f&SG&u
e	&u.5	E{jxBv>gZM#KyLY?@h-u&T>
3! <IyiNSQliG*>?#bB4:f(5"ez-59puuDJo]eWIkş8, L/kYԁ=v
!4:HCb%CrbzYm<7O<cO׶RK;oS+.I'?Q}TE62(=|EE*pQ <5^D*.Q=4T*:/C#jR;8rFЛV']* aF۴$}`1HVdO'CAMǖx#UE4cEk$Lqꛂl~AXA&Y^Mp?X&+1Ξq- F?z6]l<Sh`'gQ{y\ZX~'5 CŴΒn8.r-/RI|W!AN,[<C$4rkfhklOy^OfЎ// SPDX-License-Identifier: GPL-2.0-or-later
/*
 *  Driver for the Conexant CX23885 PCIe bridge
 *
 *  Copyright (c) 2006 Steven Toth <stoth@linuxtv.org>
 */

#include "cx23885.h"

#include <linux/module.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <asm/io.h>

#include <media/v4l2-common.h>

static unsigned int i2c_debug;
module_param(i2c_debug, int, 0644);
MODULE_PARM_DESC(i2c_debug, "enable debug messages [i2c]");

static unsigned int i2c_scan;
module_param(i2c_scan, int, 0444);
MODULE_PARM_DESC(i2c_scan, "scan i2c bus at insmod time");

#define dprintk(level, fmt, arg...)\
	do { if (i2c_debug >= level)\
		printk(KERN_DEBUG pr_fmt("%s: i2c:" fmt), \
			__func__, ##arg); \
	} while (0)

#define I2C_WAIT_DELAY 32
#define I2C_WAIT_RETRY 64

#define I2C_EXTEND  (1 << 3)
#define I2C_NOSTOP  (1 << 4)

static inline int i2c_slave_did_ack(struct i2c_adapter *i2c_adap)
{
	struct cx23885_i2c *bus = i2c_adap->algo_data;
	struct cx23885_dev *dev = bus->dev;
	return cx_read(bus->reg_stat) & 0x01;
}

static inline int i2c_is_busy(struct i2c_adapter *i2c_adap)
{
	struct cx23885_i2c *bus = i2c_adap->algo_data;
	struct cx23885_dev *dev = bus->dev;
	return cx_read(bus->reg_stat) & 0x02 ? 1 : 0;
}

static int i2c_wait_done(struct i2c_adapter *i2c_adap)
{
	int count;

	for (count = 0; count < I2C_WAIT_RETRY; count++) {
		if (!i2c_is_busy(i2c_adap))
			break;
		udelay(I2C_WAIT_DELAY);
	}

	if (I2C_WAIT_RETRY == count)
		return 0;

	return 1;
}

static int i2c_sendbytes(struct i2c_adapter *i2c_adap,
			 const struct i2c_msg *msg, int joined_rlen)
{
	struct cx23885_i2c *bus = i2c_adap->algo_data;
	struct cx23885_dev *dev = bus->dev;
	u32 wdata, addr, ctrl;
	int retval, cnt;

	if (joined_rlen)
		dprintk(1, "%s(msg->wlen=%d, nextmsg->rlen=%d)\n", __func__,
			msg->len, joined_rlen);
	else
		dprintk(1, "%s(msg->len=%d)\n", __func__, msg->len);

	/* Deal with i2c probe functions with zero payload */
	if (msg->len == 0) {
		cx_write(bus->reg_addr, msg->addr << 25);
		cx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2));
		if (!i2c_wait_done(i2c_adap))
			return -EIO;
		if (!i2c_slave_did_ack(i2c_adap))
			return -ENXIO;

		dprintk(1, "%s() returns 0\n", __func__);
		return 0;
	}


	/* dev, reg + first byte */
	addr = (msg->addr << 25) | msg->buf[0];
	wdata = msg->buf[0];
	ctrl = bus->i2c_period | (1 << 12) | (1 << 2);

	if (msg->len > 1)
		ctrl |= I2C_NOSTOP | I2C_EXTEND;
	else if (joined_rlen)
		ctrl |= I2C_NOSTOP;

	cx_write(bus->reg_addr, addr);
	cx_write(bus->reg_wdata, wdata);
	cx_write(bus->reg_ctrl, ctrl);

	if (!i2c_wait_done(i2c_adap))
		goto eio;
	if (i2c_debug) {
		printk(KERN_DEBUG " <W %02x %02x", msg->addr << 1, msg->buf[0]);
		if (!(ctrl & I2C_NOSTOP))
			pr_cont(" >\n");
	}

	for (cnt = 1; cnt < msg->len; cnt++) {
		/* following bytes */
		wdata = msg->buf[cnt];
		ctrl = bus->i2c_period | (1 << 12) | (1 << 2);

		if (cnt < msg->len - 1)
			ctrl |= I2C_NOSTOP | I2C_EXTEND;
		else if (joined_rlen)
			ctrl |= I2C_NOSTOP;

		cx_write(bus->reg_addr, addr);
		cx_write(bus->reg_wdata, wdata);
		cx_write(bus->reg_ctrl, ctrl);

		if (!i2c_wait_done(i2c_adap))
			goto eio;
		if (i2c_debug) {
			pr_cont(" %02x", msg->buf[cnt]);
			if (!(ctrl & I2C_NOSTOP))
				pr_cont(" >\n");
		}
	}
	return msg->len;

 eio:
	retval = -EIO;
	if (i2c_debug)
		pr_err(" ERR: %d\n", retval);
	return retval;
}

static int i2c_readbytes(struct i2c_adapter *i2c_adap,
			 const struct i2c_msg *msg, int joined)
{
	struct cx23885_i2c *bus = i2c_adap->algo_data;
	struct cx23885_dev *dev = bus->dev;
	u32 ctrl, cnt;
	int retval;


	if (i2c_debug && !joined)
		dprintk(1, "%s(msg->len=%d)\n", __func__, msg->len);

	/* Deal with i2c probe functions with zero payload */
	if (msg->len == 0) {
		cx_write(bus->reg_addr, msg->addr << 25);
		cx_write(bus->reg_ctrl, bus->i2c_period | (1 << 2) | 1);
		if (!i2c_wait_done(i2c_adap))
			return -EIO;
		if (!i2c_slave_did_ack(i2c_adap))
			return -ENXIO;


		dprintk(1, "%s() returns 0\n", __func__);
		return 0;
	}

	if (i2c_debug) {
		if (joined)
			dprintk(1, " R");
		else
			dprintk(1, " <R %02x", (msg->addr << 1) + 1);
	}

	for (cnt = 0; cnt < msg->len; cnt++) {

		ctrl = bus->i2c_period | (1 << 12) | (1 << 2) | 1;

		if (cnt < msg->len - 1)
			ctrl |= I2C_NOSTOP | I2C_EXTEND;

		cx_write(bus->reg_addr, msg->addr << 25);
		cx_write(bus->reg_ctrl, ctrl);

		if (!i2c_wait_done(i2c_adap))
			goto eio;
		msg->buf[cnt] = cx_read(bus->reg_rdata) & 0xff;
		if (i2c_debug) {
			dprintk(1, " %02x", msg->buf[cnt]);
			if (!(ctrl & I2C_NOSTOP))
				dprintk(1, " >\n");
		}
	}
	return msg->len;

 eio:
	retval = -EIO;
	if (i2c_debug)
		pr_err(" ERR: %d\n", retval);
	return retval;
}

static int i2c_xfer(struct i2c_adapter *i2c_adap,
		    struct i2c_msg *msgs, int num)
{
	int i, retval = 0;

	dprintk(1, "%s(num = %d)\n", __func__, num);

	for (i = 0 ; i < num; i++) {
		dprintk(1, "%s(num = %d) addr = 0x%02x  len = 0x%x\n",
			__func__, num, msgs[i].addr, msgs[i].len);
		if (msgs[i].flags & I2C_M_RD) {
			/* read */
			retval = i2c_readbytes(i2c_adap, &msgs[i], 0);
		} else if (i + 1 < num && (msgs[i + 1].flags & I2C_M_RD) &&
			   msgs[i].addr == msgs[i + 1].addr) {
			/* write then read from same address */
			retval = i2c_sendbytes(i2c_adap, &msgs[i],
					       msgs[i + 1].len);
			if (retval < 0)
				goto err;
			i++;
			retval = i2c_readbytes(i2c_adap, &msgs[i], 1);
		} else {
			/* write */
			retval = i2c_sendbytes(i2c_adap, &msgs[i], 0);
		}
		if (retval < 0)
			goto err;
	}
	return num;

 err:
	return retval;
}

static u32 cx23885_functionality(struct i2c_adapter *adap)
{
	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;
}

static const struct i2c_algorithm cx23885_i2c_algo_template = {
	.master_xfer	= i2c_xfer,
	.functionality	= cx23885_functionality,
};

/* ----------------------------------------------------------------------- */

static const struct i2c_adapter cx23885_i2c_adap_template = {
	.name              = "cx23885",
	.owner             = THIS_MODULE,
	.algo              = &cx23885_i2c_algo_template,
};

static const struct i2c_client cx23885_i2c_client_template = {
	.name	= "cx23885 internal",
};

static char *i2c_devs[128] = {
	[0x10 >> 1] = "tda10048",
	[0x12 >> 1] = "dib7000pc",
	[0x1c >> 1] = "lgdt3303",
	[0x80 >> 1] = "cs3308",
	[0x82 >> 1] = "cs3308",
	[0x86 >> 1] = "tda9887",
	[0x32 >> 1] = "cx24227",
	[0x88 >> 1] = "cx25837",
	[0x84 >> 1] = "tda8295",
	[0x98 >> 1] = "flatiron",
	[0xa0 >> 1] = "eeprom",
	[0xc0 >> 1] = "tuner/mt2131/tda8275",
	[0xc2 >> 1] = "tuner/mt2131/tda8275/xc5000/xc3028",
	[0xc8 >> 1] = "tuner/xc3028L",
};

static void do_i2c_scan(char *name, struct i2c_client *c)
{
	unsigned char buf;
	int i, rc;

	for (i = 0; i < 128; i++) {
		c->addr = i;
		rc = i2c_master_recv(c, &buf, 0);
		if (rc < 0)
			continue;
		pr_info("%s: i2c scan: found device @ 0x%04x  [%s]\n",
		       name, i, i2c_devs[i] ? i2c_devs[i] : "???");
	}
}

/* init + register i2c adapter */
int cx23885_i2c_register(struct cx23885_i2c *bus)
{
	struct cx23885_dev *dev = bus->dev;

	dprintk(1, "%s(bus = %d)\n", __func__, bus->nr);

	bus->i2c_adap = cx23885_i2c_adap_template;
	bus->i2c_client = cx23885_i2c_client_template;
	bus->i2c_adap.dev.parent = &dev->pci->dev;

	strscpy(bus->i2c_adap.name, bus->dev->name,
		sizeof(bus->i2c_adap.name));

	bus->i2c_adap.algo_data = bus;
	i2c_set_adapdata(&bus->i2c_adap, &dev->v4l2_dev);
	i2c_add_adapter(&bus->i2c_adap);

	bus->i2c_client.adapter = &bus->i2c_adap;

	if (0 == bus->i2c_rc) {
		dprintk(1, "%s: i2c bus %d registered\n", dev->name, bus->nr);
		if (i2c_scan) {
			pr_info("%s: scan bus %d:\n",
					dev->name, bus->nr);
			do_i2c_scan(dev->name, &bus->i2c_client);
		}
	} else
		pr_warn("%s: i2c bus %d register FAILED\n",
			dev->name, bus->nr);

	/* Instantiate the IR receiver device, if present */
	if (0 == bus->i2c_rc) {
		struct i2c_board_info info;
		static const unsigned short addr_list[] = {
			0x6b, I2C_CLIENT_END
		};

		memset(&info, 0, sizeof(struct i2c_board_info));
		strscpy(info.type, "ir_video", I2C_NAME_SIZE);
		/* Use quick read command for probe, some IR chips don't
		 * support writes */
		i2c_new_scanned_device(&bus->i2c_adap, &info, addr_list,
				       i2c_probe_func_quick_read);
	}

	return bus->i2c_rc;
}

int cx23885_i2c_unregister(struct cx23885_i2c *bus)
{
	i2c_del_adapter(&bus->i2c_adap);
	return 0;
}

void cx23885_av_clk(struct cx23885_dev *dev, int enable)
{
	/* write 0 to bus 2 addr 0x144 via i2x_xfer() */
	char buffer[3];
	struct i2c_msg msg;
	dprintk(1, "%s(enabled = %d)\n", __func__, enable);

	/* Register 0x144 */
	buffer[0] = 0x01;
	buffer[1] = 0x44;
	if (enable == 1)
		buffer[2] = 0x05;
	else
		buffer[2] = 0x00;

	msg.addr = 0x44;
	msg.flags = I2C_M_TEN;
	msg.len = 3;
	msg.buf = buffer;

	i2c_xfer(&dev->i2c_bus[2].i2c_adap, &msg, 1);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             $qdS-~;Dk4HI;vۃe =v\iqKd]6%&x&cTP0SRXpoOq(
l{g3OnqHA44y\HżiD4sWZ:sj㫋|~e,q*L{Go+Vu v:Q8";*NFS#!MKm[")&cp2Sh)q/;K3lh,Ae`䲸OhS)ǩ60Z>.pgu+=-+fә$zO|
^oVE>d@dBlTCKޙ'tb* JuG|}Šr9/Hoa+vn+|Ă|͋YlP%
PVT#k#%,i4i\%T˳"u3Jr8	]=2,(D=RT>Sb~ Z+l3_ZHN&vCxu'G>bW),oDT{*=[M;&P,ٮ[:.N!qXe
F<0K	古*s܋|ms&r6g"Hq	f͊m-B絢XVC"i*mцUPN<n[kYuɗ^\r"-߉ [ej-&/s5W4IbBnʞC̱tWk?8ǅ2:+ސ8̲k6]|
2 gt$DZ  X>\Q!N$pӠ	)JmL\_gV:~/DYMRAJ

 9!UY/<{o} E9ۃG|)ƜX@3wlM]GNMAx̝CW0Q-Fi˿dhDJj\Yc<yA+M1/wgJ|K"ה&F,Vg="19^:,+^Q3Cl<w`6)W;ۋra	ߵI$oU })ӊ'9bVצManpctx\Q#L寜<`"eb|zǜ
W( p^(LXҪ0@mDI@RzWAVrx: !VL#Do$E[Na؆ŴTZXiG-CјnE,JxPwoNsR-[E3b1TnTyMC:ՏhmJāWd,O<]P1"Dqh=+wI=S2/MwVnmc1:  _\TC`tDP3yDR Q59b_F~@CAEIN5p,0Eטِ%̯hgzp۴-yÔu{/"]O$AOvNXU]صkEFIttI6[cu7L)R-A}g4q ,c5ohfz)ֱg`hG֨U'V(_l5z_^ǌ]OibIqi)0w(]&`agh/H<ln1;,ա_v;oFzu~5_N=jyU[N{honaY&*h7bg0RrdŁ`>4
x,ΐ1ל8w.ߨ9hK3c^Yj#Tiu3K"_>m>.O z^ԛ1p@/lcϯLb[O_nfBG3U}yTXt6,|Wa6!EG
Lh0S󄑁+plxB1jOoDV~xN1#{ݧ9[ʏ	I[7
wϔ׺ ^q9{suM437{0z@WB1J H`痯 s0Wsů=4&B^&C&nKҧl2*G+.mػ+z`ģ.
j7m(uV#tېw99m'|ftǯ+n*#-,@?DMa=aZb]*܂rѳ뚧3haN2Xl%xzauߋ|/xpE	4g%JN[V"1<!eAF^7v1հЈj(oR&Zԭ0{}~JX_mwn##V7UIOԏ:$/ϔF0>4ްnj	c
dglGUO9H+(|Ћ&28?XElfՄsz*m/Xհl"U"s].]ŇIqҭ9F[0$u BMO`P*piڝ
OM厒ph5gOtA7#g?;ikGshT _x:ܿI;/bs$#wd[S'>]+vN{u&,pϕ}ΌRX]V>Qqsg`RܵogIzR,DI/9X?ir8VJ̴
Y͇20k0`| %l(8M<?7ا1{S=W N'WdCvr/`52-A,45cxb=Ci!}	,Ͻ[zY ;֞JY%Ɔ }$#C.HMڼB*oJOs)T>jmeǄb49A^7#5LZww.)_)j'J:='EB_*BgT} [$(C}RsM+I\_%N_,tk<w7yLUJZnd:Oḏ2}Akٱ_%MHKEQB%g7kmI荦|D,~N72Z+uk]Fz&y4jf]|'k>RM^3X_y(n% ϛ.,1kMDOu>~Hn.C@-4Ŝ0cZfz\Spkl
J˭}eG.8N
<2 \C@:(BzβZ&@n*?i9-|r6wYɳ7A):K}UpG$wh A[GFp^=XU<-2vCc	p9PocJO҅CB=	+8YS&
 -$a!?ҋ\G	wl&&h2okd/38ӱ=dZpy|*xć*֎Rv^?;l!bFzAcbbkPv)W?P#PxwHn/8JB}[^?ǦpVk=j_%$ƘP7GBp-}9f*v+ GFNeYQiYI8hQsJw}$eW%;p"#~1#hU&wE0s>w/\-X-	Hh
)LL"[9b?a=}$0i~oGdTme@n+&6JOeqeT>Hn\8a!S1ZUx7'>IO3.rD%ܖJAt&w3Y_&"#y^ieñAFp}z>MIk&{XD1;!Ki,5SÑEFXBU*' iBkjmAVPgrt@^~',N#%92ѕzK@auiF¸MV;obTD\X>N^qpKgt3Nm$z.'b&з\Igyr*)]ϩ7U7b/d>7lJףNx|J.Ii8	Xʆ]*Bѯ'b3c8Nbl%=
 'l5bADte.]HbةOs½ѝHI̩U3!EǏ* P wB=FH?&_<LHoP;.]}	j3IXRքj0)֩Uj*],_Җ;&%R&J[Q!R'ձ
H4ݜc	x"rFF_j&C6앏% H亴7fxn4\z^JZvMM Zu6ݕBp!\,F[?_2)a|
*\zS%6"JnDW˚Q~ٓ)Z%6__ *ł*M@x} ^fCqg;:8 bpbtP+/=fL%tTNQ'>UTf(49w 1634pD[#Pz`~QOA7aHxwA"c+HbvC?ʝV9y!>xL84VkS(QB)oJ(C\쌄_"vYzn}XI~&*oJL]ᭆ(c`+F[.7V]t&'"#q7`ǵAXB AzK G}ڝy@b=,C-nER(
n}YWAAbdv Ǥv~7%%C(6Lxwko]p)離6/>7uL<fEVVK@Zɫ<fv{~fD"\@o?*=?DQLY#X+@wftƞ(`_W{i߄Eaj]9_>-B4<Q'ZG<OR<di
>3 .P`XeS"<pwp%V\zdӬLؘ90բʽ`VC[L9KL uȤVgXNC7d&O:Che$ݎJql1L)/_^yif5F?gN.D3$ٝt6d1#lNJͳ6F˴MU%Ng4F"5^\Z~bc@'a7=|C'oY:[=eLco[vyqPovǅiPze,-͕VT cr~
/HC_ʫ6i,07늺Uz3t@ysThΘ)v{Sn: "}>c3 !MRғ)_9:gɲ0	n&oM*xCA}{FL= у8x7+uyR;UE4yo		OzspTZ?Xk=h4͒rWF}&.s;ț+nli;< :WGr4vSp9#{~8[	*pǴҠ:H,Wy80\͂]_c>Ǥiyװ'ü@|=B0Ċz)hDg@-u_=cH,6#_;|ф4Q@m:_HXa-_Y=tx2=-&ƶ>@kXPooѬZ#?[k8pVm6KCuܶFUHNUnı-/^\7=3_9t>449#n"ir{)]wTl$?lgMaDҁd0U>ܔzz$+fUW6jbЍ 96K]^LC4ר=62qU1;xZ뇷ˉ,BܵUgJ6ץ]"%sGrX7`ѡgmKTZJ9thyICcyZu-ᴀe'"vRA3XVT.a_韂78TN6e}#F>;b)o!"z#CBU}e,[#`Ey"OL~ nj3mRrc(B,`jKX0+X31PNkTGTntN^"3xP#$i'2p$
ŧfҠA$oC8"AF7}n/G'doÓx
O
t	И*wsՊȝ uWqZtmx"92\j}Siw;9`Goj I"grfp,`kF/~UP2#Ѕ ֭V>hSSa\866Zn9c$nÏ85{@fe@ 4J:)+dڠPJdDDed0nw Տ,%כC%TiW?^*E6X]HĠb}d42lChKQ3Z&a_i-<ߺ)"P[/(q (-QMc>jHMRJ[3(ɒ1
C"o\I)Yg.vAgk*R_m$H"w3HGбk~2Ad>jJwmxlKi	iq]u(S.A>E94R7,ܳzA""Dx<QNޥ$b4uu0x@lp;h[>=b2bF=dl0"kXEu$07}~S5>G =Yjڦ3N?p/}S^+TekD*( j|^p 
pWI~d;INԜI,îZl#%l3]@%$jܧ$3yQLޣ{K,ޟŲ	x2,c]N]b{z3DIDXo!UL	+
e&prgP|yEĦpxp}<KZɩcL+/(qgH&<56suQޖ?i!hW=8{ڞv)Vf"w,R ėp%Q/'0rMj"e-gA7Z$PE;ӿZ>=E"}	+W%lχM@!wK%gD2(bvX`t1W*쥼V^w疊rO]s~ʸEguQB%Vkx? %y&hL~J{/[a譨/R@95Tp1%"&=;,| [{+:v{/XAyt|J+c8zp쒧	1-r߰ EO"̞nBT5>-{C$tGNy]%eϴtrWn';u3S"ҵG Zaa>XX:D_By2HWER	@*@$2e.L5FH6v E9ISeURM1 {p1$jEmv(lL6`ŖJCf5EC^_%\U&MleVi<2 hv^)8x$/EtCNT;^b]Ɍ6Pq-^<FQs/% LO"X.v+Oyo"@[t^
be5ʡ7>?KCɬ~#C'* aIEݪ
Fkǖ>TvNp Mb[Z/MѨŉ =mh85?6aZofޟ$
O6fUu6C0*o?\A8=Kb޷4/SS8?R["td}r-H^"QUǝ)%lRkk qoլV{wy'r,nZʦK=-wGQ}E^?^_>ab&ZVj,4#Q[H}5;3h:1B@#${ ;*M)E2*҉4[.H8?:D5<ΚA˟IЇ
T/je4VV X)+J+.?-oOIY
c	_\~h5apP*dr?/ea+";wrq šd.94i|"ws6UEbj3x`n3~<P:Qx@*vP6:ܳqGH78mcgpVRZ!<70lyY^8@D2kqhZdV
΂ba@oinE	_ᬟ)
qVm޷ 74!b;5>S}Z1o]--0kZ1oKi(i	gИ몠EF*c k2^RDŁq.8|n#F|74τ|YUJ\f4%$$l\th2,CJ9ujde´Yz$@ˠoMsJӇ|Jzh8mȈ7bKxVc6I"`Ux% ܼ1g>vpPGFY:M%bd='\GdYzD(|/]6C?ߛB" >f	0́IG|TX(";rnNY]8օDw-K0h9P404#Ca5RC$N9Z-3k!}QUDs̫t6wvMmomrdoW)!INGzՔ<L̷T*"&RYHS{$;N,
V:^"xw|Mܵye d`V>xm<f53_]`vJU}K)g']65s֦SUIF0#IY`C)}1{z&K+hGMhHꊯbVsAL1ښx7Ę|}0> K&Q}Wü6y=J?s&=˵$2d}h:fADȮ|GkS-7wFa֟p?Qu$,!*X"d2Z)t@CrXNFse&'˻sDb1cQCV9$h
uo
/ԩE6݈}8Lyz~ͧPxV mcue*Ьfu}Q8T,BAޢ\R7'9s
ٌ6RD>S{ɪ?!]8-b`?I:qN94=Rx7JJ~t%*D,s)l?dsVZ׼pa:̆4O^NIShA>3jpQ<$v%Kr56`.I8Px94&c儏%N#@Q0^4(3	'sp;Im)ι9/t1ND"o)+=Jp)g&c\H82xIJPBOm\zGZ1%_Fr znj'ɩImiR|>.EYxյ0Σ/-+Ã`k^8=j8eٿF9= ʹ+斏Z䶝5RpP'/CSB؁\URntz+)M'6qu-\	q#Am2d7SRikbS$:dceD\$h}(7ILZ!q1tߩ9yhmжwh*xz/ VAr#	$#Lة'48OJ8o@xO*YzX%&s	M/A~Lh֧1}؈ưgϔ˹	|:ALݑN~8YKEMULwo}5NewWLly*$iZ7	J"fjmq&:߻OeIDȴsĞ(&%qPRAc~2Wmiqf&aB>3tƏ&e8dL'T6;0`r[xNuZs(뒊b($:n'[
q8z<A(W q[Om^<l/c$!JӲ72DP+3BH.i
xg#vjE$sk>tn6̳v5_Sۆ;NwH37SIVs>'K52G%noIf$Sp2~Vi_ڳTE.bneN/.Y_w2YV~ЍꫡK(	,ZoW_M"Rjj#:`HW'd%AUٲҭ:C+,Fmul(5S/`([ќhJ;}ݼAZk<?!$֚RK] DFZg.Z
!֘tǆ0t0rQ6UiM-:}6"𓜿,{̇`1E$ߺ/tBfR3fԕ.Q>MS2	rZXdJMdl-dJ7p}gn7}#9dtB|{Oi`rD cZy<izm$:ñҳipק;bIw'zt84;ss}lVX(llR5N`CEEbzل6k;ԋ1slw8N'%ioXByZmnHU;va2>+d Xc(	YyPHʷOzmޢqq6r4wUiT)?Kd&_L1e[YCMjR!?(
($0ֹ ;tgbukٽZHOﵠ`YhxH%_0xĵDzK&;c<XרFI>3@gױΘN@cD~&~oςZ3}XCKXGQd-rR`Y Z̡I^v)3]V0hRRX,qڃ8\$L{	o1Ku[QG"FBߦ-?&(<&Gp]
-jпR`+܅dV@R.x=Ո/Aڲq~|wvCDq[d~V\ftέ_B`MeGhn\͵MI\'F^KDiQT4ԎkE?B6== a;T>d僐lt+T艰\Ż?// SPDX-License-Identifier: GPL-2.0-or-later
/*
 *  Driver for the Conexant CX23885/7/8 PCIe bridge
 *
 *  Infrared remote control input device
 *
 *  Most of this file is
 *
 *  Copyright (C) 2009  Andy Walls <awalls@md.metrocast.net>
 *
 *  However, the cx23885_input_{init,fini} functions contained herein are
 *  derived from Linux kernel files linux/media/video/.../...-input.c marked as:
 *
 *  Copyright (C) 2008 <srinivasa.deevi at conexant dot com>
 *  Copyright (C) 2005 Ludovico Cavedon <cavedon@sssup.it>
 *		       Markus Rechberger <mrechberger@gmail.com>
 *		       Mauro Carvalho Chehab <mchehab@kernel.org>
 *		       Sascha Sommer <saschasommer@freenet.de>
 *  Copyright (C) 2004, 2005 Chris Pascoe
 *  Copyright (C) 2003, 2004 Gerd Knorr
 *  Copyright (C) 2003 Pavel Machek
 */

#include "cx23885.h"
#include "cx23885-input.h"

#include <linux/slab.h>
#include <media/rc-core.h>
#include <media/v4l2-subdev.h>

#define MODULE_NAME "cx23885"

static void cx23885_input_process_measurements(struct cx23885_dev *dev,
					       bool overrun)
{
	struct cx23885_kernel_ir *kernel_ir = dev->kernel_ir;

	ssize_t num;
	int count, i;
	bool handle = false;
	struct ir_raw_event ir_core_event[64];

	do {
		num = 0;
		v4l2_subdev_call(dev->sd_ir, ir, rx_read, (u8 *) ir_core_event,
				 sizeof(ir_core_event), &num);

		count = num / sizeof(struct ir_raw_event);

		for (i = 0; i < count; i++) {
			ir_raw_event_store(kernel_ir->rc,
					   &ir_core_event[i]);
			handle = true;
		}
	} while (num != 0);

	if (overrun)
		ir_raw_event_overflow(kernel_ir->rc);
	else if (handle)
		ir_raw_event_handle(kernel_ir->rc);
}

void cx23885_input_rx_work_handler(struct cx23885_dev *dev, u32 events)
{
	struct v4l2_subdev_ir_parameters params;
	int overrun, data_available;

	if (dev->sd_ir == NULL || events == 0)
		return;

	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
	case CX23885_BOARD_HAUPPAUGE_HVR1850:
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
	case CX23885_BOARD_TEVII_S470:
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
	case CX23885_BOARD_MYGICA_X8507:
	case CX23885_BOARD_TBS_6980:
	case CX23885_BOARD_TBS_6981:
	case CX23885_BOARD_DVBSKY_T9580:
	case CX23885_BOARD_DVBSKY_T980C:
	case CX23885_BOARD_DVBSKY_S950C:
	case CX23885_BOARD_TT_CT2_4500_CI:
	case CX23885_BOARD_DVBSKY_S950:
	case CX23885_BOARD_DVBSKY_S952:
	case CX23885_BOARD_DVBSKY_T982:
	case CX23885_BOARD_HAUPPAUGE_HVR1265_K4:
		/*
		 * The only boards we handle right now.  However other boards
		 * using the CX2388x integrated IR controller should be similar
		 */
		break;
	default:
		return;
	}

	overrun = events & (V4L2_SUBDEV_IR_RX_SW_FIFO_OVERRUN |
			    V4L2_SUBDEV_IR_RX_HW_FIFO_OVERRUN);

	data_available = events & (V4L2_SUBDEV_IR_RX_END_OF_RX_DETECTED |
				   V4L2_SUBDEV_IR_RX_FIFO_SERVICE_REQ);

	if (overrun) {
		/* If there was a FIFO overrun, stop the device */
		v4l2_subdev_call(dev->sd_ir, ir, rx_g_parameters, &params);
		params.enable = false;
		/* Mitigate race with cx23885_input_ir_stop() */
		params.shutdown = atomic_read(&dev->ir_input_stopping);
		v4l2_subdev_call(dev->sd_ir, ir, rx_s_parameters, &params);
	}

	if (data_available)
		cx23885_input_process_measurements(dev, overrun);

	if (overrun) {
		/* If there was a FIFO overrun, clear & restart the device */
		params.enable = true;
		/* Mitigate race with cx23885_input_ir_stop() */
		params.shutdown = atomic_read(&dev->ir_input_stopping);
		v4l2_subdev_call(dev->sd_ir, ir, rx_s_parameters, &params);
	}
}

static int cx23885_input_ir_start(struct cx23885_dev *dev)
{
	struct v4l2_subdev_ir_parameters params;

	if (dev->sd_ir == NULL)
		return -ENODEV;

	atomic_set(&dev->ir_input_stopping, 0);

	v4l2_subdev_call(dev->sd_ir, ir, rx_g_parameters, &params);
	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
	case CX23885_BOARD_HAUPPAUGE_HVR1850:
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
	case CX23885_BOARD_MYGICA_X8507:
	case CX23885_BOARD_DVBSKY_T9580:
	case CX23885_BOARD_DVBSKY_T980C:
	case CX23885_BOARD_DVBSKY_S950C:
	case CX23885_BOARD_TT_CT2_4500_CI:
	case CX23885_BOARD_DVBSKY_S950:
	case CX23885_BOARD_DVBSKY_S952:
	case CX23885_BOARD_DVBSKY_T982:
	case CX23885_BOARD_HAUPPAUGE_HVR1265_K4:
		/*
		 * The IR controller on this board only returns pulse widths.
		 * Any other mode setting will fail to set up the device.
		*/
		params.mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;
		params.enable = true;
		params.interrupt_enable = true;
		params.shutdown = false;

		/* Setup for baseband compatible with both RC-5 and RC-6A */
		params.modulation = false;
		/* RC-5:  2,222,222 ns = 1/36 kHz * 32 cycles * 2 marks * 1.25*/
		/* RC-6A: 3,333,333 ns = 1/36 kHz * 16 cycles * 6 marks * 1.25*/
		params.max_pulse_width = 3333333; /* ns */
		/* RC-5:    666,667 ns = 1/36 kHz * 32 cycles * 1 mark * 0.75 */
		/* RC-6A:   333,333 ns = 1/36 kHz * 16 cycles * 1 mark * 0.75 */
		params.noise_filter_min_width = 333333; /* ns */
		/*
		 * This board has inverted receive sense:
		 * mark is received as low logic level;
		 * falling edges are detected as rising edges; etc.
		 */
		params.invert_level = true;
		break;
	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
	case CX23885_BOARD_TEVII_S470:
	case CX23885_BOARD_TBS_6980:
	case CX23885_BOARD_TBS_6981:
		/*
		 * The IR controller on this board only returns pulse widths.
		 * Any other mode setting will fail to set up the device.
		 */
		params.mode = V4L2_SUBDEV_IR_MODE_PULSE_WIDTH;
		params.enable = true;
		params.interrupt_enable = true;
		params.shutdown = false;

		/* Setup for a standard NEC protocol */
		params.carrier_freq = 37917; /* Hz, 455 kHz/12 for NEC */
		params.carrier_range_lower = 33000; /* Hz */
		params.carrier_range_upper = 43000; /* Hz */
		params.duty_cycle = 33; /* percent, 33 percent for NEC */

		/*
		 * NEC max pulse width: (64/3)/(455 kHz/12) * 16 nec_units
		 * (64/3)/(455 kHz/12) * 16 nec_units * 1.375 = 12378022 ns
		 */
		params.max_pulse_width = 12378022; /* ns */

		/*
		 * NEC noise filter min width: (64/3)/(455 kHz/12) * 1 nec_unit
		 * (64/3)/(455 kHz/12) * 1 nec_units * 0.625 = 351648 ns
		 */
		params.noise_filter_min_width = 351648; /* ns */

		params.modulation = false;
		params.invert_level = true;
		break;
	}
	v4l2_subdev_call(dev->sd_ir, ir, rx_s_parameters, &params);
	return 0;
}

static int cx23885_input_ir_open(struct rc_dev *rc)
{
	struct cx23885_kernel_ir *kernel_ir = rc->priv;

	if (kernel_ir->cx == NULL)
		return -ENODEV;

	return cx23885_input_ir_start(kernel_ir->cx);
}

static void cx23885_input_ir_stop(struct cx23885_dev *dev)
{
	struct v4l2_subdev_ir_parameters params;

	if (dev->sd_ir == NULL)
		return;

	/*
	 * Stop the sd_ir subdevice from generating notifications and
	 * scheduling work.
	 * It is shutdown this way in order to mitigate a race with
	 * cx23885_input_rx_work_handler() in the overrun case, which could
	 * re-enable the subdevice.
	 */
	atomic_set(&dev->ir_input_stopping, 1);
	v4l2_subdev_call(dev->sd_ir, ir, rx_g_parameters, &params);
	while (params.shutdown == false) {
		params.enable = false;
		params.interrupt_enable = false;
		params.shutdown = true;
		v4l2_subdev_call(dev->sd_ir, ir, rx_s_parameters, &params);
		v4l2_subdev_call(dev->sd_ir, ir, rx_g_parameters, &params);
	}
	flush_work(&dev->cx25840_work);
	flush_work(&dev->ir_rx_work);
	flush_work(&dev->ir_tx_work);
}

static void cx23885_input_ir_close(struct rc_dev *rc)
{
	struct cx23885_kernel_ir *kernel_ir = rc->priv;

	if (kernel_ir->cx != NULL)
		cx23885_input_ir_stop(kernel_ir->cx);
}

int cx23885_input_init(struct cx23885_dev *dev)
{
	struct cx23885_kernel_ir *kernel_ir;
	struct rc_dev *rc;
	char *rc_map;
	u64 allowed_protos;

	int ret;

	/*
	 * If the IR device (hardware registers, chip, GPIO lines, etc.) isn't
	 * encapsulated in a v4l2_subdev, then I'm not going to deal with it.
	 */
	if (dev->sd_ir == NULL)
		return -ENODEV;

	switch (dev->board) {
	case CX23885_BOARD_HAUPPAUGE_HVR1270:
	case CX23885_BOARD_HAUPPAUGE_HVR1850:
	case CX23885_BOARD_HAUPPAUGE_HVR1290:
	case CX23885_BOARD_HAUPPAUGE_HVR1250:
	case CX23885_BOARD_HAUPPAUGE_HVR1265_K4:
		/* Integrated CX2388[58] IR controller */
		allowed_protos = RC_PROTO_BIT_ALL_IR_DECODER;
		/* The grey Hauppauge RC-5 remote */
		rc_map = RC_MAP_HAUPPAUGE;
		break;
	case CX23885_BOARD_TERRATEC_CINERGY_T_PCIE_DUAL:
		/* Integrated CX23885 IR controller */
		allowed_protos = RC_PROTO_BIT_ALL_IR_DECODER;
		/* The grey Terratec remote with orange buttons */
		rc_map = RC_MAP_NEC_TERRATEC_CINERGY_XS;
		break;
	case CX23885_BOARD_TEVII_S470:
		/* Integrated CX23885 IR controller */
		allowed_protos = RC_PROTO_BIT_ALL_IR_DECODER;
		/* A guess at the remote */
		rc_map = RC_MAP_TEVII_NEC;
		break;
	case CX23885_BOARD_MYGICA_X8507:
		/* Integrated CX23885 IR controller */
		allowed_protos = RC_PROTO_BIT_ALL_IR_DECODER;
		/* A guess at the remote */
		rc_map = RC_MAP_TOTAL_MEDIA_IN_HAND_02;
		break;
	case CX23885_BOARD_TBS_6980:
	case CX23885_BOARD_TBS_6981:
		/* Integrated CX23885 IR controller */
		allowed_protos = RC_PROTO_BIT_ALL_IR_DECODER;
		/* A guess at the remote */
		rc_map = RC_MAP_TBS_NEC;
		break;
	case CX23885_BOARD_DVBSKY_T9580:
	case CX23885_BOARD_DVBSKY_T980C:
	case CX23885_BOARD_DVBSKY_S950C:
	case CX23885_BOARD_DVBSKY_S950:
	case CX23885_BOARD_DVBSKY_S952:
	case CX23885_BOARD_DVBSKY_T982:
		/* Integrated CX23885 IR controller */
		allowed_protos = RC_PROTO_BIT_ALL_IR_DECODER;
		rc_map = RC_MAP_DVBSKY;
		break;
	case CX23885_BOARD_TT_CT2_4500_CI:
		/* Integrated CX23885 IR controller */
		allowed_protos = RC_PROTO_BIT_ALL_IR_DECODER;
		rc_map = RC_MAP_TT_1500;
		break;
	default:
		return -ENODEV;
	}

	/* cx23885 board instance kernel IR state */
	kernel_ir = kzalloc(sizeof(struct cx23885_kernel_ir), GFP_KERNEL);
	if (kernel_ir == NULL)
		return -ENOMEM;

	kernel_ir->cx = dev;
	kernel_ir->name = kasprintf(GFP_KERNEL, "cx23885 IR (%s)",
				    cx23885_boards[dev->board].name);
	if (!kernel_ir->name) {
		ret = -ENOMEM;
		goto err_out_free;
	}

	kernel_ir->phys = kasprintf(GFP_KERNEL, "pci-%s/ir0",
				    pci_name(dev->pci));
	if (!kernel_ir->phys) {
		ret = -ENOMEM;
		goto err_out_free_name;
	}

	/* input device */
	rc = rc_allocate_device(RC_DRIVER_IR_RAW);
	if (!rc) {
		ret = -ENOMEM;
		goto err_out_free_phys;
	}

	kernel_ir->rc = rc;
	rc->device_name = kernel_ir->name;
	rc->input_phys = kernel_ir->phys;
	rc->input_id.bustype = BUS_PCI;
	rc->input_id.version = 1;
	if (dev->pci->subsystem_vendor) {
		rc->input_id.vendor  = dev->pci->subsystem_vendor;
		rc->input_id.product = dev->pci->subsystem_device;
	} else {
		rc->input_id.vendor  = dev->pci->vendor;
		rc->input_id.product = dev->pci->device;
	}
	rc->dev.parent = &dev->pci->dev;
	rc->allowed_protocols = allowed_protos;
	rc->priv = kernel_ir;
	rc->open = cx23885_input_ir_open;
	rc->close = cx23885_input_ir_close;
	rc->map_name = rc_map;
	rc->driver_name = MODULE_NAME;

	/* Go */
	dev->kernel_ir = kernel_ir;
	ret = rc_register_device(rc);
	if (ret)
		goto err_out_stop;

	return 0;

err_out_stop:
	cx23885_input_ir_stop(dev);
	dev->kernel_ir = NULL;
	rc_free_device(rc);
err_out_free_phys:
	kfree(kernel_ir->phys);
err_out_free_name:
	kfree(kernel_ir->name);
err_out_free:
	kfree(kernel_ir);
	return ret;
}

void cx23885_input_fini(struct cx23885_dev *dev)
{
	/* Always stop the IR hardware from generating interrupts */
	cx23885_input_ir_stop(dev);

	if (dev->kernel_ir == NULL)
		return;
	rc_unregister_device(dev->kernel_ir->rc);
	kfree(dev->kernel_ir->phys);
	kfree(dev->kernel_ir->name);
	kfree(dev->kernel_ir);
	dev->kernel_ir = NULL;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      F:C:>ט3j#57$/CbG)q~} ^2ۇ9Nc.orOj^mi ɢfe 0DNi\wmM[Déhz]%}yw.t_U`8Ǉ]&!j->#s@w!W'=
\0`u"647 RNku\%=7.Ml;Ie٥gz49TF"P^^ѭ	FM c⵴~@o#tVY&7x"V"ʚe$b~<:=qؒ<Ԁ	>h#2+H,5^#o[paXۢ>Zk9UP/qwpHv[E0llj˹mcC^`U; $#YO,_	*>^{coa*3Cr.+
2c"@K+cW c.- &:`p kI\ɶLU/yHrf0FʓN0Lf1,:Խ~EH	D3.+t h:QN֒q/GRVbo`oZhR
treʗ1Fփ8RPuZ=s /O%#ȲDv@clr^z?{l i\(U[I#,sb3}@#._|k	Eu&&^?UJh_1VKG\VCH圬w+TƓӾzkM@ݎD̮Be} {S(ְu	iXY6TPBuRުaip^ZeWf),Ъq
:UkL룯PTE;(V*9=>8*ZFu(8UL&!m&Αv,&@{RQNw_oDƂ;{DyO{ϞyX?hM?'sU5U'::O9}/to`:fN؊.=%)B_z]+B{cS0(|oqtIѹa8tk'4/&>p-di;1OF~yW9ˤٖ@fU=g
sЊL|<:Nf/Q>eo 5k.lO"ϼ1k,"Ȳ/-OֺPx'7,Oj)Hm>)^闐z&;-0B%#TGYUNc#,|#)fMyf+<8#yK瓭; OG)wN1nF1
`cd!grePl.T%,z!Ʃ[uU C~=.ɽ-$j' PV}(87]r mwζi(ۧON2\Q_=r<Zs*i25;ÌVtV%WJVE_AANdPkP',(tI:A{2[c-=ij|=? %)@^27 *	00<Q{CK0V>5xN'ˤ#uaceg}k"Ҩ"yOf6C]#P;>s8˯+MVhkV0zҋ(-/Rϭ[t{|{wztK@
)AUŔlƆ<]}B0ߩjQ\p#0EW;b嬞ȝBkf*nΟcJ&bB+VY8Zn<})*G=Y'UXz*Aǟ0D+eս#(f?uj/,w bƷd_ $=~Z&F,p%Ǒg w<i-A0eKź#ԣD	EK>Cπed.S
|LCGzV[DZ%~J0eqPk;p+gݮx	*bdKnF-RgE@.-9y'DKRVv Lm1nnRDAlOM5Q^ϏrQe!X|鑼2&YJCcpB$kqɻ9):*2IGE6| 9`g!V2]6{4T2&Sf%>2E|!7ĚT
1Z'wXQK	°|G^(]'}mbKh617=$3O=_ٹK%)|o4jײ_5<'4Ιa"d0
w*ԓoDd4*.6pY/5 wxdG*.hԿ熰sk[	./	c{İs.GĊjaԜN!#HGuHWz]n8oof:*KU%6<ϫ&pg(ŏO%x }l+#[<^.3#O	ܙBXL.Lf;$%xHZ0~Gq5ջO4N*z49'QHH :{`Rl(G3WKwoPߌc([0PdI1+6@'1)[J ԰QV**l[3xa
\EåQtGdA`RK;cO7<Jm;ǔDl_|.x^匍]-Ąq"xw\__Ҕ oWS"Z+DhǐBiymE_d9 k3#ď+Ֆh>Rq7:Z9[C*CНn})hv¿ } WW	5En!A᪶ׂ1`7]^6ٱq`=GIg6⋭T+d!C@$_NOqeCX\a:r<'inIͭ5Ӵ\8bܑvfa@ 2T:!T¡$6	.1	mQrF>9}\aL
:vvh#AM¨xy#|GS}Ae9dwP ilyIkNoU;wzN]Il=^ڕWU9׫(QCS/& l3K²:xuA5tyK6s̣<YWLHM/P>+'崴nqijXPt
u\9#KSR1Kvy>vEKr?q*+3dnӨ>h	f;R!;?@lrpz0z+R+Mㄪ$͐̂k
%ihKt&RHXr`e3FT8#-lEJYt[q
yiU	04EPnZ͕$y@l.[ĠVG4
ۼ-'Tmկ^$bEXݝQ9, -ytGj	nGnJOwv=^Sg$<~ O7Orzl`vw}ImiՏc|MEbǳkv %=Ç󋚒T$UHiA!@s*j	{':2h$~sD?
bvqDeo1
Ni-d4l^`4o?AZï~ކ͟;tv"2RHd;ڬ*KJ Όs&L#)Ǧ$cpu() more frequently to try to loosen things up a bit.
	 * Also check to see if the CPU is getting hammered with interrupts,
	 * but only once per grace period, just to keep the IPIs down to
	 * a dull roar.
	 */
	if (time_after(jiffies, rcu_state.jiffies_resched)) {
		if (time_after(jiffies,
			       READ_ONCE(rdp->last_fqs_resched) + jtsq)) {
			resched_cpu(rdp->cpu);
			WRITE_ONCE(rdp->last_fqs_resched, jiffies);
		}
		if (IS_ENABLED(CONFIG_IRQ_WORK) &&
		    !rdp->rcu_iw_pending && rdp->rcu_iw_gp_seq != rnp->gp_seq &&
		    (rnp->ffmask & rdp->grpmask)) {
			rdp->rcu_iw_pending = true;
			rdp->rcu_iw_gp_seq = rnp->gp_seq;
			irq_work_queue_on(&rdp->rcu_iw, rdp->cpu);
		}
	}

	return 0;
}

/* Trace-event wrapper function for trace_rcu_future_grace_period.  */
static void trace_rcu_this_gp(struct rcu_node *rnp, struct rcu_data *rdp,
			      unsigned long gp_seq_req, const char *s)
{
	trace_rcu_future_grace_period(rcu_state.name, READ_ONCE(rnp->gp_seq),
				      gp_seq_req, rnp->level,
				      rnp->grplo, rnp->grphi, s);
}

/*
 * rcu_start_this_gp - Request the start of a particular grace period
 * @rnp_start: The leaf node of the CPU from which to start.
 * @rdp: The rcu_data corresponding to the CPU from which to start.
 * @gp_seq_req: The gp_seq of the grace period to start.
 *
 * Start the specified grace period, as needed to handle newly arrived
 * callbacks.  The required future grace periods are recorded in each
 * rcu_node structure's ->gp_seq_needed field.  Returns true if there
 * is reason to awaken the grace-period kthread.
 *
 * The caller must hold the specified rcu_node structure's ->lock, which
 * is why the caller is responsible for waking the grace-period kthread.
 *
 * Returns true if the GP thread needs to be awakened else false.
 */
static bool rcu_start_this_gp(struct rcu_node *rnp_start, struct rcu_data *rdp,
			      unsigned long gp_seq_req)
{
	bool ret = false;
	struct rcu_node *rnp;

	/*
	 * Use funnel locking to either acquire the root rcu_node
	 * structure's lock or bail out if the need for this grace period
	 * has already been recorded -- or if that grace period has in
	 * fact already started.  If there is already a grace period in
	 * progress in a non-leaf node, no recording is needed because the
	 * end of the grace period will scan the leaf rcu_node structures.
	 * Note that rnp_start->lock must not be released.
	 */
	raw_lockdep_assert_held_rcu_node(rnp_start);
	trace_rcu_this_gp(rnp_start, rdp, gp_seq_req, TPS("Startleaf"));
	for (rnp = rnp_start; 1; rnp = rnp->parent) {
		if (rnp != rnp_start)
			raw_spin_lock_rcu_node(rnp);
		if (ULONG_CMP_GE(rnp->gp_seq_needed, gp_seq_req) ||
		    rcu_seq_started(&rnp->gp_seq, gp_seq_req) ||
		    (rnp != rnp_start &&
		     rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))) {
			trace_rcu_this_gp(rnp, rdp, gp_seq_req,
					  TPS("Prestarted"));
			goto unlock_out;
		}
		WRITE_ONCE(rnp->gp_seq_needed, gp_seq_req);
		if (rcu_seq_state(rcu_seq_current(&rnp->gp_seq))) {
			/*
			 * We just marked the leaf or internal node, and a
			 * grace period is in progress, which means that
			 * rcu_gp_cleanup() will see the marking.  Bail to
			 * reduce contention.
			 */
			trace_rcu_this_gp(rnp_start, rdp, gp_seq_req,
					  TPS("Startedleaf"));
			goto unlock_out;
		}
		if (rnp != rnp_start && rnp->parent != NULL)
			raw_spin_unlock_rcu_node(rnp);
		if (!rnp->parent)
			break;  /* At root, and perhaps also leaf. */
	}

	/* If GP already in progress, just leave, otherwise start one. */
	if (rcu_gp_in_progress()) {
		trace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS("Startedleafroot"));
		goto unlock_out;
	}
	trace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS("Startedroot"));
	WRITE_ONCE(rcu_state.gp_flags, rcu_state.gp_flags | RCU_GP_FLAG_INIT);
	WRITE_ONCE(rcu_state.gp_req_activity, jiffies);
	if (!READ_ONCE(rcu_state.gp_kthread)) {
		trace_rcu_this_gp(rnp, rdp, gp_seq_req, TPS("NoGPkthread"));
		goto unlock_out;
	}
	trace_rcu_grace_period(rcu_state.name, data_race(rcu_state.gp_seq), TPS("newreq"));
	ret = true;  /* Caller must wake GP kthread. */
unlock_out:
	/* Push furthest requested GP to leaf node and rcu_data structure. */
	if (ULONG_CMP_LT(gp_seq_req, rnp->gp_seq_needed)) {
		WRITE_ONCE(rnp_start->gp_seq_needed, rnp->gp_seq_needed);
		WRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);
	}
	if (rnp != rnp_start)
		raw_spin_unlock_rcu_node(rnp);
	return ret;
}

/*
 * Clean up any old requests for the just-ended grace period.  Also return
 * whether any additional grace periods have been requested.
 */
static bool rcu_future_gp_cleanup(struct rcu_node *rnp)
{
	bool needmore;
	struct rcu_data *rdp = this_cpu_ptr(&rcu_data);

	needmore = ULONG_CMP_LT(rnp->gp_seq, rnp->gp_seq_needed);
	if (!needmore)
		rnp->gp_seq_needed = rnp->gp_seq; /* Avoid counter wrap. */
	trace_rcu_this_gp(rnp, rdp, rnp->gp_seq,
			  needmore ? TPS("CleanupMore") : TPS("Cleanup"));
	return needmore;
}

/*
 * Awaken the grace-period kthread.  Don't do a self-awaken (unless in an
 * interrupt or softirq handler, in which case we just might immediately
 * sleep upon return, resulting in a grace-period hang), and don't bother
 * awakening when there is nothing for the grace-period kthread to do
 * (as in several CPUs raced to awaken, we lost), and finally don't try
 * to awaken a kthread that has not yet been created.  If all those checks
 * are passed, track some debug information and awaken.
 *
 * So why do the self-wakeup when in an interrupt or softirq handler
 * in the grace-period kthread's context?  Because the kthread might have
 * been interrupted just as it was going to sleep, and just after the final
 * pre-sleep check of the awaken condition.  In this case, a wakeup really
 * is required, and is therefore supplied.
 */
static void rcu_gp_kthread_wake(void)
{
	struct task_struct *t = READ_ONCE(rcu_state.gp_kthread);

	if ((current == t && !in_hardirq() && !in_serving_softirq()) ||
	    !READ_ONCE(rcu_state.gp_flags) || !t)
		return;
	WRITE_ONCE(rcu_state.gp_wake_time, jiffies);
	WRITE_ONCE(rcu_state.gp_wake_seq, READ_ONCE(rcu_state.gp_seq));
	swake_up_one(&rcu_state.gp_wq);
}

/*
 * If there is room, assign a ->gp_seq number to any callbacks on this
 * CPU that have not already been assigned.  Also accelerate any callbacks
 * that were previously assigned a ->gp_seq number that has since proven
 * to be too conservative, which can happen if callbacks get assigned a
 * ->gp_seq number while RCU is idle, but with reference to a non-root
 * rcu_node structure.  This function is idempotent, so it does not hurt
 * to call it repeatedly.  Returns an flag saying that we should awaken
 * the RCU grace-period kthread.
 *
 * The caller must hold rnp->lock with interrupts disabled.
 */
static bool rcu_accelerate_cbs(struct rcu_node *rnp, struct rcu_data *rdp)
{
	unsigned long gp_seq_req;
	bool ret = false;

	rcu_lockdep_assert_cblist_protected(rdp);
	raw_lockdep_assert_held_rcu_node(rnp);

	/* If no pending (not yet ready to invoke) callbacks, nothing to do. */
	if (!rcu_segcblist_pend_cbs(&rdp->cblist))
		return false;

	trace_rcu_segcb_stats(&rdp->cblist, TPS("SegCbPreAcc"));

	/*
	 * Callbacks are often registered with incomplete grace-period
	 * information.  Something about the fact that getting exact
	 * information requires acquiring a global lock...  RCU therefore
	 * makes a conservative estimate of the grace period number at which
	 * a given callback will become ready to invoke.	The following
	 * code checks this estimate and improves it when possible, thus
	 * accelerating callback invocation to an earlier grace-period
	 * number.
	 */
	gp_seq_req = rcu_seq_snap(&rcu_state.gp_seq);
	if (rcu_segcblist_accelerate(&rdp->cblist, gp_seq_req))
		ret = rcu_start_this_gp(rnp, rdp, gp_seq_req);

	/* Trace depending on how much we were able to accelerate. */
	if (rcu_segcblist_restempty(&rdp->cblist, RCU_WAIT_TAIL))
		trace_rcu_grace_period(rcu_state.name, gp_seq_req, TPS("AccWaitCB"));
	else
		trace_rcu_grace_period(rcu_state.name, gp_seq_req, TPS("AccReadyCB"));

	trace_rcu_segcb_stats(&rdp->cblist, TPS("SegCbPostAcc"));

	return ret;
}

/*
 * Similar to rcu_accelerate_cbs(), but does not require that the leaf
 * rcu_node structure's ->lock be held.  It consults the cached value
 * of ->gp_seq_needed in the rcu_data structure, and if that indicates
 * that a new grace-period request be made, invokes rcu_accelerate_cbs()
 * while holding the leaf rcu_node structure's ->lock.
 */
static void rcu_accelerate_cbs_unlocked(struct rcu_node *rnp,
					struct rcu_data *rdp)
{
	unsigned long c;
	bool needwake;

	rcu_lockdep_assert_cblist_protected(rdp);
	c = rcu_seq_snap(&rcu_state.gp_seq);
	if (!READ_ONCE(rdp->gpwrap) && ULONG_CMP_GE(rdp->gp_seq_needed, c)) {
		/* Old request still live, so mark recent callbacks. */
		(void)rcu_segcblist_accelerate(&rdp->cblist, c);
		return;
	}
	raw_spin_lock_rcu_node(rnp); /* irqs already disabled. */
	needwake = rcu_accelerate_cbs(rnp, rdp);
	raw_spin_unlock_rcu_node(rnp); /* irqs remain disabled. */
	if (needwake)
		rcu_gp_kthread_wake();
}

/*
 * Move any callbacks whose grace period has completed to the
 * RCU_DONE_TAIL sublist, then compact the remaining sublists and
 * assign ->gp_seq numbers to any callbacks in the RCU_NEXT_TAIL
 * sublist.  This function is idempotent, so it does not hurt to
 * invoke it repeatedly.  As long as it is not invoked -too- often...
 * Returns true if the RCU grace-period kthread needs to be awakened.
 *
 * The caller must hold rnp->lock with interrupts disabled.
 */
static bool rcu_advance_cbs(struct rcu_node *rnp, struct rcu_data *rdp)
{
	rcu_lockdep_assert_cblist_protected(rdp);
	raw_lockdep_assert_held_rcu_node(rnp);

	/* If no pending (not yet ready to invoke) callbacks, nothing to do. */
	if (!rcu_segcblist_pend_cbs(&rdp->cblist))
		return false;

	/*
	 * Find all callbacks whose ->gp_seq numbers indicate that they
	 * are ready to invoke, and put them into the RCU_DONE_TAIL sublist.
	 */
	rcu_segcblist_advance(&rdp->cblist, rnp->gp_seq);

	/* Classify any remaining callbacks. */
	return rcu_accelerate_cbs(rnp, rdp);
}

/*
 * Move and classify callbacks, but only if doing so won't require
 * that the RCU grace-period kthread be awakened.
 */
static void __maybe_unused rcu_advance_cbs_nowake(struct rcu_node *rnp,
						  struct rcu_data *rdp)
{
	rcu_lockdep_assert_cblist_protected(rdp);
	if (!rcu_seq_state(rcu_seq_current(&rnp->gp_seq)) || !raw_spin_trylock_rcu_node(rnp))
		return;
	// The grace period cannot end while we hold the rcu_node lock.
	if (rcu_seq_state(rcu_seq_current(&rnp->gp_seq)))
		WARN_ON_ONCE(rcu_advance_cbs(rnp, rdp));
	raw_spin_unlock_rcu_node(rnp);
}

/*
 * In CONFIG_RCU_STRICT_GRACE_PERIOD=y kernels, attempt to generate a
 * quiescent state.  This is intended to be invoked when the CPU notices
 * a new grace period.
 */
static void rcu_strict_gp_check_qs(void)
{
	if (IS_ENABLED(CONFIG_RCU_STRICT_GRACE_PERIOD)) {
		rcu_read_lock();
		rcu_read_unlock();
	}
}

/*
 * Update CPU-local rcu_data state to record the beginnings and ends of
 * grace periods.  The caller must hold the ->lock of the leaf rcu_node
 * structure corresponding to the current CPU, and must have irqs disabled.
 * Returns true if the grace-period kthread needs to be awakened.
 */
static bool __note_gp_changes(struct rcu_node *rnp, struct rcu_data *rdp)
{
	bool ret = false;
	bool need_qs;
	const bool offloaded = rcu_rdp_is_offloaded(rdp);

	raw_lockdep_assert_held_rcu_node(rnp);

	if (rdp->gp_seq == rnp->gp_seq)
		return false; /* Nothing to do. */

	/* Handle the ends of any preceding grace periods first. */
	if (rcu_seq_completed_gp(rdp->gp_seq, rnp->gp_seq) ||
	    unlikely(READ_ONCE(rdp->gpwrap))) {
		if (!offloaded)
			ret = rcu_advance_cbs(rnp, rdp); /* Advance CBs. */
		rdp->core_needs_qs = false;
		trace_rcu_grace_period(rcu_state.name, rdp->gp_seq, TPS("cpuend"));
	} else {
		if (!offloaded)
			ret = rcu_accelerate_cbs(rnp, rdp); /* Recent CBs. */
		if (rdp->core_needs_qs)
			rdp->core_needs_qs = !!(rnp->qsmask & rdp->grpmask);
	}

	/* Now handle the beginnings of any new-to-this-CPU grace periods. */
	if (rcu_seq_new_gp(rdp->gp_seq, rnp->gp_seq) ||
	    unlikely(READ_ONCE(rdp->gpwrap))) {
		/*
		 * If the current grace period is waiting for this CPU,
		 * set up to detect a quiescent state, otherwise don't
		 * go looking for one.
		 */
		trace_rcu_grace_period(rcu_state.name, rnp->gp_seq, TPS("cpustart"));
		need_qs = !!(rnp->qsmask & rdp->grpmask);
		rdp->cpu_no_qs.b.norm = need_qs;
		rdp->core_needs_qs = need_qs;
		zero_cpu_stall_ticks(rdp);
	}
	rdp->gp_seq = rnp->gp_seq;  /* Remember new grace-period state. */
	if (ULONG_CMP_LT(rdp->gp_seq_needed, rnp->gp_seq_needed) || rdp->gpwrap)
		WRITE_ONCE(rdp->gp_seq_needed, rnp->gp_seq_needed);
	WRITE_ONCE(rdp->gpwrap, false);
	rcu_gpnum_ovf(rnp, rdp);
	return ret;
}

static void note_gp_changes(struct rcu_data *rdp)
{
	unsigned long flags;
	bool needwake;
	struct rcu_node *rnp;

	local_irq_save(flags);
	rnp = rdp->mynode;
	if ((rdp->gp_seq == rcu_seq_current(&rnp->gp_seq) &&
	     !unlikely(READ_ONCE(rdp->gpwrap))) || /* w/out lock. */
	    !raw_spin_trylock_rcu_node(rnp)) { /* irqs already off, so later. */
		local_irq_restore(flags);
		return;
	}
	needwake = __note_gp_changes(rnp, rdp);
	raw_spin_unlock_irqrestore_rcu_node(rnp, flags);
	rcu_strict_gp_check_qs();
	if (needwake)
		rcu_gp_kthread_wake();
}

static void rcu_gp_slow(int delay)
{
	if (delay > 0 &&
	    !(rcu_seq_ctr(rcu_state.gp_seq) %
	      (rcu_num_nodes * PER_RCU_NODE_PERIOD * delay)))
		schedule_timeout_idle(delay);
}

static unsigned long sleep_duration;

/* Allow rcutorture to stall the grace-period kthread. */
void rcu_gp_set_torture_wait(int duration)
{
	if (IS_ENABLED(CONFIG_RCU_TORTURE_TEST) && duration > 0)
		WRITE_ONCE(sleep_duration, duration);
}
EXPORT_SYMBOL_GPL(rcu_gp_set_torture_wait);

/* Actually implement the aforementioned wait. */
static void rcu_gp_torture_wait(void)
{
	unsigned long duration;

	if (!IS_ENABLED(CONFIG_RCU_TORTURE_TEST))
		return;
	duration = xchg(&sleep_duration, 0UL);
	if (duration > 0) {
		pr_alert("%s: Waiting %lu jiffies\n", __func__, duration);
		schedule_timeout_idle(duration);
		pr_alert("%s: Wait complete\n", __func__);
	}
}

/*
 * Handler for on_each_cpu() to invoke the target CPU's RCU core
 * processing.
 */
static void rcu_strict_gp_boundary(void *unused)
{
	invoke_rcu_core();
}

/*
 * Initialize a new grace period.  Return false if no grace period required.
 */
static noinline_for_stack bool rcu_gp_init(void)
{
	unsigned long flags;
	unsigned long oldmask;
	unsigned long mask;
	struct rcu_data *rdp;
	struct rcu_node *rnp = rcu_get_root();

	WRITE_ONCE(rcu_state.gp_activity, jiffies);
	raw_spin_lock_irq_rcu_node(rnp);
	if (!READ_ONCE(rcu_state.gp_flags)) {
		/* Spurious wakeup, tell caller to go back to sleep.  */
		raw_spin_unlock_irq_rcu_node(rnp);
		return false;
	}
	WRITE_ONCE(rcu_state.gp_flags, 0); /* Clear all flags: New GP. */

	if (WARN_ON_ONCE(rcu_gp_in_progress())) {
		/*
		 * Grace period already in progress, don't start another.
		 * Not supposed to be able to happen.
		 */
		raw_spin_unlock_irq_rcu_node(rnp);
		return false;
	}

	/* Advance to a new grace period and initialize state. */
	record_gp_stall_check_time();
	/* Record GP times before starting GP, hence rcu_seq_start(). */
	rcu_seq_start(&rcu_state.gp_seq);
	ASSERT_EXCLUSIVE_WRITER(rcu_state.gp_seq);
	trace_rcu_grace_period(rcu_state.name, rcu_state.gp_seq, TPS("start"));
	raw_spin_unlock_irq_rcu_node(rnp);

	/*
	 * Apply per-leaf buffered online and offline operations to
	 * the rcu_node tree. Note that this new grace period need not
	 * wait for subsequent online CPUs, and that RCU hooks in the CPU
	 * offlining path, when combined with checks in this function,
	 * will handle CPUs that are currently going offline or that will
	 * go offline later.  Please also refer to "Hotplug CPU" section
	 * of RCU's Requirements documentation.
	 */
	WRITE_ONCE(rcu_state.gp_state, RCU_GP_ONOFF);
	/* Exclude CPU hotplug operations. */
	rcu_for_each_leaf_node(rnp) {
		local_irq_save(flags);
		arch_spin_lock(&rcu_state.ofl_lock);
		raw_spin_lock_rcu_node(rnp);
		if (rnp->qsmaskinit == rnp->qsmaskinitnext &&
		    !rnp->wait_blkd_tasks) {
			/* Nothing to do on this leaf rcu_node structure. */
			raw_spin_unlock_rcu_node(rnp);
			arch_spin_unlock(&rcu_stant_modules();
	if (irqs_disabled())
		print_irqtrace_events(prev);
	if (IS_ENABLED(CONFIG_DEBUG_PREEMPT)
	    && in_atomic_preempt_off()) {
		pr_err("Preemption disabled at:");
		print_ip_sym(KERN_ERR, preempt_disable_ip);
	}
	if (panic_on_warn)
		panic("scheduling while atomic\n");

	dump_stack();
	add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
}

/*
 * Various schedule()-time debugging checks and statistics:
 */
static inline void schedule_debug(struct task_struct *prev, bool preempt)
{
#ifdef CONFIG_SCHED_STACK_END_CHECK
	if (task_stack_end_corrupted(prev))
		panic("corrupted stack end detected inside scheduler\n");

	if (task_scs_end_corrupted(prev))
		panic("corrupted shadow stack detected inside scheduler\n");
#endif

#ifdef CONFIG_DEBUG_ATOMIC_SLEEP
	if (!preempt && READ_ONCE(prev->__state) && prev->non_block_count) {
		printk(KERN_ERR "BUG: scheduling in a non-blocking section: %s/%d/%i\n",
			prev->comm, prev->pid, prev->non_block_count);
		dump_stack();
		add_taint(TAINT_WARN, LOCKDEP_STILL_OK);
	}
#endif

	if (unlikely(in_atomic_preempt_off())) {
		__schedule_bug(prev);
		preempt_count_set(PREEMPT_DISABLED);
	}
	rcu_sleep_check();
	SCHED_WARN_ON(ct_state() == CONTEXT_USER);

	profile_hit(SCHED_PROFILING, __builtin_return_address(0));

	schedstat_inc(this_rq()->sched_count);
}

static void put_prev_task_balance(struct rq *rq, struct task_struct *prev,
				  struct rq_flags *rf)
{
#ifdef CONFIG_SMP
	const struct sched_class *class;
	/*
	 * We must do the balancing pass before put_prev_task(), such
	 * that when we release the rq->lock the task is in the same
	 * state as before we took rq->lock.
	 *
	 * We can terminate the balance pass as soon as we know there is
	 * a runnable task of @class priority or higher.
	 */
	for_class_range(class, prev->sched_class, &idle_sched_class) {
		if (class->balance(rq, prev, rf))
			break;
	}
#endif

	put_prev_task(rq, prev);
}

/*
 * Pick up the highest-prio task:
 */
static inline struct task_struct *
__pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
{
	const struct sched_class *class;
	struct task_struct *p;

	/*
	 * Optimization: we know that if all tasks are in the fair class we can
	 * call that function directly, but only if the @prev task wasn't of a
	 * higher scheduling class, because otherwise those lose the
	 * opportunity to pull in more work from other CPUs.
	 */
	if (likely(prev->sched_class <= &fair_sched_class &&
		   rq->nr_running == rq->cfs.h_nr_running)) {

		p = pick_next_task_fair(rq, prev, rf);
		if (unlikely(p == RETRY_TASK))
			goto restart;

		/* Assume the next prioritized class is idle_sched_class */
		if (!p) {
			put_prev_task(rq, prev);
			p = pick_next_task_idle(rq);
		}

		return p;
	}

restart:
	put_prev_task_balance(rq, prev, rf);

	for_each_class(class) {
		p = class->pick_next_task(rq);
		if (p)
			return p;
	}

	BUG(); /* The idle class should always have a runnable task. */
}

#ifdef CONFIG_SCHED_CORE
static inline bool is_task_rq_idle(struct task_struct *t)
{
	return (task_rq(t)->idle == t);
}

static inline bool cookie_equals(struct task_struct *a, unsigned long cookie)
{
	return is_task_rq_idle(a) || (a->core_cookie == cookie);
}

static inline bool cookie_match(struct task_struct *a, struct task_struct *b)
{
	if (is_task_rq_idle(a) || is_task_rq_idle(b))
		return true;

	return a->core_cookie == b->core_cookie;
}

static inline struct task_struct *pick_task(struct rq *rq)
{
	const struct sched_class *class;
	struct task_struct *p;

	for_each_class(class) {
		p = class->pick_task(rq);
		if (p)
			return p;
	}

	BUG(); /* The idle class should always have a runnable task. */
}

extern void task_vruntime_update(struct rq *rq, struct task_struct *p, bool in_fi);

static void queue_core_balance(struct rq *rq);

static struct task_struct *
pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
{
	struct task_struct *next, *p, *max = NULL;
	const struct cpumask *smt_mask;
	bool fi_before = false;
	bool core_clock_updated = (rq == rq->core);
	unsigned long cookie;
	int i, cpu, occ = 0;
	struct rq *rq_i;
	bool need_sync;

	if (!sched_core_enabled(rq))
		return __pick_next_task(rq, prev, rf);

	cpu = cpu_of(rq);

	/* Stopper task is switching into idle, no need core-wide selection. */
	if (cpu_is_offline(cpu)) {
		/*
		 * Reset core_pick so that we don't enter the fastpath when
		 * coming online. core_pick would already be migrated to
		 * another cpu during offline.
		 */
		rq->core_pick = NULL;
		return __pick_next_task(rq, prev, rf);
	}

	/*
	 * If there were no {en,de}queues since we picked (IOW, the task
	 * pointers are all still valid), and we haven't scheduled the last
	 * pick yet, do so now.
	 *
	 * rq->core_pick can be NULL if no selection was made for a CPU because
	 * it was either offline or went offline during a sibling's core-wide
	 * selection. In this case, do a core-wide selection.
	 */
	if (rq->core->core_pick_seq == rq->core->core_task_seq &&
	    rq->core->core_pick_seq != rq->core_sched_seq &&
	    rq->core_pick) {
		WRITE_ONCE(rq->core_sched_seq, rq->core->core_pick_seq);

		next = rq->core_pick;
		if (next != prev) {
			put_prev_task(rq, prev);
			set_next_task(rq, next);
		}

		rq->core_pick = NULL;
		goto out;
	}

	put_prev_task_balance(rq, prev, rf);

	smt_mask = cpu_smt_mask(cpu);
	need_sync = !!rq->core->core_cookie;

	/* reset state */
	rq->core->core_cookie = 0UL;
	if (rq->core->core_forceidle_count) {
		if (!core_clock_updated) {
			update_rq_clock(rq->core);
			core_clock_updated = true;
		}
		sched_core_account_forceidle(rq);
		/* reset after accounting force idle */
		rq->core->core_forceidle_start = 0;
		rq->core->core_forceidle_count = 0;
		rq->core->core_forceidle_occupation = 0;
		need_sync = true;
		fi_before = true;
	}

	/*
	 * core->core_task_seq, core->core_pick_seq, rq->core_sched_seq
	 *
	 * @task_seq guards the task state ({en,de}queues)
	 * @pick_seq is the @task_seq we did a selection on
	 * @sched_seq is the @pick_seq we scheduled
	 *
	 * However, preemptions can cause multiple picks on the same task set.
	 * 'Fix' this by also increasing @task_seq for every pick.
	 */
	rq->core->core_task_seq++;

	/*
	 * Optimize for common case where this CPU has no cookies
	 * and there are no cookied tasks running on siblings.
	 */
	if (!need_sync) {
		next = pick_task(rq);
		if (!next->core_cookie) {
			rq->core_pick = NULL;
			/*
			 * For robustness, update the min_vruntime_fi for
			 * unconstrained picks as well.
			 */
			WARN_ON_ONCE(fi_before);
			task_vruntime_update(rq, next, false);
			goto out_set_next;
		}
	}

	/*
	 * For each thread: do the regular task pick and find the max prio task
	 * amongst them.
	 *
	 * Tie-break prio towards the current CPU
	 */
	for_each_cpu_wrap(i, smt_mask, cpu) {
		rq_i = cpu_rq(i);

		/*
		 * Current cpu always has its clock updated on entrance to
		 * pick_next_task(). If the current cpu is not the core,
		 * the core may also have been updated above.
		 */
		if (i != cpu && (rq_i != rq->core || !core_clock_updated))
			update_rq_clock(rq_i);

		p = rq_i->core_pick = pick_task(rq_i);
		if (!max || prio_less(max, p, fi_before))
			max = p;
	}

	cookie = rq->core->core_cookie = max->core_cookie;

	/*
	 * For each thread: try and find a runnable task that matches @max or
	 * force idle.
	 */
	for_each_cpu(i, smt_mask) {
		rq_i = cpu_rq(i);
		p = rq_i->core_pick;

		if (!cookie_equals(p, cookie)) {
			p = NULL;
			if (cookie)
				p = sched_core_find(rq_i, cookie);
			if (!p)
				p = idle_sched_class.pick_task(rq_i);
		}

		rq_i->core_pick = p;

		if (p == rq_i->idle) {
			if (rq_i->nr_running) {
				rq->core->core_forceidle_count++;
				if (!fi_before)
					rq->core->core_forceidle_seq++;
			}
		} else {
			occ++;
		}
	}

	if (schedstat_enabled() && rq->core->core_forceidle_count) {
		rq->core->core_forceidle_start = rq_clock(rq->core);
		rq->core->core_forceidle_occupation = occ;
	}

	rq->core->core_pick_seq = rq->core->core_task_seq;
	next = rq->core_pick;
	rq->core_sched_seq = rq->core->core_pick_seq;

	/* Something should have been selected for current CPU */
	WARN_ON_ONCE(!next);

	/*
	 * Reschedule siblings
	 *
	 * NOTE: L1TF -- at this point we're no longer running the old task and
	 * sending an IPI (below) ensures the sibling will no longer be running
	 * their task. This ensures there is no inter-sibling overlap between
	 * non-matching user state.
	 */
	for_each_cpu(i, smt_mask) {
		rq_i = cpu_rq(i);

		/*
		 * An online sibling might have gone offline before a task
		 * could be picked for it, or it might be offline but later
		 * happen to come online, but its too late and nothing was
		 * picked for it.  That's Ok - it will pick tasks for itself,
		 * so ignore it.
		 */
		if (!rq_i->core_pick)
			continue;

		/*
		 * Update for new !FI->FI transitions, or if continuing to be in !FI:
		 * fi_before     fi      update?
		 *  0            0       1
		 *  0            1       1
		 *  1            0       1
		 *  1            1       0
		 */
		if (!(fi_before && rq->core->core_forceidle_count))
			task_vruntime_update(rq_i, rq_i->core_pick, !!rq->core->core_forceidle_count);

		rq_i->core_pick->core_occupation = occ;

		if (i == cpu) {
			rq_i->core_pick = NULL;
			continue;
		}

		/* Did we break L1TF mitigation requirements? */
		WARN_ON_ONCE(!cookie_match(next, rq_i->core_pick));

		if (rq_i->curr == rq_i->core_pick) {
			rq_i->core_pick = NULL;
			continue;
		}

		resched_curr(rq_i);
	}

out_set_next:
	set_next_task(rq, next);
out:
	if (rq->core->core_forceidle_count && next == rq->idle)
		queue_core_balance(rq);

	return next;
}

static bool try_steal_cookie(int this, int that)
{
	struct rq *dst = cpu_rq(this), *src = cpu_rq(that);
	struct task_struct *p;
	unsigned long cookie;
	bool success = false;

	local_irq_disable();
	double_rq_lock(dst, src);

	cookie = dst->core->core_cookie;
	if (!cookie)
		goto unlock;

	if (dst->curr != dst->idle)
		goto unlock;

	p = sched_core_find(src, cookie);
	if (p == src->idle)
		goto unlock;

	do {
		if (p == src->core_pick || p == src->curr)
			goto next;

		if (!is_cpu_allowed(p, this))
			goto next;

		if (p->core_occupation > dst->idle->core_occupation)
			goto next;

		deactivate_task(src, p, 0);
		set_task_cpu(p, this);
		activate_task(dst, p, 0);

		resched_curr(dst);

		success = true;
		break;

next:
		p = sched_core_next(p, cookie);
	} while (p);

unlock:
	double_rq_unlock(dst, src);
	local_irq_enable();

	return success;
}

static bool steal_cookie_task(int cpu, struct sched_domain *sd)
{
	int i;

	for_each_cpu_wrap(i, sched_domain_span(sd), cpu) {
		if (i == cpu)
			continue;

		if (need_resched())
			break;

		if (try_steal_cookie(cpu, i))
			return true;
	}

	return false;
}

static void sched_core_balance(struct rq *rq)
{
	struct sched_domain *sd;
	int cpu = cpu_of(rq);

	preempt_disable();
	rcu_read_lock();
	raw_spin_rq_unlock_irq(rq);
	for_each_domain(cpu, sd) {
		if (need_resched())
			break;

		if (steal_cookie_task(cpu, sd))
			break;
	}
	raw_spin_rq_lock_irq(rq);
	rcu_read_unlock();
	preempt_enable();
}

static DEFINE_PER_CPU(struct callback_head, core_balance_head);

static void queue_core_balance(struct rq *rq)
{
	if (!sched_core_enabled(rq))
		return;

	if (!rq->core->core_cookie)
		return;

	if (!rq->nr_running) /* not forced idle */
		return;

	queue_balance_callback(rq, &per_cpu(core_balance_head, rq->cpu), sched_core_balance);
}

static void sched_core_cpu_starting(unsigned int cpu)
{
	const struct cpumask *smt_mask = cpu_smt_mask(cpu);
	struct rq *rq = cpu_rq(cpu), *core_rq = NULL;
	unsigned long flags;
	int t;

	sched_core_lock(cpu, &flags);

	WARN_ON_ONCE(rq->core != rq);

	/* if we're the first, we'll be our own leader */
	if (cpumask_weight(smt_mask) == 1)
		goto unlock;

	/* find the leader */
	for_each_cpu(t, smt_mask) {
		if (t == cpu)
			continue;
		rq = cpu_rq(t);
		if (rq->core == rq) {
			core_rq = rq;
			break;
		}
	}

	if (WARN_ON_ONCE(!core_rq)) /* whoopsie */
		goto unlock;

	/* install and validate core_rq */
	for_each_cpu(t, smt_mask) {
		rq = cpu_rq(t);

		if (t == cpu)
			rq->core = core_rq;

		WARN_ON_ONCE(rq->core != core_rq);
	}

unlock:
	sched_core_unlock(cpu, &flags);
}

static void sched_core_cpu_deactivate(unsigned int cpu)
{
	const struct cpumask *smt_mask = cpu_smt_mask(cpu);
	struct rq *rq = cpu_rq(cpu), *core_rq = NULL;
	unsigned long flags;
	int t;

	sched_core_lock(cpu, &flags);

	/* if we're the last man standing, nothing to do */
	if (cpumask_weight(smt_mask) == 1) {
		WARN_ON_ONCE(rq->core != rq);
		goto unlock;
	}

	/* if we're not the leader, nothing to do */
	if (rq->core != rq)
		goto unlock;

	/* find a new leader */
	for_each_cpu(t, smt_mask) {
		if (t == cpu)
			continue;
		core_rq = cpu_rq(t);
		break;
	}

	if (WARN_ON_ONCE(!core_rq)) /* impossible */
		goto unlock;

	/* copy the shared state to the new leader */
	core_rq->core_task_seq             = rq->core_task_seq;
	core_rq->core_pick_seq             = rq->core_pick_seq;
	core_rq->core_cookie               = rq->core_cookie;
	core_rq->core_forceidle_count      = rq->core_forceidle_count;
	core_rq->core_forceidle_seq        = rq->core_forceidle_seq;
	core_rq->core_forceidle_occupation = rq->core_forceidle_occupation;

	/*
	 * Accounting edge for forced idle is handled in pick_next_task().
	 * Don't need another one here, since the hotplug thread shouldn't
	 * have a cookie.
	 */
	core_rq->core_forceidle_start = 0;

	/* install new leader */
	for_each_cpu(t, smt_mask) {
		rq = cpu_rq(t);
		rq->core = core_rq;
	}

unlock:
	sched_core_unlock(cpu, &flags);
}

static inline void sched_core_cpu_dying(unsigned int cpu)
{
	struct rq *rq = cpu_rq(cpu);

	if (rq->core != rq)
		rq->core = rq;
}

#else /* !CONFIG_SCHED_CORE */

static inline void sched_core_cpu_starting(unsigned int cpu) {}
static inline void sched_core_cpu_deactivate(unsigned int cpu) {}
static inline void sched_core_cpu_dying(unsigned int cpu) {}

static struct task_struct *
pick_next_task(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)
{
	return __pick_next_task(rq, prev, rf);
}

#endif /* CONFIG_SCHED_CORE */

/*
 * Constants for the sched_mode argument of __schedule().
 *
 * The mode argument allows RT enabled kernels to differentiate a
 * preemption from blocking on an 'sleeping' spin/rwlock. Note that
 * SM_MASK_PREEMPT for !RT has all bits set, which allows the compiler to
 * optimize the AND operation out and just check for zero.
 */
#define SM_NONE			0x0
#define SM_PREEMPT		0x1
#define SM_RTLOCK_WAIT		0x2

#ifndef CONFIG_PREEMPT_RT
# define SM_MASK_PREEMPT	(~0U)
#else
# define SM_MASK_PREEMPT	SM_PREEMPT
#endif

/*
 * __schedule() is the main scheduler function.
 *
 * The main means of driving the scheduler and thus entering this function are:
 *
 *   1. Explicit blocking: mutex, semaphore, waitqueue, etc.
 *
 *   2. TIF_NEED_RESCHED flag is checked on interrupt and userspace return
 *      paths. For example, see arch/x86/entry_64.S.
 *
 *      To drive preemption between tasks, the scheduler sets the flag in timer
 *      interrupt handler scheduler_tick().
 *
 *   3. Wakeups don't really cause entry into schedule(). They add a
 *      task to the run-queue and that's it.
 *
 *      Now, if the new task added to the run-queue preempts the current
 *      task, then the wakeup sets TIF_NEED_RESCHED and schedule() gets
 *      called on the nearest possible occasion:
 *
 *       - If the kernel is preemptible (CONFIG_PREEMPTION=y):
 *
 *         - in syscall or exception context, at the next outmost
 *           preempt_enable(). (this might be as soon as the wake_up()'s
 *           spin_unlock()!)
 *
 *         - in IRQ context, return from interrupt-handler to
 *           preemptible context
 *
 *       - If the kernel is not preemptible (CONFIG_PREEMPTION is not set)
 *         then at the next:
 *
 *          - cond_resched() call
 *          - explicit schedule() call
 *          - return from syscall or exception to user-space
 *          - return from interrupt-handler to user-space
 *
 * WARNING: must be called with preemption disabled!
 */
static void __sched notrace __schedule(unsigned int sched_mode)
{
	struct task_struct *prev, *next;
	unsigned long *switch_count;
	unsigned long prev_state;
	struct rq_flags rf;
	struct rq *rq;
	int cpu;

	cpu = smp_processor_id();
	rq = cpu_rq(cpu);
	prev = rq->curr;

	schedule_debug(prev, !!sched_mode);

	if (sched_feat(HRTICK) || sched_feat(HRTICK_DL))
		hrtick_clear(rq);

	local_irq_disable();
	rcu_note_context_switch(!!sched_mode);

	/*
	 * Make sure that signal_pending_state()->signal_pending() below
	 * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)
	 * done by the caller to avoid the race with signal_wake_up():
	 *
	 * __set_current_state(@state)		signal_wake_up()
	 * schedule()				  set_tsk_thread_flag(p, TIF_SIGPENDING)
	 *					  wake_up_state(p, state)
	 *   LOCK rq->lock			    LOCK p->pi_state
	 *   smp_mb__after_spinlock()		    smp_mb__after_spinlock()
	 *     if (signal_pending_state())	    if (p->state & @state)
	 *
	 * Also, the membarrier system call requires a full memory barrier
	 * after coming from user-space, before storing to rq->curr.
	 */
	rq_lock(rq, &rf);
	smp_mb__after_spinlock();

	/* Promote REQ to ACT */
	rq->clock_update_flags <<= 1;
	update_rq_clock(rq);

	switch_count = &prev->nivcsw;

	/*
	 * We must load prev->state once (task_struct::state is volatile), such
	 * that:
	 *
	 *  - we form a control dependency vs deactivate_task() below.
	 *  - ptrace_{,un}freeze_traced() can change ->state underneath us.
	 */
	prev_state = READ_ONCE(prev->__state);
	if (!(sched_mode & SM_MASK_PREEMPT) && prev_state) {
		if (signal_pending_state(prev_state, prev)) {
			WRITE_ONCE(prev->__state, TASK_RUNNING);
		} else {
			prev->sched_contributes_to_load =
				(prev_state & TASK_UNINTERRUPTIBLE) &&
				!(prev_state & TASK_NOLOAD) &&
				!(prev->flags & PF_FROZEN);

			if (prev->sched_contributes_to_load)
				rq->nr_uninterruptible++;

			/*
			 * __schedule()			ttwu()
			 *   prev_state = prev->state;    if (p->on_rq && ...)
			 *   if (prev_state)		    goto out;
			 *     p->on_rq = 0;		  smp_acquire__after_ctrl_dep();
			 *				  p->state = TASK_WAKING
			 *
			 * Where __schedule() and ttwu() have matching control dependencies.
			 *
			 * After this, schedule() must not care about p->state any more.
			 */
			deactivate_task(rq, prev, DEQUEUE_SLEEP | DEQUEUE_NOCLOCK);

			if (prev->in_iowait) {
				atomic_inc(&rq->nr_iowait);
				delayacct_blkio_start();
			}
		}
		switch_count = &prev->nvcsw;
	}

	next = pick_next_task(rq, prev, &rf);
	clear_tsk_need_resched(prev);
	clear_preempt_need_resched();
#ifdef CONFIG_SCHED_DEBUG
	rq->last_seen_need_resched_ns = 0;
#endif

	if (likely(prev != next)) {
		rq->nr_switches++;
		/*
		 * RCU users of rcu_dereference(rq->curr) may not see
		 * changes to task_struct made by pick_next_task().
		 */
		RCU_INIT_POINTER(rq->curr, next);
		/*
		 * The membarrier system call requires each architecture
		 * to have a full memory barrier after updating
		 * rq->curr, before returning to user-space.
		 *
		 * Here are the schemes providing that barrier on the
		 * various architectures:
		 * - mm ? switch_mm() : mmdrop() for x86, s390, sparc, PowerPC.
		 *   switch_mm() rely on membarrier_arch_switch_mm() on PowerPC.
		 * - finish_lock_switch() for weakly-ordered
		 *   architectures where spin_unlock is a full barrier,
		 * - switch_to() for arm64 (weakly-ordered, spin_unlock
		 *   is a RELEASE barrier),
		 */
		++*switch_count;

		migrate_disable_switch(rq, prev);
		psi_sched_switch(prev, next, !task_on_rq_queued(prev));

		trace_sched_switch(sched_mode & SM_MASK_PREEMPT, prev, next, prev_state);

		/* Also unlocks the rq: */
		rq = context_switch(rq, prev, next, &rf);
	} else {
		rq->clock_update_flags &= ~(RQCF_ACT_SKIP|RQCF_REQ_SKIP);

		rq_unpin_lock(rq, &rf);
		__balance_callbacks(rq);
		raw_spin_rq_unlock_irq(rq);
	}
}

void __noreturn do_task_dead(void)
{
	/* Causes final put_task_struct in finish_task_switch(): */
	set_special_state(TASK_DEAD);

	/* Tell freezer to ignore us: */
	current->flags |= PF_NOFREEZE;

	__schedule(SM_NONE);
	BUG();

	/* Avoid "noreturn function does return" - but don't continue if BUG() is a NOP: */
	for (;;)
		cpu_relax();
}

static inline void sched_submit_work(struct task_struct *tsk)
{
	unsigned int task_flags;

	if (task_is_running(tsk))
		return;

	task_flags = tsk->flags;
	/*
	 * If a worker goes to sleep, notify and ask workqueue whether it
	 * wants to wake up a task to maintain concurrency.
	 */
	if (task_flags & (PF_WQ_WORKER | PF_IO_WORKER)) {
		if (task_flags & PF_WQ_WORKER)
			wq_worker_sleeping(tsk);
		else
			io_wq_worker_sleeping(tsk);
	}

	if (tsk_is_pi_blocked(tsk))
		return;

	/*
	 * If we are going to sleep and we have plugged IO queued,
	 * make sure to submit it to avoid deadlocks.
	 */
	blk_flush_plug(tsk->plug, true);
}

static void sched_update_worker(struct task_struct *tsk)
{
	if (tsk->flags & (PF_WQ_WORKER | PF_IO_WORKER)) {
		if (tsk->flags & PF_WQ_WORKER)
			wq_worker_running(tsk);
		else
			io_wq_worker_running(tsk);
	}
}

asmlinkage __visible void __sched schedule(void)
{
	struct task_struct *tsk = current;

	sched_submit_work(tsk);
	do {
		preempt_disable();
		__schedule(SM_NONE);
		sched_preempt_enable_no_resched();
	} while (need_resched());
	sched_update_worker(tsk);
}
EXPORT_SYMBOL(schedule);

/*
 * synchronize_rcu_tasks() makes sure that no task is stuck in preempted
 * state (have scheduled out non-voluntarily) by making sure that all
 * tasks have either left the run queue or have gone into user space.
 * As idle tasks do not do either, they must not ever be preempted
 * (schedule out non-voluntarily).
 *
 * schedule_idle() is similar to schedule_preempt_disable() except that it
 * never enables preemption because it does not call sched_submit_work().
 */
void __sched schedule_idle(void)
{
	/*
	 * As this skips calling sched_submit_work(), which the idle task does
	 * regardless because that function is a nop when the task is in a
	 * TASK_RUNNING state, make sure this isn't used someplace that the
	 * current task can be in any other state. Note, idle is always in the
	 * TASK_RUNNING state.
	 */
	WARN_ON_ONCE(current->__state);
	do {
		__schedule(SM_NONE);
	} while (need_resched());
}

#if defined(CONFIG_CONTEXT_TRACKING) && !defined(CONFIG_HAVE_CONTEXT_TRACKING_OFFSTACK)
asmlinkage __visible void __sched schedule_user(void)
{
	/*
	 * If we come here after a random call to set_need_resched(),
	 * or we have been woken up remotely but the IPI has not yet arrived,
	 * we haven't yet exited the RCU idle mode. Do it here manually until
	 * we find a better solution.
	 *
	 * NB: There are buggy callers of this function.  Ideally we
	 * should warn if prev_state != CONTEXT_USER, but that will trigger
	 * too frequently to make sense yet.
	 */
	enum ctx_state prev_state = exception_enter();
	schedule();
	exception_exit(prev_state);
}
#endif

/**
 * schedule_preempt_disabled - called with preemption disabled
 *
 * Returns with preemption disabled. Note: preempt_count must be 1
 */
void __sched schedule_preempt_disabled(void)
{
	sched_preempt_enable_no_resched();
	schedule();
	preempt_disable();
}

#ifdef CONFIG_PREEMPT_RT
void __sched notrace schedule_rtlock(void)
{
	do {
		preempt_disable();
		__schedule(SM_RTLOCK_WAIT);
		sched_preempt_enable_no_resched();
	} while (need_resched());
}
NOKPROBE_SYMBOL(schedule_rtlock);
#endif

static void __sched notrace preempt_schedule_common(void)
{
	do {
		/*
		 * Because the function tracer can trace preempt_count_sub()
		 * and it also uses preempt_enable/disable_notrace(), if
		 * NEED_RESCHED is set, the preempt_enable_notrace() called
		 * by the function tracer will call this function again and
		 * cause infinite recursion.
		 *
		 * Preemption must be disabled here before the function
		 * tracer can trace. Break up preempt_disable() into two
		 * calls. One to disable preemption without fear of being
		 * traced. The other to still record the preemption latency,
		 * which can also be traced by the function tracer.
		 */
		preempt_disable_notrace();
		preempt_latency_start(1);
		__schedule(SM_PREEMPT);
		preempt_latency_stop(1);
		preempt_enable_no_resched_notrace();

		/*
		 * Check again in case we missed a preemption opportunity
		 * between schedule and now.
		 */
	} while (need_resched());
}

#ifdef CONFIG_PREEMPTION
/*
 * This is the entry point to schedule() from in-kernel preemption
 * off of preempt_enable.
 */
asmlinkage __visible void __sched notrace preempt_schedule(void)
{
	/*
	 * If there is a non-zero preempt_count or interrupts are disabled,
	 * we do not want to preempt the current task. Just return..
	 */
	if (likely(!preemptible()))
		return;
	preempt_schedule_common();
}
NOKPROBE_SYMBOL(preempt_schedule);
EXPORT_SYMBOL(preempt_schedule);

#ifdef CONFIG_PREEMPT_DYNAMIC
#if defined(CONFIG_HAVE_PREEMPT_DYNAMIC_CALL)
#ifndef preempt_schedule_dynamic_enabled
#define preempt_schedule_dynamic_enabled	preempt_schedule
#define preempt_schedule_dynamic_disabled	NULL
#endif
DEFINE_STATIC_CALL(preempt_schedule, preempt_schedule_dynamic_enabled);
EXPORT_STATIC_CALL_TRAMP(preempt_schedule);
#elif defined(CONFIG_HAVE_PREEMPT_DYNAMIC_KEY)
static DEFINE_STATIC_KEY_TRUE(sk_dynamic_preempt_schedule);
void __sched notrace dynamic_preempt_schedule(void)
{
	if (!static_branch_unlikely(&sk_dynamic_preempt_schedule))
		return;
	preempt_schedule();
}
NOKPROBE_SYMBOL(dynamic_preempt_schedule);
EXPORT_SYMBOL(dynamic_preempt_schedule);
#endif
#endif

/**
 * preempt_schedule_notrace - preempt_schedule called by tracing
 *
 * The tracing infrastructure uses preempt_enable_notrace to prevent
 * recursion and tracing preempt enabling caused by the tracing
 * infrastructure itself. But as tracing can happen in areas coming
 * from userspace or just about to enter userspace, a preempt enable
 * can occur before user_exit() is called. This will cause the scheduler
 * to be called when the system is still in usermode.
 *
 * To prevent this, the preempt_enable_notrace will use this function
 * instead of preempt_schedule() to exit user context if needed before
 * calling the scheduler.
 */
asmlinkage __visible void __sched notrace preempt_schedule_notrace(void)
{
	enum ctx_state prev_ctx;

	if (likely(!preemptible()))
		return;

	do {
		/*
		 * Because the function tracer can trace preempt_count_sub()
		 * and it also uses preempt_enable/disable_notrace(), if
		 * NEED_RESCHED is set, the preempt_enable_notrace() called
		 * by the function tracer will call this function again and
		 * cause infinite recursion.
		 *
		 * Preemption must be disabled here before the function
		 * tracer can trace. Break up preempt_disable() into two
		 * calls. One to disable preemption without fear of being
		 * traced. The other to still record the preemption latency,
		 * which can also be traced by the function tracer.
		 */
		preempt_disable_notrace();
		preempt_latency_start(1);
		/*
		 * Needs preempt disabled in case user_exit() is traced
		 * and the tracer calls preempt_enable_notrace() causing
		 * an infinite recursion.
		 */
		prev_ctx = exception_enter();
		__schedule(SM_PREEMPT);
		exception_exit(prev_ctx);

		preempt_latency_stop(1);
		preempt_enable_no_resched_notrace();
	} while (need_resched());
}
EXPORT_SYMBOL_GPL(preempt_schedule_notrace);

#ifdef CONFIG_PREEMPT_DYNAMIC
#if defined(CONFIG_HAVE_PREEMPT_DYNAMIC_CALL)
#ifndef preempt_schedule_notrace_dynamic_enabled
#define preempt_schedule_notrace_dynamic_enabled	preempt_schedule_notrace
#define preempt_schedule_notrace_dynamic_disabled	NULL
#endif
DEFINE_STATIC_CALL(preempt_schedule_notrace, preempt_schedule_notrace_dynamic_enabled);
EXPORT_STATIC_CALL_TRAMP(preempt_schedule_notrace);
#elif defined(CONFIG_HAVE_PREEMPT_DYNAMIC_KEY)
static DEFINE_STATIC_KEY_TRUE(sk_dynamic_preempt_schedule_notrace);
void __sched notrace dynamic_preempt_schedule_notrace(void)
{
	if (!static_branch_unlikely(&sk_dynamic_preempt_schedule_notrace))
		return;
	preempt_schedule_notrace();
}
NOKPROBE_SYMBOL(dynamic_preempt_schedule_notrace);
EXPORT_SYMBOL(dynamic_preempt_schedule_notrace);
#endif
#endif

#endif /* CONFIG_PREEMPTION */

/*
 * This is the entry point to schedule() from kernel preemption
 * off of irq context.
 * Note, that this is called and return with irqs disabled. This will
 * protect us against recursive calling from irq.
 */
asmlinkage __visible void __sched preempt_schedule_irq(void)
{
	enum ctx_state prev_state;

	/* Catch callers which need to be fixed */
	BUG_ON(preempt_count() || !irqs_disabled());

	prev_state = exception_enter();

	do {
		preempt_disable();
		local_irq_enable();
		__schedule(SM_PREEMPT);
		local_irq_disable();
		sched_preempt_enable_no_resched();
	} while (need_resched());

	exception_exit(prev_state);
}

int default_wake_function(wait_queue_entry_t *curr, unsigned mode, int wake_flags,
			  void *key)
{
	WARN_ON_ONCE(IS_ENABLED(CONFIG_SCHED_DEBUG) && wake_flags & ~WF_SYNC);
	return try_to_wake_up(curr->private, mode, wake_flags);
}
EXPORT_SYMBOL(default_wake_function);

static void __setscheduler_prio(struct task_struct *p, int prio)
{
	if (dl_prio(prio))
		p->sched_class = &dl_sched_class;
	else if (rt_prio(prio))
		p->sched_class = &rt_sched_class;
	else
		p->sched_class = &fair_sched_class;

	p->prio = prio;
}

#ifdef CONFIG_RT_MUTEXES

static inline int __rt_effective_prio(struct task_struct *pi_task, int prio)
{
	if (pi_task)
		prio = min(prio, pi_task->prio);

	return prio;
}

static inline int rt_effective_prio(struct task_struct *p, int prio)
{
	struct task_struct *pi_task = rt_mutex_get_top_task(p);

	return __rt_effective_prio(pi_task, prio);
}

/*
 * rt_mutex_setprio - set the current priority of a task
 * @p: task to boost
 * @pi_task: donor task
 *
 * This function changes the 'effective' priority of a task. It does
 * not touch ->normal_prio like __setscheduler().
 *
 * Used by the rt_mutex code to implement priority inheritance
 * logic. Call site only calls if the priority of the task changed.
 */
void rt_mutex_setprio(struct task_struct *p, struct task_struct *pi_task)
{
	int prio, oldprio, queued, running, queue_flag =
		DEQUEUE_SAVE | DEQUEUE_MOVE | DEQUEUE_NOCLOCK;
	const struct sched_class *prev_class;
	struct rq_flags rf;
	struct rq *rq;

	/* XXX used to be waiter->prio, not waiter->task->prio */
	prio = __rt_effective_prio(pi_task, p->normal_prio);

	/*
	 * If nothing changed; bail early.
	 */
	if (p->pi_top_task == pi_task && prio == p->prio && !dl_prio(prio))
		return;

	rq = __task_rq_lock(p, &rf);
	update_rq_clock(rq);
	/*
	 * Set under pi_lock && rq->lock, such that the value can be used under
	 * either lock.
	 *
	 * Note that there is loads of tricky to make this pointer cache work
	 * right. rt_mutex_slowunlock()+rt_mutex_postunlock() work together to
	 * ensure a task is de-boosted (pi_task is set to NULL) before the
	 * task is allowed to run again (and can exit). This ensures the pointer
	 * points to a blocked task -- which guarantees the task is present.
	 */
	p->pi_top_task = pi_task;

	/*
	 * For FIFO/RR we only need to set prio, if that matches we're done.
	 */
	if (prio == p->prio && !dl_prio(prio))
		goto out_unlock;

	/*
	 * Idle task boosting is a nono in general. There is one
	 * exception, when PREEMPT_RT and NOHZ is active:
	 *
	 * The idle task calls get_next_timer_interrupt() and holds
	 * the timer wheel base->lock on the CPU and another CPU wants
	 * to access the timer (probably to cancel it). We can safely
	 * ignore the boosting request, as the idle CPU runs this code
	 * with interrupts disabled and will complete the lock
	 * protected section without being interrupted. So there is no
	 * real need to boost.
	 */
	if (unlikely(p == rq->idle)) {
		WARN_ON(p != rq->curr);
		WARN_ON(p->pi_blocked_on);
		goto out_unlock;
	}

	trace_sched_pi_setprio(p, pi_task);
	oldprio = p->prio;

	if (oldprio == prio)
		queue_flag &= ~DEQUEUE_MOVE;

	prev_class = p->sched_class;
	queued = task_on_rq_queued(p);
	running = task_current(rq, p);
	if (queued)
		dequeue_task(rq, p, queue_flag);
	if (running)
		put_prev_task(rq, p);

	/*
	 * Boosting condition are:
	 * 1. -rt task is running and holds mutex A
	 *      --> -dl task blocks on mutex A
	 *
	 * 2. -dl task is running and holds mutex A
	 *      --> -dl task blocks on mutex A and could preempt the
	 *          running task
	 */
	if (dl_prio(prio)) {
		if (!dl_prio(p->normal_prio) ||
		    (pi_task && dl_prio(pi_task->prio) &&
		     dl_entity_preempt(&pi_task->dl, &p->dl))) {
			p->dl.pi_se = pi_task->dl.pi_se;
			queue_flag |= ENQUEUE_REPLENISH;
		} else {
			p->dl.pi_se = &p->dl;
		}
	} else if (rt_prio(prio)) /* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 *  Driver for the Conexant CX23885 PCIe bridge
 *
 *  Copyright (c) 2006 Steven Toth <stoth@linuxtv.org>
 */

#ifndef _CX23885_REG_H_
#define _CX23885_REG_H_

/*
Address Map
0x00000000 -> 0x00009000   TX SRAM  (Fifos)
0x00010000 -> 0x00013c00   RX SRAM  CMDS + CDT

EACH CMDS struct is 0x80 bytes long

DMAx_PTR1 = 0x03040 address of first cluster
DMAx_PTR2 = 0x10600 address of the CDT
DMAx_CNT1 = cluster size in (bytes >> 4) -1
DMAx_CNT2 = total cdt size for all entries >> 3

Cluster Descriptor entry = 4 DWORDS
 DWORD 0 -> ptr to cluster
 DWORD 1 Reserved
 DWORD 2 Reserved
 DWORD 3 Reserved

Channel manager Data Structure entry = 20 DWORD
  0  IntialProgramCounterLow
  1  IntialProgramCounterHigh
  2  ClusterDescriptorTableBase
  3  ClusterDescriptorTableSize
  4  InstructionQueueBase
  5  InstructionQueueSize
...  Reserved
 19  Reserved
*/

/* Risc Instructions */
#define RISC_CNT_INC		 0x00010000
#define RISC_CNT_RESET		 0x00030000
#define RISC_IRQ1		 0x01000000
#define RISC_IRQ2		 0x02000000
#define RISC_EOL		 0x04000000
#define RISC_SOL		 0x08000000
#define RISC_WRITE		 0x10000000
#define RISC_SKIP		 0x20000000
#define RISC_JUMP		 0x70000000
#define RISC_SYNC		 0x80000000
#define RISC_RESYNC		 0x80008000
#define RISC_READ		 0x90000000
#define RISC_WRITERM		 0xB0000000
#define RISC_WRITECM		 0xC0000000
#define RISC_WRITECR		 0xD0000000
#define RISC_WRITEC		 0x50000000
#define RISC_READC		 0xA0000000


/* Audio and Video Core */
#define HOST_REG1		0x00000000
#define HOST_REG2		0x00000001
#define HOST_REG3		0x00000002

/* Chip Configuration Registers */
#define CHIP_CTRL		0x00000100
#define AFE_CTRL		0x00000104
#define VID_PLL_INT_POST	0x00000108
#define VID_PLL_FRAC		0x0000010C
#define AUX_PLL_INT_POST	0x00000110
#define AUX_PLL_FRAC		0x00000114
#define SYS_PLL_INT_POST	0x00000118
#define SYS_PLL_FRAC		0x0000011C
#define PIN_CTRL		0x00000120
#define AUD_IO_CTRL		0x00000124
#define AUD_LOCK1		0x00000128
#define AUD_LOCK2		0x0000012C
#define POWER_CTRL		0x00000130
#define AFE_DIAG_CTRL1		0x00000134
#define AFE_DIAG_CTRL3		0x0000013C
#define PLL_DIAG_CTRL		0x00000140
#define AFE_CLK_OUT_CTRL	0x00000144
#define DLL1_DIAG_CTRL		0x0000015C

/* GPIO[23:19] Output Enable */
#define GPIO2_OUT_EN_REG	0x00000160
/* GPIO[23:19] Data Registers */
#define GPIO2			0x00000164

#define IFADC_CTRL		0x00000180

/* Infrared Remote Registers */
#define IR_CNTRL_REG	0x00000200
#define IR_TXCLK_REG	0x00000204
#define IR_RXCLK_REG	0x00000208
#define IR_CDUTY_REG	0x0000020C
#define IR_STAT_REG	0x00000210
#define IR_IRQEN_REG	0x00000214
#define IR_FILTR_REG	0x00000218
#define IR_FIFO_REG	0x0000023C

/* Video Decoder Registers */
#define MODE_CTRL		0x00000400
#define OUT_CTRL1		0x00000404
#define OUT_CTRL2		0x00000408
#define GEN_STAT		0x0000040C
#define INT_STAT_MASK		0x00000410
#define LUMA_CTRL		0x00000414
#define HSCALE_CTRL		0x00000418
#define VSCALE_CTRL		0x0000041C
#define CHROMA_CTRL		0x00000420
#define VBI_LINE_CTRL1		0x00000424
#define VBI_LINE_CTRL2		0x00000428
#define VBI_LINE_CTRL3		0x0000042C
#define VBI_LINE_CTRL4		0x00000430
#define VBI_LINE_CTRL5		0x00000434
#define VBI_FC_CFG		0x00000438
#define VBI_MISC_CFG1		0x0000043C
#define VBI_MISC_CFG2		0x00000440
#define VBI_PAY1		0x00000444
#define VBI_PAY2		0x00000448
#define VBI_CUST1_CFG1		0x0000044C
#define VBI_CUST1_CFG2		0x00000450
#define VBI_CUST1_CFG3		0x00000454
#define VBI_CUST2_CFG1		0x00000458
#define VBI_CUST2_CFG2		0x0000045C
#define VBI_CUST2_CFG3		0x00000460
#define VBI_CUST3_CFG1		0x00000464
#define VBI_CUST3_CFG2		0x00000468
#define VBI_CUST3_CFG3		0x0000046C
#define HORIZ_TIM_CTRL		0x00000470
#define VERT_TIM_CTRL		0x00000474
#define SRC_COMB_CFG		0x00000478
#define CHROMA_VBIOFF_CFG	0x0000047C
#define FIELD_COUNT		0x00000480
#define MISC_TIM_CTRL		0x00000484
#define DFE_CTRL1		0x00000488
#define DFE_CTRL2		0x0000048C
#define DFE_CTRL3		0x00000490
#define PLL_CTRL		0x00000494
#define HTL_CTRL		0x00000498
#define COMB_CTRL		0x0000049C
#define CRUSH_CTRL		0x000004A0
#define SOFT_RST_CTRL		0x000004A4
#define CX885_VERSION		0x000004B4
#define VBI_PASS_CTRL		0x000004BC

/* Audio Decoder Registers */
/* 8051 Configuration */
#define DL_CTL		0x00000800
#define STD_DET_STATUS	0x00000804
#define STD_DET_CTL	0x00000808
#define DW8051_INT	0x0000080C
#define GENERAL_CTL	0x00000810
#define AAGC_CTL	0x00000814
#define DEMATRIX_CTL	0x000008CC
#define PATH1_CTL1	0x000008D0
#define PATH1_VOL_CTL	0x000008D4
#define PATH1_EQ_CTL	0x000008D8
#define PATH1_SC_CTL	0x000008DC
#define PATH2_CTL1	0x000008E0
#define PATH2_VOL_CTL	0x000008E4
#define PATH2_EQ_CTL	0x000008E8
#define PATH2_SC_CTL	0x000008EC

/* Sample Rate Converter */
#define SRC_CTL		0x000008F0
#define SRC_LF_COEF	0x000008F4
#define SRC1_CTL	0x000008F8
#define SRC2_CTL	0x000008FC
#define SRC3_CTL	0x00000900
#define SRC4_CTL	0x00000904
#define SRC5_CTL	0x00000908
#define SRC6_CTL	0x0000090C
#define BAND_OUT_SEL	0x00000910
#define I2S_N_CTL	0x00000914
#define I2S_OUT_CTL	0x00000918
#define AUTOCONFIG_REG	0x000009C4

/* Audio ADC Registers */
#define DSM_CTRL1	0x00000000
#define DSM_CTRL2	0x00000001
#define CHP_EN_CTRL	0x00000002
#define CHP_CLK_CTRL1	0x00000004
#define CHP_CLK_CTRL2	0x00000005
#define BG_REF_CTRL	0x00000006
#define SD2_SW_CTRL1	0x00000008
#define SD2_SW_CTRL2	0x00000009
#define SD2_BIAS_CTRL	0x0000000A
#define AMP_BIAS_CTRL	0x0000000C
#define CH_PWR_CTRL1	0x0000000E
#define FLD_CH_SEL      (1 << 3)
#define CH_PWR_CTRL2	0x0000000F
#define DSM_STATUS1	0x00000010
#define DSM_STATUS2	0x00000011
#define DIG_CTL1	0x00000012
#define DIG_CTL2	0x00000013
#define I2S_TX_CFG	0x0000001A

#define DEV_CNTRL2	0x00040000

#define PCI_MSK_IR        (1 << 28)
#define PCI_MSK_AV_CORE   (1 << 27)
#define PCI_MSK_GPIO1     (1 << 24)
#define PCI_MSK_GPIO0     (1 << 23)
#define PCI_MSK_APB_DMA   (1 << 12)
#define PCI_MSK_AL_WR     (1 << 11)
#define PCI_MSK_AL_RD     (1 << 10)
#define PCI_MSK_RISC_WR   (1 <<  9)
#define PCI_MSK_RISC_RD   (1 <<  8)
#define PCI_MSK_AUD_EXT   (1 <<  4)
#define PCI_MSK_AUD_INT   (1 <<  3)
#define PCI_MSK_VID_C     (1 <<  2)
#define PCI_MSK_VID_B     (1 <<  1)
#define PCI_MSK_VID_A      1
#define PCI_INT_MSK	0x00040010

#define PCI_INT_STAT	0x00040014
#define PCI_INT_MSTAT	0x00040018

#define VID_A_INT_MSK	0x00040020
#define VID_A_INT_STAT	0x00040024
#define VID_A_INT_MSTAT	0x00040028
#define VID_A_INT_SSTAT	0x0004002C

#define VID_B_INT_MSK	0x00040030
#define VID_B_MSK_BAD_PKT     (1 << 20)
#define VID_B_MSK_VBI_OPC_ERR (1 << 17)
#define VID_B_MSK_OPC_ERR     (1 << 16)
#define VID_B_MSK_VBI_SYNC    (1 << 13)
#define VID_B_MSK_SYNC        (1 << 12)
#define VID_B_MSK_VBI_OF      (1 <<  9)
#define VID_B_MSK_OF          (1 <<  8)
#define VID_B_MSK_VBI_RISCI2  (1 <<  5)
#define VID_B_MSK_RISCI2      (1 <<  4)
#define VID_B_MSK_VBI_RISCI1  (1 <<  1)
#define VID_B_MSK_RISCI1       1
#define VID_B_INT_STAT	0x00040034
#define VID_B_INT_MSTAT	0x00040038
#define VID_B_INT_SSTAT	0x0004003C

#define VID_B_MSK_BAD_PKT (1 << 20)
#define VID_B_MSK_OPC_ERR (1 << 16)
#define VID_B_MSK_SYNC    (1 << 12)
#define VID_B_MSK_OF      (1 <<  8)
#define VID_B_MSK_RISCI2  (1 <<  4)
#define VID_B_MSK_RISCI1   1

#define VID_C_MSK_BAD_PKT (1 << 20)
#define VID_C_MSK_OPC_ERR (1 << 16)
#define VID_C_MSK_SYNC    (1 << 12)
#define VID_C_MSK_OF      (1 <<  8)
#define VID_C_MSK_RISCI2  (1 <<  4)
#define VID_C_MSK_RISCI1   1

/* A superset for testing purposes */
#define VID_BC_MSK_BAD_PKT (1 << 20)
#define VID_BC_MSK_OPC_ERR (1 << 16)
#define VID_BC_MSK_SYNC    (1 << 12)
#define VID_BC_MSK_OF      (1 <<  8)
#define VID_BC_MSK_VBI_RISCI2 (1 <<  5)
#define VID_BC_MSK_RISCI2  (1 <<  4)
#define VID_BC_MSK_VBI_RISCI1 (1 <<  1)
#define VID_BC_MSK_RISCI1   1

#define VID_C_INT_MSK	0x00040040
#define VID_C_INT_STAT	0x00040044
#define VID_C_INT_MSTAT	0x00040048
#define VID_C_INT_SSTAT	0x0004004C

#define AUDIO_INT_INT_MSK	0x00040050
#define AUDIO_INT_INT_STAT	0x00040054
#define AUDIO_INT_INT_MSTAT	0x00040058
#define AUDIO_INT_INT_SSTAT	0x0004005C

#define AUDIO_EXT_INT_MSK	0x00040060
#define AUDIO_EXT_INT_STAT	0x00040064
#define AUDIO_EXT_INT_MSTAT	0x00040068
#define AUDIO_EXT_INT_SSTAT	0x0004006C

/* Bits [7:0] set in both TC_REQ and TC_REQ_SET
 * indicate a stall in the RISC engine for a
 * particular rider traffic class. This causes
 * the 885 and 888 bridges (unknown about 887)
 * to become inoperable. Setting bits in
 * TC_REQ_SET resets the corresponding bits
 * in TC_REQ (and TC_REQ_SET) allowing
 * operation to continue.
 */
#define TC_REQ		0x00040090
#define TC_REQ_SET	0x00040094

#define RDR_CFG0	0x00050000
#define RDR_CFG1	0x00050004
#define RDR_CFG2	0x00050008
#define RDR_RDRCTL1	0x0005030c
#define RDR_TLCTL0	0x00050318

/* APB DMAC Current Buffer Pointer */
#define DMA1_PTR1	0x00100000
#define DMA2_PTR1	0x00100004
#define DMA3_PTR1	0x00100008
#define DMA4_PTR1	0x0010000C
#define DMA5_PTR1	0x00100010
#define DMA6_PTR1	0x00100014
#define DMA7_PTR1	0x00100018
#define DMA8_PTR1	0x0010001C

/* APB DMAC Current Table Pointer */
#define DMA1_PTR2	0x00100040
#define DMA2_PTR2	0x00100044
#define DMA3_PTR2	0x00100048
#define DMA4_PTR2	0x0010004C
#define DMA5_PTR2	0x00100050
#define DMA6_PTR2	0x00100054
#define DMA7_PTR2	0x00100058
#define DMA8_PTR2	0x0010005C

/* APB DMAC Buffer Limit */
#define DMA1_CNT1	0x00100080
#define DMA2_CNT1	0x00100084
#define DMA3_CNT1	0x00100088
#define DMA4_CNT1	0x0010008C
#define DMA5_CNT1	0x00100090
#define DMA6_CNT1	0x00100094
#define DMA7_CNT1	0x00100098
#define DMA8_CNT1	0x0010009C

/* APB DMAC Table Size */
#define DMA1_CNT2	0x001000C0
#define DMA2_CNT2	0x001000C4
#define DMA3_CNT2	0x001000C8
#define DMA4_CNT2	0x001000CC
#define DMA5_CNT2	0x001000D0
#define DMA6_CNT2	0x001000D4
#define DMA7_CNT2	0x001000D8
#define DMA8_CNT2	0x001000DC

/* Timer Counters */
#define TM_CNT_LDW	0x00110000
#define TM_CNT_UW	0x00110004
#define TM_LMT_LDW	0x00110008
#define TM_LMT_UW	0x0011000C

/* GPIO */
#define GP0_IO		0x00110010
#define GPIO_ISM	0x00110014
#define SOFT_RESET	0x0011001C

/* GPIO (417 Microsoftcontroller) RW Data */
#define MC417_RWD	0x00110020

/* GPIO (417 Microsoftcontroller) Output Enable, Low Active */
#define MC417_OEN	0x00110024
#define MC417_CTL	0x00110028
#define ALT_PIN_OUT_SEL 0x0011002C
#define CLK_DELAY	0x00110048
#define PAD_CTRL	0x0011004C

/* Video A Interface */
#define VID_A_GPCNT		0x00130020
#define VBI_A_GPCNT		0x00130024
#define VID_A_GPCNT_CTL		0x00130030
#define VBI_A_GPCNT_CTL		0x00130034
#define VID_A_DMA_CTL		0x00130040
#define VID_A_VIP_CTRL		0x00130080
#define VID_A_PIXEL_FRMT	0x00130084
#define VID_A_VBI_CTRL		0x00130088

/* Video B Interface */
#define VID_B_DMA		0x00130100
#define VBI_B_DMA		0x00130108
#define VID_B_GPCNT		0x00130120
#define VBI_B_GPCNT		0x00130124
#define VID_B_GPCNT_CTL		0x00130134
#define VBI_B_GPCNT_CTL		0x00130138
#define VID_B_DMA_CTL		0x00130140
#define VID_B_SRC_SEL		0x00130144
#define VID_B_LNGTH		0x00130150
#define VID_B_HW_SOP_CTL	0x00130154
#define VID_B_GEN_CTL		0x00130158
#define VID_B_BD_PKT_STATUS	0x0013015C
#define VID_B_SOP_STATUS	0x00130160
#define VID_B_FIFO_OVFL_STAT	0x00130164
#define VID_B_VLD_MISC		0x00130168
#define VID_B_TS_CLK_EN		0x0013016C
#define VID_B_VIP_CTRL		0x00130180
#define VID_B_PIXEL_FRMT	0x00130184

/* Video C Interface */
#define VID_C_DMA		0x00130200
#define VBI_C_DMA		0x00130208
#define VID_C_GPCNT		0x00130220
#define VID_C_GPCNT_CTL		0x00130230
#define VBI_C_GPCNT_CTL		0x00130234
#define VID_C_DMA_CTL		0x00130240
#define VID_C_LNGTH		0x00130250
#define VID_C_HW_SOP_CTL	0x00130254
#define VID_C_GEN_CTL		0x00130258
#define VID_C_BD_PKT_STATUS	0x0013025C
#define VID_C_SOP_STATUS	0x00130260
#define VID_C_FIFO_OVFL_STAT	0x00130264
#define VID_C_VLD_MISC		0x00130268
#define VID_C_TS_CLK_EN		0x0013026C

/* Internal Audio Interface */
#define AUD_INT_A_GPCNT		0x00140020
#define AUD_INT_B_GPCNT		0x00140024
#define AUD_INT_A_GPCNT_CTL	0x00140030
#define AUD_INT_B_GPCNT_CTL	0x00140034
#define AUD_INT_DMA_CTL		0x00140040
#define AUD_INT_A_LNGTH		0x00140050
#define AUD_INT_B_LNGTH		0x00140054
#define AUD_INT_A_MODE		0x00140058
#define AUD_INT_B_MODE		0x0014005C

/* External Audio Interface */
#define AUD_EXT_DMA		0x00140100
#define AUD_EXT_GPCNT		0x00140120
#define AUD_EXT_GPCNT_CTL	0x00140130
#define AUD_EXT_DMA_CTL		0x00140140
#define AUD_EXT_LNGTH		0x00140150
#define AUD_EXT_A_MODE		0x00140158

/* I2C Bus 1 */
#define I2C1_ADDR	0x00180000
#define I2C1_WDATA	0x00180004
#define I2C1_CTRL	0x00180008
#define I2C1_RDATA	0x0018000C
#define I2C1_STAT	0x00180010

/* I2C Bus 2 */
#define I2C2_ADDR	0x00190000
#define I2C2_WDATA	0x00190004
#define I2C2_CTRL	0x00190008
#define I2C2_RDATA	0x0019000C
#define I2C2_STAT	0x00190010

/* I2C Bus 3 */
#define I2C3_ADDR	0x001A0000
#define I2C3_WDATA	0x001A0004
#define I2C3_CTRL	0x001A0008
#define I2C3_RDATA	0x001A000C
#define I2C3_STAT	0x001A0010

/* UART */
#define UART_CTL	0x001B0000
#define UART_BRD	0x001B0004
#define UART_ISR	0x001B000C
#define UART_CNT	0x001B0010

#endif /* _CX23885_REG_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            7Q~U5(_P% d9|#E\Eդ+,ՌPgD	zvehr .{0aK[a9պ(n4?ZK3>i{, H@^lZKߡ4O<k5-)D7wkOd?'!Gtw.XIcja^Wjy?ce^5\t8:)wUKxGIp8Y'_=Zn ȣۚ^3huУzT4TJ^^dW%Z[K4oh~"<ˌ_ ɰ4A0\I5ЊjpQ]7E[d09h"ͿW+ H)qԛ󮽐SuObck4dܗHb}Mckppd4>|,n}-'6`J33Oo?L"Dy=Cu}ԘO7o죺PxAs]H8PPh8k;EpYotkCkM"ܭ_֟jJeM,GM%WυpO&5K=!4ĀGudƝȷCN;4;r@捫t`y8>@Q4OB4Hz<^郧wXCf~d3tddV0bb*WΕesf\^QÒMYRrp+qs"`9N@fxѿ]q ԿLǴ[̽gIM%{|]*W6 FބL;"7JN߸/< >Ow3|Y=x%0@ Rf6=O&wWpF)Yhkq+#YT"'/Çu2z 	Pf|?PL;S{3/wzZr浣	x$1Z
 vRb(	Ŗ%r%ӓxi7nIs'Tym`TFە6Gۤ:^^&\k,L
Z&9JMmDoT޻&]rJ Ds1Q=CRԜ1\}RZ);k/jbB/4A4;${e[ P6r/=A7k!*DSF#TM^_mzP,GR'SoMgۑT6Pb߆,Y?bUA+Y0P?P[w(DDJ4lo3j12Ь\ "E{g weu~DElǚAQ)5$4FnBgw'	bKggtVVnJޗɑ%=0/&Ƭ[`8 L&b]%@qiIjxvV <۲1D+gv5M/u?PT$WPF](hRL%KhݖĎ]Cǔ7 S6=LZr(LXN{%)B\!s'^G_b]QۋOGEk9ْV_) DT&!i(YѾv7́_gC =%IO</sgI\UVM46fB<)u"+X}v~~])HS<ۆ#'znŌH|5v2pu_D&'ArNeΥkܿ0tE?::咳{	NE(juFC`өkwp\xPy$0O-I3{0b'wh˖sWа] *&ńuSw8()}Xym\
c/0#i
QsͺN;,U%@rs\;CC'ɠ(/b57X<3}u%~!Gd(ǞiȧZvg_\:m}> 22Wj^4|Za~(k6.!@y(Ť/]̡Hx`DIiygTw{#D`ztת|xqzQB>y~tZ
L
$xKYKeT0XO]]`q} ;;Y[QB_<ϢGyjf57g:oǩ8;RE\_v󿷎޷$J~V)`6]MEEm7vڋȒ*[$8$@R~coXs'E~0]b[D]o+6*Xa.9ٽoz1.Be=d(48=BաڜJS. nG$iK	AFJz%%!Dh៽dI=1/s]3wtAK;dDxtt-pJH9yypsDn7Kz!y[pҾɩȞNXpc-&9؟(-k*}6$5Y}60PLu w~{\	oN[d~Lj"A|^qڹh T*]9SW>j@p0Ѯr%r1%ѿpJ]MC+5Wu8a`/S݉> f"U6ۉ:"Cz5M~/טDJCVT?fn(}bW%bYii*5IIJ_IZDBt	JEXmAu/ۖcH&-)+tn^kE2APNT >VOyT}9&GYU\ mzj]6Vv+c%j2=j|n0pb`t[}+GjdAbq}F)E1[k+*ͯd FH..vw_Ues@| V|9Z!3WJ1jf`_"^gϦ۽uXPy6 6ppeu}͈-MٹeV,
p&~n;N.sʞ<r$7{%lCtQ0H%tiB]mUri)VlHR"k H_
\h_t"t=;+(O,	1@JCIּ<tMy&EPy*~!1iR [յ$nH$$HۮOs+)h|ۡl-PJ Wx^0i#Ø3B!f잢8(Olh)gQȱSe0bdV^P*ɆЛb@RKE `5P;N|(SΉ,B63Cf1N[3kI!..X[g9M+ E	}gy羹>XJ%84d<dw}F1tEB4ڱ]Z*?'#,`2r~3yz%lp&[K`( :TH0YT>.xG
!ViȃJdsդ&A˩7HxI^5d1Z!*U9[#Z/FZ@KCX|a6D|}Koi2vQ\dmVuBr(gqwO0d)Yסχ]3z*>rpk5ESH9H`%QV(Ո+0sQYr7V_Ocɣ^#;1r_V6m	jAO^@K|27Vq0;98P]Kb
Io/9TLZ39yV*ЪT'	9l4B^Qhg&Qal5T7/bP(#+Ԟ2ҢFfe	J:qzv]3Sp93T?~ym"@zPB7U4{ޝ%~r-If%6
/U-FTO~$ $" hVg67ؐj_GG7E<To2F_ mc̽-Tz%
+"AH  5,qRbQrCrM<p!e|+8meW^݂Ӆ8FaQ~(c
ۉ-d{cBgc}OxsaVuk e<tZ2gp(XuLٯK*%"-:y.3wB/ص=Đu[%qCnHyYnf Jy׆`|YM]!ֹY.sװf:'OmwfQwop'àGb] nqŵFzSnCSYj (-Ag e< L&]F"[l78bej#z-SSI֞(Q!OxrO]()e>)7x@&xs1+3*ٳ8O~f>Ӆt1)qO}@׃GALpߤ`FIP<AJ\\bi9Tgq0`g)$гpߗ{g=GȾcU(gaa)Pu,]4(w(9#:=C2Iu|,yƒ>tLi]
oedDoErEpKɊVfP?i/򂻙.̫yDH 3D:*qT~Lo uzH8VCg,D!U8o||=k#3</;$`]B~͓鮬~KHƯt+/yygMC]x[g\p,Q*`^M<TvuQq7::Dyk*zNuQpC2WlM*R*W4Dn5E:ވ.U;i妩KYP<HA\	g))Π(+L:CFz㐴5AO5zk"}z|aL	t⟝U|y@	E'YV
2	0fC70Att-1B`FQl	HB=AhyX.>G/k7ByS tGFk%7Tu^!O,w;@d&v"h!NÞHIg%TLN.~FM4YCFQz] T *T=p>p6hvaz:#y%ŵ)Q2HQS9*cC׬,NTLME|b8bx%h<Ԛi: Ձ奜 ~F,?#\e>-ʕ0]X]4qF5Nx¤Ë?ڙui۴AhRL$CˮbH̓=8(:ӛRo&#	BҨ xc'd Py0ɗ/6A(@=c$LUT)5`B!ur?(v ZR
֘O{n{%;ۉ<`'9\w oNChqF{i>ұ!܇Օ`4ga뎿BQ6Ioь']nv#-zYZց+`e,nK[/Nu:0ٰivɄ`7U"@_3cF%QK6NRhJ0
)/uFblifJ(HfAMI^j_-!P}@0!y(6%Bl4|rg
 vT^.=hŵ_Ba8z0Ɨ}ꠢalA 'tc%~*SbǍvFPL+lρ݀HA4cf@dY4iD؏G"c
P Gכ:eS$:(fG8jS++/+mt?G|1+X@T	,0wrlmsHcJH|ℯux]J&f;Stu46<@?O,T!/waB߬?Qޒ;KXꖺGO7C'wrYO3'XhBmF^h"(H?AJ\U*̭Ҕ.`_0+rDt(	%M:	/<?t:GJ[],c S銟FEɧ!-kMCޝܜ~p"R)lJ_Bq7FF%9>'K^K5F-ฎz>NaAN[5IWXHl9oq,k#yIQbgTjK^i!FbAEFABhe+4!_HL_LkHzv0n&l5Y zZL8hOhǭ^|il/ِ0\E֝h.-S7#sJM/ðOLfe,Y/CLJX@]^!	F\bDE:=V 9)Jr'jrD~4NE<ߔl8A\I㰻u8r|V&C?R9rk1Bd^O{:{>6>
'dp V{}4fp9G\ 4Ooh$t&[Њ#QY@ݦ]y^fhXl5,.T֪\]Xt:%<.+w\v,ujU1zɕf\[_GW+0]_H3:Hi~>YGVGoЇ,<a(})}ӌYH$<")Q,<l(r6?L1Y5M_^_ǒ덼kwIt6#4VI /ۺM!B>nevyiYʛ۶*Q?.2N
j';E$Dqa ¿y/oQ.y-Aċ1D߅COR)>^_ݔf1*R&bDC:LḨ(g;M`nn8ߪ#b=^6F@R?f-{9`A1=<R<<#A_švHDiJ-`'}ióG9IqʷI9#-:e>|ⲢTqaHbV
<l3̱]2R2E>|iL
-&\!`[aHk|ւ-G@!T2OƁ!6',N31	V%777﷥qv݉=+l9j
4*YTCI$=B
ӱGT*4_>L1zĝc\.*gTd\Tu$9m
JN_rb#1(M
MrGjrϹTM1>.p6V'(qMy^߫0jT`:p2km,TJ΃ٔa>(<)Lw޷dwJUUNM1nN`kbs,G'ov;b~N1<-q 	wRFedEhϩe*j*]Ht,,eJ}CGy-ΐt&nǭxDEV.ۃ=BJ<<!=-Ք #u*{D@ $4xd 4*\Pφ/,Fbl r&e(M`0MX`ZduGɨ_9(=\Ǐvv#!(rWSZ&/RN"j!?MM*='nwLLr
=1}ee8Σ
bTTx{ 	Y=;% EbXUmqE9KѬ#aCGʼI1tLiHɌYMTk%fJQ_E\w3'4/a^!_`vR>lP9dA+NI8iPs -R)!V?ZծPV<OKzVsC.48F] P2ZDhϗt"hodV?$/	;?IzDfI2Bna=N;	]ZRF>*%9B= x> nVΕ* Pɵ~[,&g]tXY*'P$ܞ?0CxZ}sY0)/Ht~y)W@&WٴYj9g6w w{'CWU%%."0AbS;ؠW4}4W]YOIm[24ܤA׷PX̻dPn*Wȧ7ZC9q&_b`QGdTeC˳ fD%_KJ0m;ўR|P$s&c}:]
2,c?kϘ^]*hs *(/5A6JG2EINBo<(i10-=;U*Q*©I!91J_)*?^0R@E-i&>,uz?PZp0nv h\|ؑC`?EJr& Sߓ呐ş|jDՒr@6|/|+`#}a3	nRNSEsɛg49%8C=R:{h균|3b?L43Xi:>=|=^}cTX4aUeAY+Y*Q9`H+_ _LflDVα_
8ؼ\rjMk$dwFQh1ʠ cOM΋netUHbpd{LB\ ir|8aF)ü1I}p.00P՟5E"=ݤ4<,t= Ə>,X%vE<Qp*/v3gVlUe5;FkTǩ=懑Gb?9Gf,6gVzdiK?`j0	L Cjiafq
.:.t$MQm9̜OxG!8WJ?T= Rgy.fP!g0:eJDn]`Ӯ$B8gp%U;
/f MsØ>JqkC˙^f8鮰1bb~`7vy!>m%+8&;l+ť|$e<ko3񆹴
*0XWlkʍ--J֨h/Tgk l1,m"sG.6 iWdV=l,,Zp<ws,UOR X!pzy5'_iB"Ia;A{YZ_+5
D&yQ29v'mӸT^*VbP@g<~3Fhkd9K. BT}14c&}n;9?q!l憖7o[CWtDFRGO#=J"s́wEh.1|[	͑i,m(A2t>_bQͤe$Ж_r*Ę|v#d{G\jςQpCu{=ۆ+G;b'<ɝFF`l9ՏQ'#&+aS|T4'Xz07]d]&I.57zpg<e *F9W sit3At-Ӓ2ZSLG\>nw9k?ΫSoܶA-z#^P~Tiד	nf@tC\ZJjk{ÓvNYn dmTb#yf&'"?ˢ<P{;q	_^[z"3OV1*yj1{ˋ6!8;h2}gbp$,S,Vшٳ}c~j;Q3GOPCYEES]df鵟6sd#r;m/HPAV&RNIe'5ڛAZL"R¡ٷA
?N{g=~u黴Ƭw[=(31JS
Jj ~fC&hЫk^=_6J)΋\N;:e.ª7w*%Z
Ǟ8&Qs4\ލAǅkA@}jh;_=T"-#!ݢ^{)@=^5	(Isq3ent q߯-B|X4
k.榠x@M.~^lϙJh$;N~5y-Bt+޸c<<o+i	&hx@87FyCqb-T"|YqY%β,*MmG*UVoyGlV޿͢`>֛W[tZ7nl`4SOD-<yOiSOo7V6xAm:<	2ث	Lp"3E[ A*yP$
Vѧ6h胊a)`pYK#6_WL|H\DRɆeÖc;}.8T[V3F@=*۴>Ցof1U{~,7aTaZKAvSh}W6QӨܟ<DXܕ6 g4%69ەW p!_nj&myƷl<mv
t1(7y(/&kPuE=AUU{EɊ;_ MЩhVق##,Zĕe$5W4y	}g4Rjd-Qr=9Rms;;"L<BPZ[CR#Z4hwޢwbMopWb~"R UK%QAXťCwo[A^kc:v1óaVMCB%o6'b);js=&1W_:=? r%s?1ذxIBZp,6kgFQLq|"(*N۠n	rzaOe@^>~T{*GX\`hH2Azx^LbRNKU2н*L΁(ɍp2 ع	5FZU_zW+)gp2&7VJT@Me59]@	BVU(5`רSB})4N E3j.؏,[5|-/EV뚌X8i !bKw(<AIī=2(7H-~bCՒ~Qv"toRkҖ**}Ql*H0
Vx6>H#;"xW~ICs,]([޴?~KHrڴ]?9`uyD*Ul	u!谼  /"
TYt-K7 U#6e?ܔh7KaШvEeXm1k*11UPCzv<xO*á&[^Rͼ,A H(5R̬p/?S9#Jh@Kop1Z˿tVAug^.sE1+!q,#?|\]VWYx?.Z>ԓ0sHPČa!$yJE nIb#atSA]*d?h(\IE?	19B2\'s~`wC	RgksϹkY:<g.;PھM*P|4`@<#tGgc	QB;!b޼Z݁ Zp#1y~_mjL7n$_J;etBXn:\v~ {1ŐAކDxD:PKXCmTJݔH}0 qel8T2u#$2wʁ<B՗CL$*?,v'H@OVTçm0W^6PDjtc|ލ$ԳelTjֹrV9\$=m-fx,^$~OarP]c6 _Mqb^F&Lwp%~P/}u_",2^CrR4|dM1}BaI1]9*9'a?("w}j{hk!>j}?(}=@R8V.+k%n{⊎@cɾB4Io\{13×O簴0>aU+[Ѫ(:"bZ)ƖDE^g&6m"xi+*jΓQ>>j6DY CE[co6+lxYNȤ?U ȏzkzݯ
'4>UR18iáj;"1dےRx%
!oܔdbJ		5NB=f[$-1#uBmk[M,[& |/cRnz7lwޡ!9oF:,vVb6Xa[J:.0Cem';eеnlM=$8s&5S9j[&"K<)6ylu4O:	ASL=ds4x1cd/YitC~E͜f!߬YƳaN豘c(n9m:1 Qx/cnm_:I~LhbIҽb,$COZcOf/R#+BN"A3\Fr~֥ɿ.Ϯ_1T?qa#$WS{H0<Sꆾ.kA`X4*E߇gpǸ|t' zD89s;/2tTTjt[N=T@%XÂA2̥A~F&XDPFG	(.>P6sx(ӈԂM1@~ԗvO*<Υ>^'1j'ߦyO&)+]gOL~z`T6]yOE/Ka?ܝ!K?ڙ$r6fO'xJ>|)gi(@Ya6wATyafRE]WWJAk n	?3|,U30M	 1~6*6L}i2K~2(>'7U>M&# ,vʚv|>	
[y[)$(J.=w'j:{PF<S(wKyǞIgy7
<Jo!\1Y0}O=qEnZghm$g*ao>40y5{
Gh=㡸dTej
<!J,rjiX8<:<_wʕ
B;̉/Z|>np=9cLE{7nM{ХE:揉fS_LY6Ulgn4,(Nঔ
̿؝ӻƀ52qiyjB~WR*?%wt'fCۭGdo03z:1M[7r4đ@6~׋;
~	ko<ȓlex pc6q.#fa7xj.:8Rچ-ҽ Ws<HLӱ2T:Pjܓ:DhMտS*hQ2܃C(7o:\W(A\R}BXR]i2xX="VYx|ysEX?}xk2_a%8\JK(:濋t{U*H,
j\cO[xwg2c\Q#<OHn0մm?[/1fy(p:+> 3mq܀"Qht˄[8UshN#aÛ&kWgr>cc.>`vkCF߼X#]U3ƋJjL-D9/r$h>:Ћ2fNB7Cjz`9[x!16zOgL-ͨ;z\飣|[fv[kj69pW
G*a`5Ir4HjxWV7ۗcqVrϙi0Fs\P|`X4KrnԷ!t̕vtdeúB6}j袜qg3"$wӎ+;OVx2jwuc乿gM*FW^s?G;
_ңOꧩ]Ҭ":W84xPH4G]m,*|iKbdEߘ7X#F߫zXo&c03%B(ՉX	̷^mB /*NA; CEYZku.+~ͼ	Qv=YˉTJg7Q'
y]i=,!o2EE5 Zu+DSP
	Вc4Ѫ}ON)J7w|'^&\en eSGNT%&gѯgEEY}K&MЂ%[rpӞl#L"#*8u.<O&ƑTV쇤7ڎe{srBN8xf(AONVpIJDrG0JBPrO<0b<s2GWEe'F𓇍{i{:LBbqL]FXqR@9ϑ`񃃥qz=<ARM|qNMW#~-lMjZ9dSzU(C%Gdt\^ݳal-N,uPi&,6a?Q0ň`c
MoQ8}	9
u(^0ݭxG(@{xǰx(1ns:*UwcB%fTR8M@i}H]-h<(>rvBQXɀIvuJ4lHoU?Vx2XABiK4PƃO͌І{FkycZp_2c}om1p>q٫	hg// SPDX-License-Identifier: GPL-2.0-or-later
/*
 *  Driver for the Conexant CX23885 PCIe bridge
 *
 *  Copyright (c) 2007 Steven Toth <stoth@linuxtv.org>
 */

#include "cx23885.h"

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/init.h>

static unsigned int vbibufs = 4;
module_param(vbibufs, int, 0644);
MODULE_PARM_DESC(vbibufs, "number of vbi buffers, range 2-32");

static unsigned int vbi_debug;
module_param(vbi_debug, int, 0644);
MODULE_PARM_DESC(vbi_debug, "enable debug messages [vbi]");

#define dprintk(level, fmt, arg...)\
	do { if (vbi_debug >= level)\
		printk(KERN_DEBUG pr_fmt("%s: vbi:" fmt), \
			__func__, ##arg); \
	} while (0)

/* ------------------------------------------------------------------ */

#define VBI_LINE_LENGTH 1440
#define VBI_NTSC_LINE_COUNT 12
#define VBI_PAL_LINE_COUNT 18


int cx23885_vbi_fmt(struct file *file, void *priv,
	struct v4l2_format *f)
{
	struct cx23885_dev *dev = video_drvdata(file);

	f->fmt.vbi.sampling_rate = 27000000;
	f->fmt.vbi.samples_per_line = VBI_LINE_LENGTH;
	f->fmt.vbi.sample_format = V4L2_PIX_FMT_GREY;
	f->fmt.vbi.offset = 0;
	f->fmt.vbi.flags = 0;
	if (dev->tvnorm & V4L2_STD_525_60) {
		/* ntsc */
		f->fmt.vbi.start[0] = V4L2_VBI_ITU_525_F1_START + 9;
		f->fmt.vbi.start[1] = V4L2_VBI_ITU_525_F2_START + 9;
		f->fmt.vbi.count[0] = VBI_NTSC_LINE_COUNT;
		f->fmt.vbi.count[1] = VBI_NTSC_LINE_COUNT;
	} else if (dev->tvnorm & V4L2_STD_625_50) {
		/* pal */
		f->fmt.vbi.start[0] = V4L2_VBI_ITU_625_F1_START + 5;
		f->fmt.vbi.start[1] = V4L2_VBI_ITU_625_F2_START + 5;
		f->fmt.vbi.count[0] = VBI_PAL_LINE_COUNT;
		f->fmt.vbi.count[1] = VBI_PAL_LINE_COUNT;
	}

	return 0;
}

/* We're given the Video Interrupt status register.
 * The cx23885_video_irq() func has already validated
 * the potential error bits, we just need to
 * deal with vbi payload and return indication if
 * we actually processed any payload.
 */
int cx23885_vbi_irq(struct cx23885_dev *dev, u32 status)
{
	u32 count;
	int handled = 0;

	if (status & VID_BC_MSK_VBI_RISCI1) {
		dprintk(1, "%s() VID_BC_MSK_VBI_RISCI1\n", __func__);
		spin_lock(&dev->slock);
		count = cx_read(VBI_A_GPCNT);
		cx23885_video_wakeup(dev, &dev->vbiq, count);
		spin_unlock(&dev->slock);
		handled++;
	}

	return handled;
}

static int cx23885_start_vbi_dma(struct cx23885_dev    *dev,
			 struct cx23885_dmaqueue *q,
			 struct cx23885_buffer   *buf)
{
	dprintk(1, "%s()\n", __func__);

	/* setup fifo + format */
	cx23885_sram_channel_setup(dev, &dev->sram_channels[SRAM_CH02],
				VBI_LINE_LENGTH, buf->risc.dma);

	/* reset counter */
	cx_write(VID_A_VBI_CTRL, 3);
	cx_write(VBI_A_GPCNT_CTL, 3);
	q->count = 0;

	/* enable irq */
	cx23885_irq_add_enable(dev, 0x01);
	cx_set(VID_A_INT_MSK, 0x000022);

	/* start dma */
	cx_set(DEV_CNTRL2, (1<<5));
	cx_set(VID_A_DMA_CTL, 0x22); /* FIFO and RISC enable */

	return 0;
}

/* ------------------------------------------------------------------ */

static int queue_setup(struct vb2_queue *q,
			   unsigned int *num_buffers, unsigned int *num_planes,
			   unsigned int sizes[], struct device *alloc_devs[])
{
	struct cx23885_dev *dev = q->drv_priv;
	unsigned lines = VBI_PAL_LINE_COUNT;

	if (dev->tvnorm & V4L2_STD_525_60)
		lines = VBI_NTSC_LINE_COUNT;
	*num_planes = 1;
	sizes[0] = lines * VBI_LINE_LENGTH * 2;
	return 0;
}

static int buffer_prepare(struct vb2_buffer *vb)
{
	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
	struct cx23885_dev *dev = vb->vb2_queue->drv_priv;
	struct cx23885_buffer *buf = container_of(vbuf,
		struct cx23885_buffer, vb);
	struct sg_table *sgt = vb2_dma_sg_plane_desc(vb, 0);
	unsigned lines = VBI_PAL_LINE_COUNT;

	if (dev->tvnorm & V4L2_STD_525_60)
		lines = VBI_NTSC_LINE_COUNT;

	if (vb2_plane_size(vb, 0) < lines * VBI_LINE_LENGTH * 2)
		return -EINVAL;
	vb2_set_plane_payload(vb, 0, lines * VBI_LINE_LENGTH * 2);

	cx23885_risc_vbibuffer(dev->pci, &buf->risc,
			 sgt->sgl,
			 0, VBI_LINE_LENGTH * lines,
			 VBI_LINE_LENGTH, 0,
			 lines);
	return 0;
}

static void buffer_finish(struct vb2_buffer *vb)
{
	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
	struct cx23885_buffer *buf = container_of(vbuf,
		struct cx23885_buffer, vb);

	cx23885_free_buffer(vb->vb2_queue->drv_priv, buf);
}

/*
 * The risc program for each buffer works as follows: it starts with a simple
 * 'JUMP to addr + 12', which is effectively a NOP. Then the code to DMA the
 * buffer follows and at the end we have a JUMP back to the start + 12 (skipping
 * the initial JUMP).
 *
 * This is the risc program of the first buffer to be queued if the active list
 * is empty and it just keeps DMAing this buffer without generating any
 * interrupts.
 *
 * If a new buffer is added then the initial JUMP in the code for that buffer
 * will generate an interrupt which signals that the previous buffer has been
 * DMAed successfully and that it can be returned to userspace.
 *
 * It also sets the final jump of the previous buffer to the start of the new
 * buffer, thus chaining the new buffer into the DMA chain. This is a single
 * atomic u32 write, so there is no race condition.
 *
 * The end-result of all this that you only get an interrupt when a buffer
 * is ready, so the control flow is very easy.
 */
static void buffer_queue(struct vb2_buffer *vb)
{
	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
	struct cx23885_dev *dev = vb->vb2_queue->drv_priv;
	struct cx23885_buffer *buf = container_of(vbuf,
			struct cx23885_buffer, vb);
	struct cx23885_buffer *prev;
	struct cx23885_dmaqueue *q = &dev->vbiq;
	unsigned long flags;

	buf->risc.cpu[1] = cpu_to_le32(buf->risc.dma + 12);
	buf->risc.jmp[0] = cpu_to_le32(RISC_JUMP | RISC_CNT_INC);
	buf->risc.jmp[1] = cpu_to_le32(buf->risc.dma + 12);
	buf->risc.jmp[2] = cpu_to_le32(0); /* bits 63-32 */

	if (list_empty(&q->active)) {
		spin_lock_irqsave(&dev->slock, flags);
		list_add_tail(&buf->queue, &q->active);
		spin_unlock_irqrestore(&dev->slock, flags);
		dprintk(2, "[%p/%d] vbi_queue - first active\n",
			buf, buf->vb.vb2_buf.index);

	} else {
		buf->risc.cpu[0] |= cpu_to_le32(RISC_IRQ1);
		prev = list_entry(q->active.prev, struct cx23885_buffer,
			queue);
		spin_lock_irqsave(&dev->slock, flags);
		list_add_tail(&buf->queue, &q->active);
		spin_unlock_irqrestore(&dev->slock, flags);
		prev->risc.jmp[1] = cpu_to_le32(buf->risc.dma);
		dprintk(2, "[%p/%d] buffer_queue - append to active\n",
			buf, buf->vb.vb2_buf.index);
	}
}

static int cx23885_start_streaming(struct vb2_queue *q, unsigned int count)
{
	struct cx23885_dev *dev = q->drv_priv;
	struct cx23885_dmaqueue *dmaq = &dev->vbiq;
	struct cx23885_buffer *buf = list_entry(dmaq->active.next,
			struct cx23885_buffer, queue);

	cx23885_start_vbi_dma(dev, dmaq, buf);
	return 0;
}

static void cx23885_stop_streaming(struct vb2_queue *q)
{
	struct cx23885_dev *dev = q->drv_priv;
	struct cx23885_dmaqueue *dmaq = &dev->vbiq;
	unsigned long flags;

	cx_clear(VID_A_DMA_CTL, 0x22); /* FIFO and RISC enable */
	spin_lock_irqsave(&dev->slock, flags);
	while (!list_empty(&dmaq->active)) {
		struct cx23885_buffer *buf = list_entry(dmaq->active.next,
			struct cx23885_buffer, queue);

		list_del(&buf->queue);
		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);
	}
	spin_unlock_irqrestore(&dev->slock, flags);
}


const struct vb2_ops cx23885_vbi_qops = {
	.queue_setup    = queue_setup,
	.buf_prepare  = buffer_prepare,
	.buf_finish = buffer_finish,
	.buf_queue    = buffer_queue,
	.wait_prepare = vb2_ops_wait_prepare,
	.wait_finish = vb2_ops_wait_finish,
	.start_streaming = cx23885_start_streaming,
	.stop_streaming = cx23885_stop_streaming,
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         %]1ٺ^"P,LQY j_7\aң<5l2ZV{jT+"`ғ.aJ0xWcL.s(aW*I^aʺ(Bɥwf?wA-D_SWp<Yașy/$sjgyb	*O`4x- "Xr1o<>c36V0@?b:b>1c[b=G-X4=3Shx-f'xh%hQha@ vc
gii,c2L*sei
^)GGb=@kF<a7Tn;Vcg#|tkeջPA{Kg]OtU,UPGx5%y2|<O;Ui泟`9MO>FǓpg5j`dq/i:i|C+!ۆB?xqjpwdr;-!]^o3U^D>$ɨ{p.4R6p!]sY*bjj|
?1L7͉ WIN'TsViEtZy9wc"$%e*GDǩU[C(R|£yty=ꦠɣ&dwt7uE5=7r\8k*Ynۜ@S^/b<h2a9
<Yz=֡~65[b2̸5&KLרy|y,fLvxcWU33:W
s0 l.7iu/<lv}݁>q$1&5?v"%|S|w$+,D&!_ZOG)o"`"#ouǫѪW՛5Re,A
܇a7.0/7d>&N W)muU,)׹{L|w7n?r/n>n{[/XWje/9y(Po)yNx&Hr	adtL1ZM0#gK5aݕgce1]W[JMfgGV,~ ;%Jգp~:nњsl.^d4Jg.Diz7Z$VqمBK)&Q`EB=;9" sn`z[}#<yZqј'^YZ݈ɢR@9S<~cD\TWg~xGۚ7RMr"*'f-U'.\H׵#O:?C\UMsDh̞QSW]Щ;?Wgi~}&^1n\)1p6ˑVR}ebI]g*8!a&VgT71O~$oQi-
Gx $æh@^w%N"$.~yNa0T0ʂ>HK=GK*kB_ƙm6ylY/+sT375W;(L*(윆أĶqo4 n|%f1ah&A![];/>2ɥat>lFB4\ljb	ḽVLϫGTDT[ >Dv@߿_A,M	k	}KT!,`*z'1/n75_"3?;y(ZAe{:UtV8V!^@	NjwX	 tLRj5z
_uP}9'ĥ׏tIkP>k~1AOliocе{:90&^ #`~cCj Җi`U!!<#bc[>Hv+UحvJՎ%|l`32]/jL~| :9V)<?w{]9CUu?V`\0돍A6 /{B[@Kvi<mMT@Mtw
WDEOPI{̴& eh_q
XĕW?F.&Qwgk^}2P31 9Gs"`nޮ|@LYAn8\'FIm/e!J?G|3YJ&#gL[hQ\hJ<&"X-ISh!?|##k"3hq`ᆄ2+:FGl/肹I+$Q.0_S9UZzߥ9{b)i9Rz]+j%~f	.;0,Nk\uZEz5PR8m4dsEbl~YiMf+ߘ,|T5Y8҈oҪWoPMYN%ǰGe^dl~5ZéWV3ǽ(]iFr5eMn6Nm&̟u w)r79,TDqSIS&Wzyɧ&jU=L@<xLbs89E@JC׷UfUz@\1Xi׾.i2h;B@HF95`yZ%B;T<y^b4ⰾ3 "/S,#@2=%g:wG-I<ʠ\۶ԑq|b2&;rJ!"!1#D%PI%`mJ3-o6"gL*ʹGjɦy+@:n&MՓjh D(݅`M=s\PY[i/c)bZ~b-WjCO ?SYa$`&K΅pXfla,u<.]Cg7SɯEwek
Jkv~0+xEk9p^;T_=f90?H	ĥqj5<{켑J1iLݳ.Sϙ6]@-wgv=j`_Ϧ/_+n*Zt
̟-ӮJm<D	˔ 	}@1BM 1m뒚Oўްo2FQvWv- {9:(MTL(%pɤ]D/*zz4{9^eP~nࡋs*1
-rpexMȜi=E=w&ES*W:4[=&V(7*a('&Xri?3U}/듋Hqa̈́У-U6]I&`/
TY<:kZ.rw3d`7s ao"~<*0?k0&-͟wd톧=a&PE)g=ARvSsb)QILV44z7J%5
$+I0҄͡z* XtzC~ۭ\6bln_iPQQɣTM]Lqh0|Xs']X-1Hf/>'8V>t2++\̳ci0H%V.#Yy #>'Hj2+d/e]4CԯJfteF+gE3Үbmpcxh{}b5[ޱayNL\OA	FKv'i ND_
:0W-pr95orvߏ2׌Ck$*u{)!}f	E?n)k,-RRWGQuEg8d?+0gu+q5eqb?7f9pc&f)7@kۘ+(vof1 ceNǅc^T)
_upS\DF/&!<a5לN-=jX
0_nӫ-jx陊,`>Dd?sO2%P M`k:R?
$6iWp%vx[~t|w(X0SN韥&x??>g`F7;m?4Lf[*Mh0fjYAfRpCM9@jĺ/1"wiz8C~WK_ڕa	E4s<pQh3]6Y%@AI8uB-ݗx"Zq\G*$ar;ʣJZfNjjost?FI)Lo@P)Qqe ,4iΡچ  z]ڨv|fiܪP (d+雲_eW {ěl)N?j-:OY9ǆ&eU`4J7E؏ZTHnKA8n8P0ÜVxn{%.|ѷcuSغ*#_#V!H4ܴ^σhAHOJJrN>YZ'<pL]
F2(ꦾu|y$ȺLA066hѳ	jC@S ـֶXqtڛi&cTLrI<4۠}g^Υz33}Ĕ좠=azYisAf߾"43[=:2[C%&GBҊDkL5:{|ݴڒRCǫ	9+[w(6&STIDBe̸5 bwj'˟X'7Y߅5+:u9Eu5>\.sCZIDWBE?Z8RjJBnH)a=kIels9ɱI,*]_1&0AK&JJ]&b'4w* Q%>.tGD m&ۡJjPslЯ'$v^G|@Qv<z.8L5A #6R5.IhCK:PFx[s`FOI-hIGT[8LqL+.g?V }DE(]^s;u$rp+kz3i{-1|_@vn<tTXZFCpd>tO5gn}_O,g!4I7*x$?>DSrhϔrr8	5Oiˆ/f -D[t(xga^c(pDؙ$f'&DlB~C9elA̖HmSxY-Z 9ݱoU|Q3.xe-e)̹o>#>hU
WL7{n)}Τlrʃ!኷[bʝ+W&f{.z512%ȽSfgG)uƴɵ*)nU1F%z->`,
2,̝ʿbL&@V5D 碯c;Jm43We q#eouġʕ#T́R6 >M5`ē3{H hr?r>8b?d{q	K 
vEuRLrW0`|7o)Get{*T9[}o'hs򚲤5tt(9"l;8ߝO\`2őnLpaU%n+Δ9)QCxܑxBb\
YVc_<Аg#kU`jh]-CC쓙μDs73̝/f{eo90rOPqL'W~S|hsf:Ŏ-)Ac)^ԤNO1|ޯ+TsmfuOٛ}[/oRv>x.ox$C(ohvGKD;А,0 )l&PJh]<?d@jz[UhGPcl?[W=k5Ob+j^`huc%ΡX7?](WԖ'݂kFN+Ě(8R&$Aj_8šs}ע>}0ioaHr-&!E^㪑,+l2:z>x|%5u?74nS<Nc[$0fI
1v_AXl۸/]%C^F~EHI`c%<- m
^\'+8.6{c_쮷AVp0/|<\!c&75"-70?\\癩ȠEؗH3bf(;Uv5p-<oFb2@}גksZ!/V|5&Գo1t`	-!eultڪ߬|LnTזI/R(*@`@@aõ[la-T ohN{C{jR$z`t%+lwjQk6/}WkbFe 6o;u5ZQV)ΨJ?GqqD߱6fiP.
˭k }̓n%xEcI|[ %8CH\:}VOiTgXkuB:ą]H2A8}ow&*[@'=IzM;^Yu_H7?0uC]kI۟O/ƌ(zR?GkK{N[N!sBEԄ%JB=RL^Ì७gPƒX	 P$ШputI٨0y*S@b1#j1{i%ȗdw2o|,̦2%L_2 o{-sSA!XH?ȧs
MBeHAN9ϲjis; /mEhӉE^gqq\QK(qc7"Kdj1|xH3l^G^k
-m8KuX%}Fˏ\}6Exbxcyn[ƲzJ(A/M32x7hϸû֔R6&		f>"7&_2|T ߧB삳e		ڔE$Igp5S9HQ@1
{e7&a
f(13BC v!5j]0sL
yRU`838$vs@Jd3+)"A9QdZ|ed3a%s#)W#,^kp
#BヿgА<<)!k\;rZ=4~F:#kYpVî͈,xٔ.tAKJo0è|\,2	_1A}Q%`\ιw#)۞Ab[4#3;"o,_cd2`\t9%'?C2FT